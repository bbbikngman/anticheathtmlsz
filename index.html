<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>声网 RTC 双工对话客户端</title>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.0.js"></script>
    <script src="web_uid_validator.js"></script>
    <script src="web_subscription_manager.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #5a67d8 0%, #805ad5 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #1a202c;
        padding: 24px;
      }

      .container {
        width: 100%;
        max-width: 900px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 20px;
        padding: 32px;
        box-shadow: 0 20px 60px rgba(67, 56, 202, 0.18);
      }

      header {
        text-align: center;
        margin-bottom: 24px;
      }

      header h1 {
        font-size: 2.2rem;
        color: #2d3748;
        margin-bottom: 8px;
      }

      header p {
        color: #4a5568;
      }

      .status-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }

      .status-card {
        background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        border-radius: 14px;
        padding: 18px;
        border: 1px solid #cbd5f5;
      }

      .status-card h2 {
        font-size: 1rem;
        color: #2b6cb0;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .status-value {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .status-value.online {
        color: #2f855a;
      }

      .status-value.offline {
        color: #c53030;
      }

      .status-value.idle {
        color: #b7791f;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-bottom: 24px;
        justify-content: center;
      }

      button {
        padding: 12px 28px;
        border: none;
        border-radius: 999px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: #fff;
      }

      button.primary {
        background: linear-gradient(135deg, #48bb78, #38a169);
      }

      button.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button.danger {
        background: linear-gradient(135deg, #f56565, #e53e3e);
      }

      button.danger:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      /* 一个没用的注释，触发重启 */
      .meter {
        background: #edf2f7;
        border-radius: 14px;
        padding: 12px 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.95rem;
        color: #4a5568;
      }

      .meter span {
        font-weight: 600;
        color: #2d3748;
      }

      .meter-bar {
        margin-top: 8px;
        width: 180px;
        height: 10px;
        background: #e2e8f0;
        border-radius: 999px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #63b3ed, #3182ce);
        transition: width 0.1s ease;
      }

      .conversation-log {
        background: #f7fafc;
        border-radius: 14px;
        border: 1px solid #e2e8f0;
        padding: 18px;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-entry {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px dashed rgba(160, 174, 192, 0.5);
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry time {
        display: block;
        font-size: 0.8rem;
        color: #718096;
        margin-bottom: 4px;
      }

      .log-entry strong {
        display: inline-block;
        min-width: 70px;
        color: #2b6cb0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 12px;
        justify-content: center;
        margin-top: 8px;
      }

      .volume-control label {
        font-weight: 600;
        color: #2d3748;
      }

      .volume-control input {
        width: 220px;
      }

      .conversation-log {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        margin: 24px 0;
        max-height: 300px;
        overflow-y: auto;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 0.9rem;
      }

      .log-entry {
        margin-bottom: 8px;
        padding: 8px;
        border-radius: 6px;
        background: white;
        border-left: 4px solid #cbd5e0;
      }

      .log-entry.stt {
        border-left-color: #4299e1;
        background: #ebf8ff;
      }

      .log-entry.llm {
        border-left-color: #48bb78;
        background: #f0fff4;
      }

      .log-entry.error {
        border-left-color: #f56565;
        background: #fed7d7;
        color: #c53030;
      }

      .log-entry time {
        font-size: 0.8rem;
        color: #718096;
        margin-right: 8px;
      }

      .log-entry .source {
        font-weight: 600;
        margin-right: 8px;
      }

      .log-entry .source.stt {
        color: #2b6cb0;
      }

      .log-entry .source.llm {
        color: #2f855a;
      }

      .log-entry .source.error {
        color: #c53030;
      }

      .error-popup {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #fed7d7;
        border: 1px solid #feb2b2;
        border-radius: 8px;
        padding: 16px;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
      }

      .error-popup .error-title {
        font-weight: 600;
        color: #c53030;
        margin-bottom: 8px;
      }

      .error-popup .error-message {
        color: #742a2a;
        font-size: 0.9rem;
      }

      .error-popup .close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 1.2rem;
        color: #c53030;
        cursor: pointer;
        padding: 4px;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .websocket-status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .websocket-status.connected {
        background: #48bb78;
      }

      .websocket-status.disconnected {
        background: #f56565;
      }

      .websocket-status.connecting {
        background: #ed8936;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      footer {
        margin-top: 24px;
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
      }

      footer code {
        background: #edf2f7;
        padding: 2px 6px;
        border-radius: 6px;
      }

      .control-button.active {
        background-color: #48bb78;
        color: white;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>声网 RTC 双工对话客户端</h1>
        <p>浏览器直接加入声网频道，上行麦克风、下行 Bot 音频</p>
      </header>

      <section class="status-panel">
        <div class="status-card">
          <h2>连接状态</h2>
          <div id="connectionStatus" class="status-value offline">未连接</div>
          <p id="statusHint">点击开始对话即可连接声网</p>
        </div>
        <div class="status-card">
          <h2>频道信息</h2>
          <div class="status-value">
            <div>频道：<span id="channelName">-</span></div>
            <div>本地 UID：<span id="localUid">-</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>Bot 状态</h2>
          <div class="status-value">
            <div>远端 UID：<span id="remoteUid">-</span></div>
            <div>音量：<span id="remoteVolume">70%</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>调试连接</h2>
          <div class="status-value">
            <div><span class="websocket-status disconnected" id="wsStatus"></span>WebSocket：<span id="wsStatusText">未连接</span></div>
            <div>消息数：<span id="wsMessageCount">0</span></div>
          </div>
        </div>
      </section>

      <section class="controls">
        <button id="connectButton" class="primary">开始对话</button>
        <button id="disconnectButton" class="danger" disabled>断开连接</button>
        <button id="exportLogsButton" class="primary">导出日志</button>
      </section>

      <!-- Dify App Selection -->
      <div class="controls-panel">
        <div class="control-group">
          <span class="control-label">选择Dify应用:</span>
          <div class="buttons">
            <button id="difyApp1Button" class="control-button" data-app="dify_app_1" onclick="setDifyApp('dify_app_1')">通用应用</button>
            <button id="difyApp2Button" class="control-button active" data-app="dify_app_2" onclick="setDifyApp('dify_app_2')">反诈应用</button>
          </div>
        </div>
      </div>

      <section class="meter">
        <div>
          <span>麦克风电平</span>
          <div class="meter-bar">
            <div id="micBar" class="meter-fill"></div>
          </div>
        </div>
        <div>
          <span id="micLevel">0%</span>
        </div>
      </section>

      <div class="volume-control">
        <label for="volumeSlider">Bot 音量</label>
        <input id="volumeSlider" type="range" min="0" max="100" value="70" />
      </div>



      <section class="conversation-log" id="logContainer"></section>

      <div id="remoteAudio"></div>

      <footer>
        <div>
          调试命令：<code
            >curl https://cityuantifraud.cn/api/agora/config</code
          >
        </div>
      </footer>
    </div>

    <script>
      /**
       * 路由原则：
       * 1) 预录音频 & cache_index.json 统一从后端读取：
       *    `${API_BASE_URL}/prerecorded_audio/cache_index.json`
       *    `${API_BASE_URL}/prerecorded_audio/audio_files/<file>.mp3`
       * 2) RTC/业务相关只打后端（cityuantifraud.cn）。
       * 3) Bot 实时音频来自 Agora 订阅的远端 track，与上述静态音频无关。
       */

      /************** ① 捕捉 F12 控制台日志（log/info/warn/error/debug + 全局错误） **************/
      (function setupConsoleCapture() {
        const levels = ["log", "info", "warn", "error", "debug"];
        const original = {};
        const MAX_LOGS = 20000; // 为了安全做个上限；需要放开可以改大
        window.__consoleLogs = [];

        function argToString(a) {
          try {
            if (a instanceof Error) return a.stack || (a.name + ": " + a.message);
            if (typeof a === "object" && a !== null) {
              // 安全 stringify（处理循环引用/DOM）
              const seen = new WeakSet();
              return JSON.stringify(
                a,
                (k, v) => {
                  if (typeof v === "object" && v !== null) {
                    if (seen.has(v)) return "[Circular]";
                    if (v instanceof Node) return `[DOM:${v.nodeName}]`;
                    seen.add(v);
                  }
                  return v;
                },
                2
              );
            }
            return String(a);
          } catch {
            try { return String(a); } catch { return "[Unserializable]"; }
          }
        }

        levels.forEach((level) => {
          original[level] = console[level].bind(console);
          console[level] = function (...args) {
            try {
              window.__consoleLogs.push({
                ts: Date.now(),
                level,
                args: args.map(argToString),
              });
              if (window.__consoleLogs.length > MAX_LOGS) {
                window.__consoleLogs.splice(0, window.__consoleLogs.length - MAX_LOGS);
              }
            } catch {}
            original[level](...args);
          };
        });

        window.addEventListener("error", (e) => {
          try {
            window.__consoleLogs.push({
              ts: Date.now(),
              level: "error",
              args: [
                `UncaughtError: ${e.message}`,
                `${e.filename}:${e.lineno}:${e.colno}`,
              ],
            });
          } catch {}
        });

        window.addEventListener("unhandledrejection", (e) => {
          try {
            const reason = e && e.reason !== undefined ? e.reason : "unknown";
            window.__consoleLogs.push({
              ts: Date.now(),
              level: "error",
              args: [`UnhandledRejection: ${argToString(reason)}`],
            });
          } catch {}
        });

        // 导出为纯文本
        window.__getConsoleLogText = function () {
          return (window.__consoleLogs || [])
            .map(({ ts, level, args }) => {
              const t = new Date(ts).toLocaleString();
              return `[${t}] [${level.toUpperCase()}] ${args.join(" ")}`;
            })
            .join("\n");
        };
      })();

      /************** ② 把 UI 区域日志 + 页面状态 汇总成文本 **************/
      function getUiLogText() {
        const container = document.getElementById("logContainer");
        if (!container) return "";
        const items = container.querySelectorAll(".log-entry");
        const lines = [];
        items.forEach((n) => {
          const t = (n.querySelector("time")?.textContent || "").trim();
          const s = (n.querySelector(".source")?.textContent || "日志").trim();
          // 取该条里所有 <div> 的文本作为内容
          const content = Array.from(n.querySelectorAll("div"))
            .map((d) => (d.textContent || "").trim())
            .filter(Boolean)
            .join(" ");
          lines.push(`${t}  ${s}  ${content}`);
        });
        return lines.join("\n");
      }

      function buildUserInfoText() {
        // 你的信息栏关键字段
        const get = (el) => (el ? el.textContent.trim() : "-");
        const info = [
          `时间: ${new Date().toLocaleString()}`,
          `URL: ${location.href}`,
          `UA: ${navigator.userAgent}`,
          `平台: ${navigator.platform || "n/a"}`,
          `语言: ${navigator.language || "n/a"}`,
          `窗口: ${window.innerWidth}x${window.innerHeight}`,
          `网络: ${
            navigator.connection
              ? `${navigator.connection.effectiveType || "n/a"}, ${navigator.connection.downlink || "?"}Mb/s`
              : "n/a"
          }`,
        ];

        const els = {
          connectionStatus: document.getElementById("connectionStatus"),
          channelName: document.getElementById("channelName"),
          localUid: document.getElementById("localUid"),
          remoteUid: document.getElementById("remoteUid"),
          remoteVolume: document.getElementById("remoteVolume"),
          wsStatusText: document.getElementById("wsStatusText"),
          wsMessageCount: document.getElementById("wsMessageCount"),
          micLevel: document.getElementById("micLevel"),
        };

        const state = [
          `连接状态: ${get(els.connectionStatus)}`,
          `频道: ${get(els.channelName)}`,
          `本地UID: ${get(els.localUid)}`,
          `远端UID: ${get(els.remoteUid)}`,
          `Bot音量: ${get(els.remoteVolume)}`,
          `WebSocket: ${get(els.wsStatusText)}，消息数 ${get(els.wsMessageCount)}`,
          `麦克风电平: ${get(els.micLevel)}`,
        ];

        return `--- 环境信息 ---\n${info.join("\n")}\n\n--- 页面状态 ---\n${state.join("\n")}`;
      }

      /************** ③ 兼容性最强的弹窗（含：全选 + 复制 按钮） **************/
      function showLogsInPopup(fullText) {
        // 蒙层
        const mask = document.createElement("div");
        Object.assign(mask.style, {
          position: "fixed",
          inset: 0,
          background: "rgba(0,0,0,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          zIndex: 9999,
          padding: "16px",
        });

        // 面板
        const panel = document.createElement("div");
        Object.assign(panel.style, {
          width: "min(920px, 96vw)",
          background: "#fff",
          borderRadius: "14px",
          boxShadow: "0 10px 30px rgba(0,0,0,0.2)",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
        });

        // 工具条
        const toolbar = document.createElement("div");
        Object.assign(toolbar.style, {
          display: "flex",
          gap: "8px",
          padding: "12px",
          borderBottom: "1px solid #e2e8f0",
          background: "#f7fafc",
          alignItems: "center",
          justifyContent: "space-between",
        });
        const left = document.createElement("div");
        left.textContent = "已汇总：页面信息 + UI日志 + 控制台日志";
        Object.assign(left.style, { color: "#2d3748", fontWeight: "600" });

        const btnWrap = document.createElement("div");
        Object.assign(btnWrap.style, { display: "flex", gap: "8px" });

        function mkBtn(text, color) {
          const b = document.createElement("button");
          b.textContent = text;
          Object.assign(b.style, {
            border: "none",
            borderRadius: "999px",
            padding: "8px 16px",
            fontWeight: "700",
            cursor: "pointer",
            color: "#fff",
            background: color,
          });
          return b;
        }
        const btnSelectAll = mkBtn("全选", "#3182ce");
        const btnCopy = mkBtn("复制", "#38a169");
        const btnClose = mkBtn("关闭", "#e53e3e");

        btnWrap.append(btnSelectAll, btnCopy, btnClose);
        toolbar.append(left, btnWrap);

        // 文本区域（用 textarea，移动端/微信可长按）
        const ta = document.createElement("textarea");
        ta.value = fullText;
        ta.readOnly = true;
        Object.assign(ta.style, {
          width: "100%",
          height: "70vh",
          border: "none",
          outline: "none",
          padding: "12px 16px",
          fontFamily: "Consolas, Monaco, monospace",
          fontSize: "13px",
          whiteSpace: "pre-wrap",
          boxSizing: "border-box",
        });

        panel.append(toolbar, ta);
        mask.append(panel);
        document.body.appendChild(mask);

        // 事件
        btnClose.onclick = () => mask.remove();

        btnSelectAll.onclick = () => {
          ta.focus();
          ta.select();
          // iOS 兼容：setSelectionRange
          try { ta.setSelectionRange(0, ta.value.length); } catch {}
        };

        btnCopy.onclick = async () => {
          // 先尝试 Clipboard API（安全上下文）
          let ok = false;
          try {
            if (navigator.clipboard && window.isSecureContext) {
              await navigator.clipboard.writeText(ta.value);
              ok = true;
            }
          } catch {}
          // 再退回 execCommand
          if (!ok) {
            try {
              ta.focus();
              ta.select();
              try { ta.setSelectionRange(0, ta.value.length); } catch {}
              ok = document.execCommand("copy");
            } catch { ok = false; }
          }
          // 提示
          const tip = document.createElement("div");
          tip.textContent = ok ? "✅ 已复制到剪贴板" : "❌ 复制失败，请长按文本手动复制";
          Object.assign(tip.style, {
            position: "absolute",
            bottom: "12px",
            left: "50%",
            transform: "translateX(-50%)",
            background: ok ? "#48bb78" : "#e53e3e",
            color: "#fff",
            padding: "6px 12px",
            borderRadius: "999px",
            fontWeight: "700",
            fontSize: "12px",
          });
          panel.appendChild(tip);
          setTimeout(() => tip.remove(), 1800);
        };

        // 打开时默认把光标放进去，便于手动长按
        setTimeout(() => { ta.focus(); }, 50);
      }

      /************** ④ "导出日志"按钮点击逻辑（自动汇总三类内容） **************/
      function collectAllLogsText() {
        const userInfo = buildUserInfoText();
        const uiLogs = getUiLogText();
        const consoleLogs =
          (window.__getConsoleLogText && window.__getConsoleLogText()) || "";

        const lines = [
          "===================== 调试日志导出 =====================",
          new Date().toLocaleString(),
          "========================================================",
          "",
          userInfo,
          "",
          "--- UI 日志（页面可见区域） ---",
          uiLogs || "(无)",
          "",
          "--- Console 日志（F12 控制台） ---",
          consoleLogs || "(无)",
          "",
        ];
        return lines.join("\n");
      }

      // === AudioGate：一次解锁，后续任意播放 ===
      function createAudioGate({ poolSize = 4 } = {}) {
        let unlocked = false;
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const pool = [];

        // 预创建一组 <audio>，后续统一复用
        for (let i = 0; i < poolSize; i++) {
          const a = document.createElement('audio');
          a.preload = 'auto';
          a.setAttribute('playsinline', '');
          a.playsInline = true;
          a.controls = false;
          a.style.display = 'none';
          a.crossOrigin = 'anonymous';
          document.body.appendChild(a);
          pool.push(a);
        }

        async function unlock() {
          if (unlocked) return;
          try {
            console.log('[AudioGate] 开始解锁音频环境...');
            
            // 1) 唤醒 WebAudio
            await ctx.resume();

            // 2) 用一次用户手势"祝福"所有 <audio> 元素
            //    播一段极短静音音频 -> 立即 pause -> 元素进入已授权状态
            const silent =
              'data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA';
            await Promise.all(
              pool.map(async (el) => {
                try {
                  el.src = silent;
                  el.volume = 0.001;
                  await el.play();
                  el.pause();
                  el.currentTime = 0;
                  el.removeAttribute('src');
                  el.load(); // 清空，等待后续真正的 src
                } catch (e) {
                  // 部分浏览器这里可能拒绝，但只要有一次成功就足够
                  console.warn('[AudioGate] bless one element failed:', e.message);
                }
              })
            );

            // 3) 保险：用一个隐藏 iframe 自动播一次静音，覆盖部分内核边角
            try {
              const iframe = document.createElement('iframe');
              iframe.allow = 'autoplay';
              iframe.style.display = 'none';
              iframe.srcdoc =
                '<audio autoplay ' +
                'src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA"></audio>';
              document.body.appendChild(iframe);
              setTimeout(() => iframe.remove(), 2000);
            } catch {}

            unlocked = true;
            window.__audioGate__ = { ctx, pool, unlocked: true };
            console.log('[AudioGate] ✅ 音频环境已成功解锁');
          } catch (err) {
            console.warn('[AudioGate] unlock failed:', err);
          }
        }

        function getFreeElement() {
          // 找一个空闲 <audio>（暂停或已结束），没有就用第一个（会打断它）
          return pool.find((el) => el.paused || el.ended) || pool[0];
        }

        async function play(url, { volume = 1.0, loop = false } = {}) {
          if (!unlocked) throw new Error('Audio not unlocked yet');
          const el = getFreeElement();
          el.volume = volume;
          el.loop = loop;
          el.setAttribute('playsinline', '');
          el.playsInline = true;
          el.src = url;
          try {
            await el.play();
            return el; // 返回正在播放的 <audio>
          } catch (err) {
            // HTMLMediaElement 播放失败时，降级走 WebAudio 解码播放（几乎总能播）
            console.warn('[AudioGate] media play() failed, fallback to WebAudio:', err);
            try {
              const resp = await fetch(url);
              const buf = await resp.arrayBuffer();
              const audioBuf = await ctx.decodeAudioData(buf);
              const node = ctx.createBufferSource();
              node.buffer = audioBuf;
              node.connect(ctx.destination);
              node.start(0);
              return node; // 返回 WebAudio 的节点
            } catch (e) {
              console.error('[AudioGate] fallback failed:', e);
              throw err;
            }
          }
        }

        // 页面回前台自动 resume（很多时候不需要用户手势）
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible' && ctx.state === 'suspended') {
            ctx.resume().catch(() => {});
          }
        });
        // 任意交互时也尝试 resume（如果被系统挂起，用户随手点一下任何位置即可恢复）
        ['pointerdown', 'touchstart', 'keydown'].forEach((evt) => {
          window.addEventListener(
            evt,
            () => {
              if (ctx.state === 'suspended') ctx.resume().catch(() => {});
            },
            { passive: true }
          );
        });

        return { unlock, play, get unlocked() { return unlocked; }, ctx, pool };
      }
      
      const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
      
      // 全局只建一次 AudioGate 实例
      const AudioGate = createAudioGate({ poolSize: 4 });
      
      let localTrack = null;
      let microphoneAudioTrack = null; // 添加缺失的变量定义
      let remoteAudioTrack = null;
      let agoraConfigCache = null;
      const backendBaseUrl = "https://cityuantifraud.cn";
      // 生产环境配置：API调用使用后端服务器，静态资源使用相对路径
      const API_BASE_URL = backendBaseUrl;
      
      // 新增一行（放在上面附近即可）
      const PREREC_BASE = `${backendBaseUrl}/prerecorded_audio`;

      // 静态资源一律相对路径；该函数只是确保不会出现以 / 开头的根路径导致跳到站点根
      const staticPath = (p) => (p || "").replace(/^\/+/, "");
      // 音频路径归一化：处理Windows反斜杠并确保相对路径
      const normalizeAudioPath = (p) => staticPath(String(p || '').replace(/\\/g, '/'));
      let isConnecting = false;
      let subscriptionManager = null;
      let audioContext = null;
      let analyser = null;
      let micDataArray = null;
      let meterAnimation = null;
      


      // WebSocket相关变量
      let debugWebSocket = null;
      let wsReconnectTimer = null;
      let wsMessageCount = 0;
      let wsReconnectAttempts = 0;
      const WS_MAX_RECONNECT_ATTEMPTS = 5;
      const WS_RECONNECT_DELAY = 3000;
      
      // === 统一去重：2s TTL ===
      const DEDUP_TTL_MS = 2000;           // ★ 2 秒 TTL
      const lastSeenMap = new Map();       // hash -> ts
      
      // 预录制音频播放状态跟踪
      let lastPrerecordedAudioTime = 0;
      const PRERECORDED_AUDIO_WINDOW = 1000; // 1秒内的assistant_text消息被认为是预录制音频相关
      
      // ===== 预录音频"播放锁"/节流 =====
      let prerecPlayingKey = null;
      let prerecAudioEl = null;
      const prerecRecent = new Map(); // key -> ts
      const PREREC_TTL_MS = 4000;     // 4s 内相同Key不重复播
      
      // ===== 播放排队机制：未解锁时先排队，解锁后一次性冲刷 =====
      const pendingAudioQueue = []; // {url, audioData}[]
      
      function normalizeTextKey(t) {
        return (t || "")
          .replace(/[，。！？；：、"'""''（）【】[\]\s]/g, "")
          .toLowerCase();
      }
      
      function keyFromAudioData(audioData, fallbackText) {
        if (audioData?.audio_file) return `file:${audioData.audio_file}`;
        if (audioData?.hash)       return `hash:${audioData.hash}`;
        const txt = audioData?.text || fallbackText || "";
        return `text:${normalizeTextKey(txt)}`;
      }
      
      // 播放排队相关函数
      function doPlay(audioUrl, audioData) {
        AudioGate.play(audioUrl, { volume: 1.0 }).then(player => {
          prerecAudioEl = player;

          // 结束清理（同时兼容 <audio> 与 WebAudio）
          if (player && typeof player.addEventListener === 'function') {
            player.addEventListener('ended', () => {
              prerecPlayingKey = null; 
              prerecAudioEl = null;
            });
          } else if (player && 'onended' in player) {
            player.onended = () => { 
              prerecPlayingKey = null; 
              prerecAudioEl = null; 
            };
          }
        }).catch(err => {
          console.error('[预录制音频] ❌ 播放失败:', err);
          log('系统', `预录制音频播放失败: ${err.message}`, 'error');
          prerecPlayingKey = null; 
          prerecAudioEl = null;
          // 如需：这里可继续调用 tryAlternativeUrls(audioUrl, audioData, 0)
        });
      }

      function enqueueOrPlay(audioUrl, audioData) {
        if (!AudioGate.unlocked) {
          pendingAudioQueue.push({ url: audioUrl, audioData });
          console.log('[预录制音频] ⏸ AudioGate 未解锁，排队：', audioUrl);
          return;
        }
        doPlay(audioUrl, audioData);
      }

      function flushPendingAudio() {
        if (!AudioGate.unlocked) return;
        while (pendingAudioQueue.length) {
          const { url, audioData } = pendingAudioQueue.shift();
          doPlay(url, audioData);
        }
      }
      
      const elements = {
        connectionStatus: document.getElementById("connectionStatus"),
        statusHint: document.getElementById("statusHint"),
        channelName: document.getElementById("channelName"),
        localUid: document.getElementById("localUid"),
        remoteUid: document.getElementById("remoteUid"),
        remoteVolume: document.getElementById("remoteVolume"),
        connectButton: document.getElementById("connectButton"),
        disconnectButton: document.getElementById("disconnectButton"),
        volumeSlider: document.getElementById("volumeSlider"),
        micLevel: document.getElementById("micLevel"),
        micBar: document.getElementById("micBar"),
        logContainer: document.getElementById("logContainer"),
        wsStatus: document.getElementById("wsStatus"),
        wsStatusText: document.getElementById("wsStatusText"),
        wsMessageCount: document.getElementById("wsMessageCount"),
      };

      // 简单的字符串hash函数
      function simpleHash(str) {
        let hash = 0;
        if (str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // 转换为32位整数
        }
        return hash.toString();
      }

      function normalizeForHash(s) {
        // 移除"（触发预录制）"后缀，确保去重正确识别相同内容
        return (s || '')
          .replace(/（触发预录制）$/, '')  // 移除结尾的"（触发预录制）"
          .replace(/\s+/g, ' ')           // 合并空白，避免无意义差异
          .trim();
      }

      // 🔧 统一的音频URL构建函数
      function buildAudioURL(audioFilePath) {
        if (!audioFilePath) return null;
        
        // 如果已经是完整的HTTP(S) URL，直接返回
        if (/^https?:\/\//i.test(audioFilePath)) {
          return audioFilePath;
        }
        
        // 获取基础URL，优先使用API_BASE_URL，否则使用当前域名
        const base = (typeof API_BASE_URL === 'string' ? API_BASE_URL : window.location.origin).replace(/\/+$/, '');
        
        // 确保路径以 / 开头
        let path = audioFilePath;
        if (!path.startsWith('/')) {
          path = '/' + path;
        }
        
        return base + path;
      }

      function shouldDedup(source, message, type) {
        const keyType = (type || source || 'info').toString().toLowerCase();
        const hash = simpleHash(`${keyType}|${normalizeForHash(message)}`);
        const now = Date.now();
        const prev = lastSeenMap.get(hash) || 0;

        if (now - prev < DEDUP_TTL_MS) {
          console.log(`[去重] ${keyType} 在 ${now - prev}ms 内重复，跳过: "${(message || '').slice(0,50)}..."`);
          return true;
        }
        lastSeenMap.set(hash, now);
        return false;
      }

      // 定期清理过期的hash记录，防止Map膨胀
      setInterval(() => {
        const now = Date.now();
        for (const [k, ts] of lastSeenMap.entries()) {
          if (now - ts > 60000) lastSeenMap.delete(k);
        }
      }, 30000);



      function log(source, message, type = "info") {
        // 统一 2 秒 TTL 去重
        if (shouldDedup(source, message, type)) return;
        
        const entry = document.createElement("div");
        entry.className = "log-entry";
        const timestamp = new Date().toLocaleTimeString();
        
        // 根据消息类型设置样式
        if (type === "stt" || source === "STT") {
          entry.classList.add("stt");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source stt">语音识别</span>
            <div>${message}</div>
          `;
        } else if (type === "llm" || source === "LLM") {
          entry.classList.add("llm");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source llm">AI回复</span>
            <div>${message}</div>
          `;
        } else if (type === "error") {
          entry.classList.add("error");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source error">${source}</span>
            <div>${message}</div>
          `;
        } else {
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source">${source}</span>
            <div>${message}</div>
          `;
          if (type === "success") {
            entry.style.color = "#2f855a";
          }
        }
        
        elements.logContainer.appendChild(entry);
        elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
      }

      function setConnectionState(state, hint) {
        elements.connectionStatus.classList.remove("online", "offline", "idle");
        elements.connectionStatus.classList.add(state);
        elements.connectionStatus.textContent =
          state === "online"
            ? "已连接"
            : state === "offline"
            ? "未连接"
            : "准备中";
        if (hint) {
          elements.statusHint.textContent = hint;
        }
      }

      // WebSocket状态更新函数
      function updateWebSocketStatus(status, text) {
        elements.wsStatus.className = `websocket-status ${status}`;
        elements.wsStatusText.textContent = text;
      }

      // 显示错误弹窗
      function showErrorPopup(title, message) {
        // 移除已存在的错误弹窗
        const existingPopup = document.querySelector('.error-popup');
        if (existingPopup) {
          existingPopup.remove();
        }

        const popup = document.createElement('div');
        popup.className = 'error-popup';
        popup.innerHTML = `
          <button class="close-btn" onclick="this.parentElement.remove()">×</button>
          <div class="error-title">${title}</div>
          <div class="error-message">${message}</div>
        `;
        
        document.body.appendChild(popup);
        
        // 5秒后自动关闭
        setTimeout(() => {
          if (popup.parentElement) {
            popup.remove();
          }
        }, 5000);
      }

      // 🎵 预加载音频文件函数
      async function preloadAudioFiles() {
        try {
          console.log('[预加载] 🎵 开始预加载音频文件...');
          log('系统', '正在预加载音频文件...', 'info');
          
          // 加载缓存索引
          const cacheIndexUrl = `${PREREC_BASE}/cache_index.json`;
          const response = await fetch(cacheIndexUrl);
          if (!response.ok) {
            console.warn('[预加载] ⚠️ 无法加载缓存索引，跳过预加载');
            return;
          }
          
          const cacheIndex = await response.json();
          const audioFiles = Object.values(cacheIndex).map(entry => entry.audio_file).filter(Boolean);
          console.log(`[预加载] 📋 发现 ${audioFiles.length} 个音频文件需要预加载`);
          
          // 限制并发预加载数量，避免过多请求
          const maxConcurrent = 3;
          let loadedCount = 0;
          let failedCount = 0;
          
          for (let i = 0; i < audioFiles.length; i += maxConcurrent) {
            const batch = audioFiles.slice(i, i + maxConcurrent);
            const promises = batch.map(async (audioFile) => {
              try {
                // 1) 使用统一的URL构建函数，确保生成正确的绝对URL
                const audioPath = `prerecorded_audio/audio_files/${audioFile}`;
                const audioUrl = encodeURI(buildAudioURL(audioPath));
                
                // 使用 AudioGate 的音频池预加载
                // 这里我们不实际播放，只是让浏览器缓存这些文件
                const tempAudio = new Audio(audioUrl);
                tempAudio.crossOrigin = 'anonymous';
                tempAudio.preload = 'auto';
                tempAudio.volume = 0;
                
                return new Promise((resolve) => {
                  // 2) 成功标准放宽：loadedmetadata / canplay / canplaythrough 任一触发即算成功
                  const onSuccess = (evt) => {
                    clearTimeout(t);
                    tempAudio.onloadedmetadata = null;
                    tempAudio.oncanplay = null;
                    tempAudio.oncanplaythrough = null;
                    tempAudio.onerror = null;
                    console.log(`[预加载] ✅ ${audioFile} 预加载成功（${evt?.type}）`);
                    loadedCount++;
                    resolve();
                  };
                  const onError = (e) => {
                    clearTimeout(t);
                    tempAudio.onloadedmetadata = null;
                    tempAudio.oncanplay = null;
                    tempAudio.oncanplaythrough = null;
                    tempAudio.onerror = null;
                    console.warn(`[预加载] ⚠️ ${audioFile} 预加载失败`);
                    failedCount++;
                    resolve();
                  };
                  tempAudio.onloadedmetadata = onSuccess;
                  tempAudio.oncanplay = onSuccess;
                  tempAudio.oncanplaythrough = onSuccess;
                  tempAudio.onerror = onError;

                  // 3) 一定要保存并在成功/失败时 clearTimeout
                  const t = setTimeout(() => {
                    onError(new Error('timeout'));
                  }, 12000); // 适当放宽到 12s，避免慢网/冷缓存误判
                });
              } catch (error) {
                console.warn(`[预加载] ❌ ${audioFile} 预加载异常:`, error);
                failedCount++;
              }
            });
            
            await Promise.all(promises);
            
            // 显示进度
            const progress = Math.round(((i + batch.length) / audioFiles.length) * 100);
            console.log(`[预加载] 📊 进度: ${progress}% (${loadedCount}/${audioFiles.length} 成功, ${failedCount} 失败)`);
          }
          
          console.log(`[预加载] 🎉 预加载完成: ${loadedCount}/${audioFiles.length} 成功, ${failedCount} 失败`);
          log('系统', `音频预加载完成: ${loadedCount}/${audioFiles.length} 成功`, loadedCount > 0 ? 'success' : 'warning');
          
        } catch (error) {
          console.error('[预加载] ❌ 预加载过程出错:', error);
          log('系统', '音频预加载失败', 'error');
        }
      }

      // 🔧 尝试备用URL的函数
      function tryAlternativeUrls(originalPath, audioData, urlIndex) {
        const base = normalizeAudioPath(originalPath);
        const basename = base.split(/[\/\\]/).pop();
        const alternativeUrls = [
          buildAudioURL(`prerecorded_audio/audio_files/${basename}`),
          buildAudioURL(`prerecorded_audio/audio_files/${base}`)
        ];
        
        if (!AudioGate.unlocked) {
          // 等解锁后再重试，避免"未解锁→多次失败"刷屏
          pendingAudioQueue.push({ url: alternativeUrls[0], audioData });
          return;
        }
        
        if (urlIndex >= alternativeUrls.length) {
          console.error('[预录制音频] ❌ 所有备用URL都失败了');
          log('系统', '预录制音频: 所有URL都无法访问', 'error');
          return;
        }
        
        const testUrl = alternativeUrls[urlIndex];
        console.log(`[预录制音频] 🔧 测试备用URL ${urlIndex + 1}/${alternativeUrls.length}:`, testUrl);
        
        // 使用 AudioGate 尝试播放备用URL
        AudioGate.play(testUrl, { volume: 1.0 }).then(audioElement => {
          console.log(`[预录制音频] ✅ 备用URL ${urlIndex + 1} 成功:`, testUrl);
          log('系统', `预录制音频: 使用备用URL播放`, 'success');
          
          // 更新全局播放状态
          prerecAudioEl = audioElement;
          
          // 结束清理（同时兼容 <audio> 与 WebAudio）
          if (audioElement && typeof audioElement.addEventListener === 'function') {
            audioElement.addEventListener('ended', () => {
              console.log('[预录制音频] 备用URL音频播放完成');
              prerecPlayingKey = null;
              prerecAudioEl = null;
            });
          } else if (audioElement && 'onended' in audioElement) {
            audioElement.onended = () => {
              console.log('[预录制音频] 备用URL音频播放完成');
              prerecPlayingKey = null;
              prerecAudioEl = null;
            };
          }
        }).catch(error => {
          console.error(`[预录制音频] ❌ 备用URL ${urlIndex + 1} 失败:`, testUrl, error);
          tryAlternativeUrls(originalPath, audioData, urlIndex + 1);
        });
      }

      // 🔍 从缓存索引中查找并播放预录制音频
      async function tryFindAndPlayPrerecordedAudio(text, messageData) {
        try {
          console.log('[预录制音频] 🔍 开始查找音频文件:', text);
          
          // 🔍 尝试加载缓存索引
          const cacheIndexUrl = `${PREREC_BASE}/cache_index.json`;
          console.log('[预录制音频] 🔍 加载缓存索引:', cacheIndexUrl);
          
          const response = await fetch(cacheIndexUrl);
          if (!response.ok) {
            console.error('[预录制音频] ❌ 无法加载缓存索引:', response.status, response.statusText);
            return;
          }
          
          const cacheIndex = await response.json();
          console.log('[预录制音频] 🔍 缓存索引加载成功，条目数:', Object.keys(cacheIndex).length);
          
          // 🔍 查找匹配的音频文件
          let foundEntry = null;
          let foundHash = null;
          
          // 方法1: 直接文本匹配
          for (const [hash, entry] of Object.entries(cacheIndex)) {
            if (entry.text === text || entry.normalized_text === text) {
              foundEntry = entry;
              foundHash = hash;
              console.log('[预录制音频] ✅ 找到匹配文本的音频文件 (精确匹配):', hash, entry.audio_file);
              break;
            }
          }
          
          // 方法2: 如果精确匹配失败，尝试模糊匹配
          if (!foundEntry) {
            const normalizedText = text.replace(/[，。！？；：""''（）【】]/g, '').replace(/\s+/g, '');
            for (const [hash, entry] of Object.entries(cacheIndex)) {
              const entryNormalized = (entry.normalized_text || entry.text || '').replace(/[，。！？；：""''（）【】]/g, '').replace(/\s+/g, '');
              if (entryNormalized === normalizedText) {
                foundEntry = entry;
                foundHash = hash;
                console.log('[预录制音频] ✅ 找到匹配文本的音频文件 (模糊匹配):', hash, entry.audio_file);
                break;
              }
            }
          }
          
          if (foundEntry && foundEntry.audio_file) {
            // 🎵 构建音频文件路径
            const audioFilePath = `prerecorded_audio/audio_files/${foundEntry.audio_file}`;
            console.log('[预录制音频] 🎵 构建音频文件路径:', audioFilePath);
            
            // 播放音频文件
            playPrerecordedAudio(audioFilePath, {
              text: text,
              audio_file: foundEntry.audio_file,
              hash: foundHash,
              ...messageData
            });
          } else {
            console.warn('[预录制音频] ⚠️ 未找到匹配的音频文件:', text);
            console.log('[预录制音频] 🔍 可用的音频文件列表:');
            Object.entries(cacheIndex).slice(0, 5).forEach(([hash, entry]) => {
              console.log(`  - ${hash}: "${entry.text || entry.normalized_text}"`);
            });
          }
          
        } catch (error) {
          console.error('[预录制音频] ❌ 查找音频文件失败:', error);
        }
      }

      // 播放预录制音频文件
      function playPrerecordedAudio(audioFilePath, audioData) {
        try {
          const key = keyFromAudioData(audioData, audioData?.text);
          const now = Date.now();
          const last = prerecRecent.get(key) || 0;
          if (now - last < PREREC_TTL_MS) {
            console.log('[预录制音频] 🧊 节流：短时间内重复触发，同Key跳过 ->', key);
            return;
          }
          // 如果当前就正在播放同一段，直接忽略
          if (prerecPlayingKey === key && prerecAudioEl && !prerecAudioEl.ended) {
            console.log('[预录制音频] 🔁 正在播放同一段，同Key跳过 ->', key);
            return;
          }
          prerecRecent.set(key, now);
          
          console.log('[预录制音频] 开始播放:', audioFilePath, audioData);
          log('系统', `播放预录制音频: ${audioData.text || '未知文本'}`, 'success');
          
          // 🔍 详细调试信息
          console.log('[预录制音频] 🔍 详细调试信息:');
          console.log('  - API_BASE_URL:', API_BASE_URL);
          console.log('  - audioFilePath:', audioFilePath);
          console.log('  - audioFilePath 类型:', typeof audioFilePath);
          console.log('  - audioData:', JSON.stringify(audioData, null, 2));
          
          // 使用统一的URL构建函数，确保生成正确的绝对URL
          const audioUrl = buildAudioURL(audioFilePath);
          console.log('[预录制音频] 🎵 构建的完整URL:', audioUrl);
          console.log('[预录制音频] 🔍 原始路径:', audioFilePath);
          
          // 设置播放状态
          prerecPlayingKey = key;
          
          // 使用排队机制播放音频
          enqueueOrPlay(audioUrl, audioData);
          
        } catch (error) {
          console.error('[预录制音频] 播放函数执行失败:', error);
          log('系统', `预录制音频播放函数执行失败: ${error.message}`, 'error');
          // 异常时也释放锁
          prerecPlayingKey = null;
          prerecAudioEl = null;
        }
      }

      // 解析WebSocket调试消息
      function parseDebugMessage(message) {
        try {
          // 尝试解析JSON格式的消息
          const jsonMessage = JSON.parse(message);
          
          // 检查是否是预录制音频信号
          if (jsonMessage.type === 'prerecorded_audio' && jsonMessage.data) {
            const audioData = jsonMessage.data;
            console.log('[WebSocket] 收到预录制音频信号:', audioData);
            
            // 记录预录制音频播放时间
            lastPrerecordedAudioTime = Date.now();
            
            // 播放预录制音频文件
            if (audioData.audio_file_path) {
              playPrerecordedAudio(audioData.audio_file_path, audioData);
            }
            
            // 不返回消息对象，避免重复显示
            // 预录制音频的文本内容会通过 assistant_text 消息单独发送
            return null;
          }
          
          // 检查是否是新的assistant_text消息格式（优先处理）
          if (jsonMessage.type === 'assistant_text' && jsonMessage.data && jsonMessage.data.text) {
            const text = jsonMessage.data.text.trim();
            const kind = jsonMessage.data.kind || 'llm';
            const source = jsonMessage.data.source;
            
            // 仅标注为"触发预录制"，不设置音频时间戳
            if (source === 'prerecorded_cache') {
              return {
                type: (kind === 'stt') ? 'stt' : 'llm',
                content: `${text}（触发预录制）`
              };
            }
            
            // 检查是否是预录制音频相关的消息（在预录制音频播放后的短时间内）
            const now = Date.now();
            const isPrerecordedRelated = (now - lastPrerecordedAudioTime) < PRERECORDED_AUDIO_WINDOW;
            
            return {
              type: (kind === 'stt') ? 'stt' : 'llm',
              content: isPrerecordedRelated ? `${text}（触发预录制）` : text
            };
          }
          
          // 检查是否是旧的调试消息格式
          if (jsonMessage.type === 'debug' && jsonMessage.data && jsonMessage.data.message) {
            const debugText = jsonMessage.data.message.trim();
            console.log('[WebSocket] 解析JSON调试消息:', debugText);
            
            // 解析调试消息内容
            if (debugText.startsWith('[LLM_DEBUG]')) {
              return {
                type: 'llm',
                content: debugText.replace('[LLM_DEBUG]', '').trim()
              };
            } else if (debugText.startsWith('[STT_DEBUG]')) {
              return {
                type: 'stt',
                content: debugText.replace('[STT_DEBUG]', '').trim()
              };
            } else if (debugText.startsWith('[WELCOME]')) {
              return {
                type: 'llm',
                content: debugText.replace('[WELCOME]', '').trim()
              };
            } else if (debugText.includes('ERROR')) {
              // 匹配各种错误类型
              const errorTypes = ['VAD_ERROR', 'STT_ERROR', 'LLM_ERROR', 'TTS_ERROR'];
              for (const errorType of errorTypes) {
                if (debugText.includes(`[${errorType}]`)) {
                  return {
                    type: 'error',
                    source: errorType.replace('_ERROR', ''),
                    content: debugText.replace(`[${errorType}]`, '').trim()
                  };
                }
              }
              return {
                type: 'error',
                source: '系统',
                content: debugText
              };
            } else {
              return {
                type: 'info',
                content: debugText
              };
            }
          }
          
          // 检查是否是ping消息
          if (jsonMessage.type === 'ping') {
            return {
              type: 'ping',
              content: 'ping'
            };
          }
          
          // 处理其他类型的JSON消息
          return {
            type: 'info',
            content: `收到JSON消息: ${jsonMessage.type || '未知类型'}`
          };
          
        } catch (e) {
          // 如果不是JSON，按原来的文本格式处理
          const text = message.trim();
          console.log('[WebSocket] 解析文本调试消息:', text);
          
          // 匹配不同类型的调试消息
          if (text.startsWith('[LLM_DEBUG]')) {
            return {
              type: 'llm',
              content: text.replace('[LLM_DEBUG]', '').trim()
            };
          } else if (text.startsWith('[STT_DEBUG]')) {
            return {
              type: 'stt',
              content: text.replace('[STT_DEBUG]', '').trim()
            };
          } else if (text.startsWith('[WELCOME]')) {
            return {
              type: 'llm',
              content: text.replace('[WELCOME]', '').trim()
            };
          } else if (text.includes('ERROR')) {
            // 匹配各种错误类型
            const errorTypes = ['VAD_ERROR', 'STT_ERROR', 'LLM_ERROR', 'TTS_ERROR'];
            for (const errorType of errorTypes) {
              if (text.includes(`[${errorType}]`)) {
                return {
                  type: 'error',
                  source: errorType.replace('_ERROR', ''),
                  content: text.replace(`[${errorType}]`, '').trim()
                };
              }
            }
            return {
              type: 'error',
              source: '系统',
              content: text
            };
          } else {
            return {
              type: 'info',
              content: text
            };
          }
        }
      }

      // 连接WebSocket
      function connectWebSocket() {
        if (debugWebSocket && debugWebSocket.readyState === WebSocket.OPEN) {
          return; // 已经连接
        }

        updateWebSocketStatus('connecting', '连接中...');
        
        try {
          // 直接固定成域名 + /ws（由 Nginx 负责 TLS 和反代）
          const wsUrl = 'wss://cityuantifraud.cn/ws';
          
          console.log(`[WebSocket] 尝试连接: ${wsUrl}`);
          debugWebSocket = new WebSocket(wsUrl);
          
          debugWebSocket.onopen = function(event) {
            console.log('[WebSocket] 连接成功');
            updateWebSocketStatus('connected', '已连接');
            wsReconnectAttempts = 0;
            log('WebSocket', '调试连接已建立', 'success');
            
            // 发送bind消息以绑定客户端（扁平JSON格式）
            try {
              const bindMessage = JSON.stringify({
                type: 'bind',
                client_id: 'web_console',
                client_type: 'web_client'
              });
              debugWebSocket.send(bindMessage);
              console.log('[WebSocket] 已发送bind消息:', bindMessage);
            } catch (error) {
              console.error('[WebSocket] 发送bind消息失败:', error);
            }
          };
          
          debugWebSocket.onmessage = function(event) {
            wsMessageCount++;
            elements.wsMessageCount.textContent = wsMessageCount;
            
            // 添加详细的WebSocket消息接收日志
            console.log('[WebSocket] 收到消息:', event.data);
            console.log('[WebSocket] 消息计数:', wsMessageCount);
            
            try {
              const parsed = parseDebugMessage(event.data);
              console.log('[WebSocket] 解析后的消息:', parsed);
              
              // 检查parsed是否为null（预录制音频消息会返回null）
              if (parsed === null) {
                console.log('[WebSocket] 预录制音频消息已处理，跳过后续处理');
                return;
              }
              
              if (parsed.type === 'ping') {
                // 响应ping消息，发送pong
                try {
                  const pongMessage = JSON.stringify({
                    type: 'pong',
                    data: {}
                  });
                  debugWebSocket.send(pongMessage);
                  console.log('[WebSocket] 💓 收到ping，已发送pong响应');
                } catch (error) {
                  console.error('[WebSocket] 发送pong响应失败:', error);
                }
              } else if (parsed.type === 'stt') {
                log('STT', parsed.content, 'stt');
                console.log('[WebSocket] STT消息已处理:', parsed.content);
              } else if (parsed.type === 'llm') {
                log('LLM', parsed.content, 'llm');
                console.log('[WebSocket] LLM消息已处理:', parsed.content);
              } else if (parsed.type === 'error') {
                log(parsed.source, parsed.content, 'error');
                showErrorPopup(`${parsed.source}错误`, parsed.content);
                console.log('[WebSocket] 错误消息已处理:', parsed.source, parsed.content);
              } else {
                log('调试', parsed.content);
                console.log('[WebSocket] 调试消息已处理:', parsed.content);
              }
            } catch (error) {
              console.error('[WebSocket] 消息解析失败:', error, '原始消息:', event.data);
              log('WebSocket', `消息解析失败: ${error.message}`, 'error');
            }
          };
          
          debugWebSocket.onclose = function(event) {
            console.log('[WebSocket] 连接关闭:', event.code, event.reason);
            updateWebSocketStatus('disconnected', '已断开');
            
            // 自动重连逻辑
            if (wsReconnectAttempts < WS_MAX_RECONNECT_ATTEMPTS) {
              wsReconnectAttempts++;
              log('WebSocket', `连接断开，${WS_RECONNECT_DELAY/1000}秒后尝试重连 (${wsReconnectAttempts}/${WS_MAX_RECONNECT_ATTEMPTS})`);
              
              wsReconnectTimer = setTimeout(() => {
                connectWebSocket();
              }, WS_RECONNECT_DELAY);
            } else {
              log('WebSocket', '重连次数已达上限，请手动刷新页面', 'error');
            }
          };
          
          debugWebSocket.onerror = function(error) {
            console.error('[WebSocket] 连接错误:', error);
            updateWebSocketStatus('disconnected', '连接失败');
            log('WebSocket', '连接出现错误', 'error');
          };
          
        } catch (error) {
          console.error('[WebSocket] 创建连接失败:', error);
          updateWebSocketStatus('disconnected', '创建失败');
          log('WebSocket', `创建连接失败: ${error.message}`, 'error');
        }
      }

      // 断开WebSocket连接
      function disconnectWebSocket() {
        if (wsReconnectTimer) {
          clearTimeout(wsReconnectTimer);
          wsReconnectTimer = null;
        }
        
        if (debugWebSocket) {
          debugWebSocket.close();
          debugWebSocket = null;
        }
        
        updateWebSocketStatus('disconnected', '未连接');
        wsReconnectAttempts = 0;
      }

      async function fetchAgoraConfig(role = "publisher") {
        if (role === "publisher" && agoraConfigCache) {
          return agoraConfigCache;
        }
        const url = new URL("/api/agora/config", backendBaseUrl);
        url.searchParams.set("role", role);
        const response = await fetch(url.toString(), {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          throw new Error(`后端接口返回 ${response.status}`);
        }
        const config = await response.json();
        if (!config || !config.appId) {
          throw new Error("后端缺少声网 App ID");
        }

        // UID配置验证
        const validationResult = WebUIDValidator.validateConfiguration(config);
        if (!validationResult.isValid) {
          console.error("[CONFIG] UID配置验证失败:", validationResult.errors);
          throw new Error(`UID配置无效: ${validationResult.errors.join(", ")}`);
        }

        if (validationResult.warnings.length > 0) {
          console.warn("[CONFIG] UID配置警告:", validationResult.warnings);
        }

        // 记录UID信息
        WebUIDValidator.logUIDInfo("配置验证", config.botUid, {
          userUID: config.uid,
          channel: config.channel,
        });

        if (role === "publisher") {
          agoraConfigCache = config;
        }
        return config;
      }

      function startMicMeter(track) {
        try {
          const streamTrack = track.getMediaStreamTrack();
          if (!streamTrack) {
            return;
          }
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(
            new MediaStream([streamTrack])
          );
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          micDataArray = new Uint8Array(bufferLength);
          source.connect(analyser);

          const update = () => {
            analyser.getByteTimeDomainData(micDataArray);
            let sum = 0;
            for (let i = 0; i < micDataArray.length; i += 1) {
              const value = micDataArray[i] - 128;
              sum += value * value;
            }
            const rms = Math.sqrt(sum / micDataArray.length);
            const level = Math.min(
              100,
              Math.max(0, Math.round((rms / 128) * 100))
            );
            elements.micLevel.textContent = `${level}%`;
            if (elements.micBar) {
              elements.micBar.style.width = `${level}%`;
            }
            meterAnimation = requestAnimationFrame(update);
          };
          update();
        } catch (error) {
          log("系统", `麦克风电平监控异常: ${error.message}`);
        }
      }

      function stopMicMeter() {
        if (meterAnimation) {
          cancelAnimationFrame(meterAnimation);
          meterAnimation = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        analyser = null;
        micDataArray = null;
        elements.micLevel.textContent = "0%";
        if (elements.micBar) {
          elements.micBar.style.width = "0%";
        }
      }

      // 竞争性单通道相关变量
      const CHANNEL = "solidchannel";
      let sessionId, token, uid, appId;
      let beatTimer;
      let remoteCheckTimer = null; // ✅ 新增：远端用户定时检查计时器（全局）
      let clientHandlers = {
        userUnpublished: null,
        userLeft: null,
        connectionStateChange: null,
      };
      async function leaveAndCleanup() {
        try {
          if (client && client.connectionState !== "DISCONNECTED") {
            await client.leave();
            log("声网", "已离开频道");
          }
        } catch(e) {
          console.error("离开频道失败:", e);
        }
        
        try {
          if (sessionId) {
            // sendBeacon 确保页面关闭时也能发出
            const leaveUrl = `${API_BASE_URL}/rtc/leave`;
            navigator.sendBeacon(leaveUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
            log("系统", "已释放房间锁");
          }
          
          // 关闭RTC系统（释放Agora资源）
          const shutdownUrl = `${API_BASE_URL}/api/rtc/shutdown`;
          navigator.sendBeacon(shutdownUrl, new Blob([JSON.stringify({})], {type:"application/json"}));
          log("系统", "已请求关闭RTC系统");
          
        } catch(e) {
          console.error("释放资源失败:", e);
        }
        
        clearInterval(beatTimer); 
        beatTimer = null;
        sessionId = token = uid = appId = null;
        
        // 清理音频轨道
        if (microphoneAudioTrack) {
          microphoneAudioTrack.close();
          microphoneAudioTrack = null;
        }
        // ✅ 退出时复位全局回调，避免二次进入页面出现异常行为
        try {
          AgoraRTC.onAutoplayFailed = null;
        } catch (_) {}

        // ✅ 统一清理远端检查定时器
        if (remoteCheckTimer) {
          clearInterval(remoteCheckTimer);
          remoteCheckTimer = null;
        }

        setConnectionState("offline", "已断开连接");
        elements.connectButton.disabled = false;
        isConnecting = false;
      }

      async function enterAndJoin() {
        if (isConnecting) {
          return;
        }
        isConnecting = true;
        
        setConnectionState("idle", "正在初始化RTC系统...");
        elements.connectButton.disabled = true;
        log("系统", "开始初始化RTC系统...");

        try {
          // 0) 先初始化RTC系统（按需启动Agora连接）
          const initUrl = `${API_BASE_URL}/api/rtc/init`;
          console.log("初始化RTC系统URL:", initUrl);
          const initResponse = await fetch(initUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({})
          });
          
          if (!initResponse.ok) {
            throw new Error(`RTC初始化失败 HTTP ${initResponse.status}: ${initResponse.statusText}`);
          }
          
          const initResult = await initResponse.json();
          if (!initResult.ok) {
            throw new Error(`RTC初始化失败: ${initResult.error}`);
          }
          
          log("系统", "✅ RTC系统初始化成功，正在申请进入房间...");
          setConnectionState("idle", "正在申请进入房间...");

          // 启动WebSocket调试连接
          connectWebSocket();

          // 1) 申请进入（拿锁+拿token）
          const enterUrl = `${API_BASE_URL}/rtc/enter`;
          console.log("请求URL:", enterUrl);
          const response = await fetch(enterUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({ channel: CHANNEL })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const r = await response.json();

          if (!r.ok) {
            if (r.reason === "BUSY") {
              alert("当前线路正忙，请稍后再试。");
              log("系统", "房间被占用，无法进入", "error");
            } else {
              alert(`进入房间失败: ${r.reason}`);
              log("系统", `进入房间失败: ${r.reason}`, "error");
            }
            setConnectionState("offline", "进入房间失败");
            elements.connectButton.disabled = false;
            isConnecting = false;
            return;
          }

          sessionId = r.sessionId; 
          token = r.token; 
          uid = r.uid; 
          appId = r.appId;
          
          log("系统", `成功获取房间锁，会话ID: ${sessionId}`);
          elements.localUid.textContent = uid || "-";
          elements.channelName.textContent = CHANNEL;

          // 2) 心跳（10s一次）——断网/崩溃后 25s 自动释放
          beatTimer = setInterval(()=> {
            const beatUrl = `${API_BASE_URL}/rtc/beat`;
            navigator.sendBeacon(beatUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
          }, 10000);

          setConnectionState("idle", "正在加入声网频道...");
          
          if (client.connectionState !== "DISCONNECTED") {
            await client.leave().catch(() => {});
          }

          // 3) 加入频道
          await client.join(appId, CHANNEL, token, uid);
          log("声网", `已加入频道 ${CHANNEL}`);

          // 🚀 关键修复：立即绑定事件监听，避免错过 Bot 的 published 事件
          console.log("[FLOW] 🔧 立即绑定事件监听器...");
          bindClientEvents();

          // 4) 初始化订阅管理器（监听Bot用户）
          const config = await fetchAgoraConfig("publisher"); // 获取botUid
          subscriptionManager = new WebSubscriptionManager(client, {
            maxRetryAttempts: 3,
            retryDelay: 2000,
            enableAutoSubscribe: true,
            logLevel: "info",
          });
          // 注意：WebSubscriptionManager不需要initialize方法，构造函数已完成初始化
          // subscriptionManager.setSubscriptionCallback(handleSubscription); // 此方法也不存在，使用回调属性代替

          subscriptionManager.onSubscriptionSuccess = (uid, mediaType, result) => {
            console.log(`[SUBSCRIPTION] ✅ 订阅成功: ${uid} (${mediaType})`);
            log("订阅", `成功订阅用户 ${uid} 的${mediaType === "audio" ? "音频" : "视频"}流`);

            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              console.log(`[SUBSCRIPTION] 🤖 Bot用户音频订阅成功，开始播放`);

              // 保存全局变量，方便 autoplayFailed 或断开时清理
              remoteAudioTrack = result || client.remoteUsers.find(u => String(u.uid) === String(uid))?.audioTrack;

              if (remoteAudioTrack) {
                try {
                  remoteAudioTrack.play("remoteAudio");
                  console.log("[SUBSCRIPTION] Bot音频已播放");
                } catch (err) {
                  console.warn("[SUBSCRIPTION] 播放失败，可能是 autoplay 限制:", err);
                }
              } else {
                console.error("[SUBSCRIPTION] 订阅成功但未获取到 audioTrack 对象");
              }
            }
          };



          subscriptionManager.onSubscriptionFailed = (
            uid,
            mediaType,
            error
          ) => {
            console.error(
              `[SUBSCRIPTION] ❌ 订阅失败: ${uid} (${mediaType})`,
              error
            );
            log(
              "订阅",
              `订阅用户 ${uid} 的${
                mediaType === "audio" ? "音频" : "视频"
              }流失败: ${error.message}`,
              "error"
            );
          };

          subscriptionManager.onSubscriptionStateChanged = (
            uid,
            mediaType,
            state
          ) => {
            console.log(
              `[SUBSCRIPTION] 🔄 订阅状态变化: ${uid} (${mediaType}) -> ${state}`
            );

            // 更新UI显示
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              const stateText =
                {
                  not_subscribed: "未订阅",
                  subscribing: "订阅中",
                  subscribed: "已订阅",
                  subscription_failed: "订阅失败",
                  unsubscribing: "取消订阅中",
                }[state] || state;

              elements.remoteUid.textContent = `Bot(${uid}) - ${stateText}`;
            }
          };

          console.log("[SUBSCRIPTION] 订阅管理器初始化完成，已设置回调函数");

          // 🚀 关键修复：立即扫描并补订现有的 Bot 用户
          console.log("[FLOW] 🔍 扫描并补订现有 Bot 用户...");
          await scanAndSubscribeExistingBots();

          // [DEBUG] 检查当前远端用户
          console.log("[DEBUG] 当前远端用户:", client.remoteUsers);
          console.log("[DEBUG] 远端用户数量:", client.remoteUsers.length);
          client.remoteUsers.forEach((user) => {
            console.log("[DEBUG] 远端用户详情:", {
              uid: user.uid,
              hasAudio: user.hasAudio,
              hasVideo: user.hasVideo,
            });
          });

          // [AUDIO_FLOW] 检查麦克风权限和设备
          try {
            const devices = await AgoraRTC.getDevices();
            const audioInputs = devices.filter(
              (device) => device.kind === "audioinput"
            );
            console.log(
              "[AUDIO_FLOW] 可用音频输入设备:",
              audioInputs.map((d) => ({ id: d.deviceId, label: d.label }))
            );

            if (audioInputs.length === 0) {
              console.warn("[AUDIO_FLOW] 警告: 未检测到音频输入设备");
            }
          } catch (error) {
            console.error("[AUDIO_FLOW] 获取音频设备失败:", error);
          }

          // 创建和发布音频轨道
          console.log("[AUDIO_FLOW] 开始创建麦克风音频轨道...");
          microphoneAudioTrack = await AgoraRTC.createMicrophoneAudioTrack({
            encoderConfig: {
              sampleRate: 48000,
              stereo: false,
            },
          });
          localTrack = microphoneAudioTrack; // 保持兼容性

          // [AUDIO_FLOW] 音频轨道创建成功调试日志
          console.log("[AUDIO_FLOW] 麦克风音频轨道已创建:", {
            trackId: microphoneAudioTrack.getTrackId(),
            enabled: microphoneAudioTrack.enabled,
            muted: microphoneAudioTrack.muted,
            sampleRate: 48000,
          });

          await client.publish(microphoneAudioTrack);

          // [AUDIO_FLOW] 音频发布成功调试日志
          console.log("[AUDIO_FLOW] 本地音频已发布到声网:", {
            trackId: microphoneAudioTrack.getTrackId(),
            published: true,
            clientState: client.connectionState,
          });

          log("声网", "本地音频已发布");

          // [AUDIO_FLOW] 添加音频数据处理器监听音频流
          if (microphoneAudioTrack) {
            let audioFrameCounter = 0;
            try {
              const processor = {
                process: (audioBuffer) => {
                  audioFrameCounter++;
                  if (audioFrameCounter % 100 === 0) {
                    console.log(
                      "[AUDIO_FLOW] 音频数据流经声网SDK (第" +
                        audioFrameCounter +
                        "帧):",
                      {
                        sampleRate: audioBuffer.sampleRate,
                        numberOfChannels: audioBuffer.numberOfChannels,
                        length: audioBuffer.length,
                        timestamp: Date.now(),
                      }
                    );
                  }
                  return audioBuffer;
                },
              };

              if (localTrack.pipe && typeof localTrack.pipe === "function") {
                localTrack.pipe(processor);
                console.log("[AUDIO_FLOW] 音频处理器已添加到本地轨道");
              } else {
                console.log(
                  "[AUDIO_FLOW] 本地轨道不支持pipe方法，尝试其他监听方式"
                );
              }
            } catch (error) {
              console.log("[AUDIO_FLOW] 添加音频处理器失败:", error.message);
            }

            startMicMeter(microphoneAudioTrack);
          }

          // 处理 Autoplay 限制
          AgoraRTC.onAutoplayFailed = () => {
            console.warn("[WARN] Autoplay 被限制，创建恢复按钮");
            const btn = document.createElement("button");
            btn.innerText = "点击恢复 Bot 音频";
            btn.style.padding = "12px";
            btn.style.margin = "16px";
            btn.style.background = "#48bb78";
            btn.style.color = "#fff";
            btn.style.borderRadius = "8px";
            btn.onclick = () => {
              if (remoteAudioTrack) {
                remoteAudioTrack.play("remoteAudio");
                console.log("[DEBUG] 用户点击后恢复播放成功");
              }
              btn.remove();
            };
            document.body.appendChild(btn);
          };

          // 🚀 关键修复：在所有准备工作完成后再触发欢迎语
          console.log("[FLOW] 🎉 所有准备工作完成，现在触发欢迎语...");
          try {
            const resp = await fetch(`${API_BASE_URL}/api/rtc/welcome`, {
              method: "POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({})
            });
            const data = await resp.json();
            console.log("[WELCOME] 触发结果:", data);
            if (data.ok && data.welcome_sent) {
              log("系统", "✅ 欢迎语已触发（音频订阅已就绪）");
            } else {
              console.warn("[WELCOME] 触发失败或未发送:", data);
            }
          } catch (err) {
            console.error("[WELCOME] 请求出错:", err);
          }

          // --- 新增：加入后主动检查Bot用户并可能启动重试 ---
          if (subscriptionManager) {
            // 可以选择性地延迟一下，确保 SDK 状态更稳定，或者直接调用
            // setTimeout(() => {
              subscriptionManager.checkBotUsersForRetry();
            // }, 100); // 延迟 100ms，可选
          } else {
            console.warn("SubscriptionManager 未找到，无法检查Bot用户重试。");
          }
          // --- 新增结束 ---

          setConnectionState("online", "声网链路已建立，等待 Bot 音频...");
          elements.disconnectButton.disabled = false;
          log("系统", "连接完成，Bot 音频将自动播放");

          // ?? 添加：定时检查频道内的远端用户（增强版）
          if (remoteCheckTimer) { clearInterval(remoteCheckTimer); remoteCheckTimer = null; } // 避免重复
          remoteCheckTimer = setInterval(() => {
            const remoteUsers = client.remoteUsers;
            console.log("[CHECK] =========================");
            console.log("[CHECK] 频道内远端用户总数:", remoteUsers.length);

            if (remoteUsers.length === 0) {
              console.log("[CHECK] ?? 频道内无远端用户");
            } else {
              remoteUsers.forEach((user) => {
                console.log(`[CHECK] 用户 ${user.uid}:`, {
                  hasAudioTrack: !!user.audioTrack,
                  hasVideoTrack: !!user.videoTrack,
                  isPlaying: user.audioTrack?.isPlaying,
                  audioTrackType: typeof user.audioTrack,
                  audioTrackObject: user.audioTrack,
                });

                if (user.audioTrack) {
                  console.log(
                    `[CHECK] ? 用户 ${user.uid} 有音频轨道，播放状态: ${user.audioTrack.isPlaying}`
                  );
                } else {
                  console.log(`[CHECK] ? 用户 ${user.uid} 无音频轨道`);
                }

                // 特别检查Bot UID - 使用UID验证器
                if (WebUIDValidator.isBotUser(user.uid)) {
                  console.log(
                    `[CHECK] 🤖 检测到Bot用户 ${
                      user.uid
                    }! (类型: ${typeof user.uid})`
                  );
                  WebUIDValidator.logUIDInfo("Bot用户检测", user.uid, {
                    hasAudioTrack: !!user.audioTrack,
                    isPlaying: user.audioTrack?.isPlaying,
                  });
                  if (!user.audioTrack) {
                    console.log(
                      `[CHECK] ⚠️ Bot用户无音频轨道，可能需要手动订阅`
                    );
                  }
                }
              });
            }
            console.log("[CHECK] =========================");
          }, 5000); // 每5秒检查一次
        } catch (error) {
          log("错误", `连接失败: ${error.message}`, "error");
          await disconnect();
        } finally {
          isConnecting = false;
          if (!elements.disconnectButton.disabled) {
            elements.connectButton.disabled = true;
          } else {
            elements.connectButton.disabled = false;
          }
        }
      }
      function bindClientEvents() {
        // 先防御性解绑（避免极端情况下重复绑定）
        unbindClientEvents();

        // 🚀 关键修复：立即订阅 Bot 音频，避免延迟
        clientHandlers.userPublished = async (user, mediaType) => {
          console.log("[EVENT] user-published:", user.uid, mediaType);
          
          // 如果是 Bot 用户发布音频，立即订阅
          if (mediaType === "audio" && WebUIDValidator.isBotUser(user.uid)) {
            try {
              console.log(`[AUTO] 🤖 检测到 Bot ${user.uid} 发布音频，立即订阅...`);
              await client.subscribe(user, "audio");
              
              remoteAudioTrack = user.audioTrack;
              if (remoteAudioTrack) {
                // 设置音量
                const volume = parseInt(elements.volumeSlider.value) || 70;
                remoteAudioTrack.setVolume(volume);
                
                // 开始播放
                remoteAudioTrack.play("remoteAudio");
                console.log(`[AUTO] ✅ Bot ${user.uid} 音频已订阅并开始播放`);
                log("自动订阅", `Bot ${user.uid} 音频已连接并播放`);
                
                // 更新UI状态
                elements.remoteUid.textContent = `Bot(${user.uid}) - 已连接`;
              } else {
                console.error(`[AUTO] ❌ 订阅成功但未获取到 audioTrack`);
              }
            } catch (err) {
              console.error(`[AUTO] ❌ 立即订阅 Bot ${user.uid} 音频失败:`, err);
              log("订阅失败", `Bot ${user.uid} 音频订阅失败: ${err.message}`, "error");
            }
          }
        };

        clientHandlers.userUnpublished = (user, mediaType) => {
          console.log("[EVENT] user-unpublished:", user.uid, mediaType);
          if (WebUIDValidator.isBotUser(user.uid) && mediaType === "audio") {
            elements.remoteUid.textContent = "-";
            log("取消发布", `Bot ${user.uid} 取消发布音频`);
          }
        };

        clientHandlers.userLeft = (user) => {
          console.log("[EVENT] user-left:", user.uid);
          if (WebUIDValidator.isBotUser(user.uid)) {
            elements.remoteUid.textContent = "-";
            log("离开", `Bot ${user.uid} 已离开`);
          }
        };

        clientHandlers.connectionStateChange = (cur, prev, reason) => {
          log("声网", `连接状态: ${prev} -> ${cur} (${reason})`);
        };

        // 绑定所有事件
        client.on("user-published", clientHandlers.userPublished);
        client.on("user-unpublished", clientHandlers.userUnpublished);
        client.on("user-left", clientHandlers.userLeft);
        client.on("connection-state-change", clientHandlers.connectionStateChange);
      }

      // 🚀 关键修复：扫描并补订现有的 Bot 用户
      async function scanAndSubscribeExistingBots() {
        console.log("[SCAN] 开始扫描现有远端用户...");
        const remoteUsers = client.remoteUsers;
        console.log(`[SCAN] 发现 ${remoteUsers.length} 个远端用户`);
        
        for (const user of remoteUsers) {
          console.log(`[SCAN] 检查用户 ${user.uid}:`, {
            hasAudio: user.hasAudio,
            audioTrack: !!user.audioTrack,
            isBotUser: WebUIDValidator.isBotUser(user.uid)
          });
          
          if (WebUIDValidator.isBotUser(user.uid) && (user.hasAudio || user.audioTrack)) {
            try {
              console.log(`[SCAN] 🤖 发现现有 Bot ${user.uid}，立即补订音频...`);
              
              // 如果还没有订阅，则订阅
              if (!user.audioTrack) {
                await client.subscribe(user, "audio");
                console.log(`[SCAN] ✅ 补订 Bot ${user.uid} 音频成功`);
              }
              
              remoteAudioTrack = user.audioTrack;
              if (remoteAudioTrack) {
                // 设置音量
                const volume = parseInt(elements.volumeSlider.value) || 70;
                remoteAudioTrack.setVolume(volume);
                
                // 开始播放
                remoteAudioTrack.play("remoteAudio");
                console.log(`[SCAN] ✅ Bot ${user.uid} 音频已开始播放`);
                log("补订成功", `发现并连接了 Bot ${user.uid} 音频`);
                
                // 更新UI状态
                elements.remoteUid.textContent = `Bot(${user.uid}) - 已连接`;
                break; // 找到一个Bot就够了
              }
            } catch (err) {
              console.error(`[SCAN] ❌ 补订 Bot ${user.uid} 音频失败:`, err);
              log("补订失败", `Bot ${user.uid} 音频补订失败: ${err.message}`, "error");
            }
          }
        }
        
        if (remoteUsers.length === 0) {
          console.log("[SCAN] 当前频道内无远端用户，等待 Bot 加入...");
        }
      }

      function unbindClientEvents() {
        if (clientHandlers.userPublished) {
          client.off("user-published", clientHandlers.userPublished);
        }
        if (clientHandlers.userUnpublished) {
          client.off("user-unpublished", clientHandlers.userUnpublished);
        }
        if (clientHandlers.userLeft) {
          client.off("user-left", clientHandlers.userLeft);
        }
        if (clientHandlers.connectionStateChange) {
          client.off("connection-state-change", clientHandlers.connectionStateChange);
        }
        // 可选：重置为 null，避免误用旧指针
        clientHandlers = {
          userPublished: null,
          userUnpublished: null,
          userLeft: null,
          connectionStateChange: null,
        };
      }
      async function disconnect() {
        elements.disconnectButton.disabled = true;
        
        try {

          // ① 先解绑所有 client 事件（对称）
          unbindClientEvents();
             // （可留着你的这行，等价防御）
          // client.off("connection-state-change");
          
         // ② 关远端/本地轨道
          if (remoteAudioTrack) {
            remoteAudioTrack.stop();
            remoteAudioTrack.close();
            remoteAudioTrack = null;
          }

          if (localTrack) {
            localTrack.stop();
            localTrack.close();
            localTrack = null;
          }
          // ③ 停止电平动画
          stopMicMeter();

           // ✅ 统一清理远端检查定时器
          if (remoteCheckTimer) {
            clearInterval(remoteCheckTimer);
            remoteCheckTimer = null;
          }
          // ✅ 退出时复位全局回调，避免二次进入页面出现异常行为
          try {
            AgoraRTC.onAutoplayFailed = null;
          } catch (_) {}

          // 清理订阅管理器
          if (subscriptionManager) {
            subscriptionManager.destroy();
            subscriptionManager = null;
            console.log("[SUBSCRIPTION] 订阅管理器已清理");
          }

          // 断开WebSocket连接
          disconnectWebSocket();
         

          // 调用统一的清理函数（包含房间锁释放）
          await leaveAndCleanup();
        } catch (error) {
          log("错误", `断开连接出现问题: ${error.message}`);
          // 即使出错也要尝试清理
          await leaveAndCleanup();
        }
      }

      
    
      // 修改为先解锁音频再入会
      elements.connectButton.addEventListener("click", async () => {
        await AudioGate.unlock();   // ✅ 一次性解锁
        flushPendingAudio();         // ✅ 一次性处理未解锁期间积压的播放
        preloadAudioFiles();         // ✅ 解锁后预加载音频文件，避免移动端过早拉资源
        await enterAndJoin();       // 然后照常入会
      });
      elements.disconnectButton.addEventListener("click", disconnect);

      // 绑定导出日志按钮事件
      const exportLogsButton = document.getElementById("exportLogsButton");
      if (exportLogsButton) {
        exportLogsButton.addEventListener("click", () => {
          const fullText = collectAllLogsText();

          // 如果文本特别大，给个温柔提示（不截断）
          if (fullText.length > 2_000_000) {
            console.warn("[导出日志] 日志文本较大（>2MB），复制可能较慢。");
          }

          // 微信 / iPhone 友好：弹窗 + 全选/复制按钮
          showLogsInPopup(fullText);
        });
      }

      elements.volumeSlider.addEventListener("input", (event) => {
        const volume = Number(event.target.value || "70");
        elements.remoteVolume.textContent = `${volume}%`;
        if (remoteAudioTrack) {
          remoteAudioTrack.setVolume(volume);
        }
      });

      // Dify App Selection Logic
      const difyApp1Button = document.getElementById("difyApp1Button");
      const difyApp2Button = document.getElementById("difyApp2Button");

      async function setDifyApp(appName) {
        try {
          const response = await fetch('/api/set_dify_app', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ app_name: appName }),
          });
          const result = await response.json();
          if (result.ok) {
            log('系统', `Dify 应用已切换到: ${appName}`, 'success');
            // Update button styles
            if (appName === 'dify_app_1') {
              difyApp1Button.classList.add('active');
              difyApp2Button.classList.remove('active');
            } else {
              difyApp1Button.classList.remove('active');
              difyApp2Button.classList.add('active');
            }
          } else {
            log('系统', `Dify 应用切换失败: ${result.error}`, 'error');
          }
        } catch (error) {
          log('系统', `Dify 应用切换请求失败: ${error.message}`, 'error');
        }
      }

      difyApp1Button.addEventListener("click", () => setDifyApp('dify_app_1'));
      difyApp2Button.addEventListener("click", () => setDifyApp('dify_app_2'));





      // —— 挂到所有退出路径 ——
      // 1) 关闭/刷新
      window.addEventListener("beforeunload", leaveAndCleanup);
      window.addEventListener("pagehide", leaveAndCleanup);     // iOS Safari
      // 2) 页面可见性变化（可选：后台停播，前台再播）
      window.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          console.log("[DEBUG] 页面进入后台");
          // 可选：暂停某些操作
        } else {
          console.log("[DEBUG] 页面回到前台");
          // 可选：恢复某些操作
        }
      });

      log("系统", "页面加载完成，点击按钮即可体验声网 RTC 链路。");
      
      // 页面加载时尝试连接WebSocket调试服务
      log("系统", "正在连接WebSocket调试服务...");
      connectWebSocket();
    </script>
  </body>
</html>
