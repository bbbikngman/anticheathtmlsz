<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å£°ç½‘ RTC åŒå·¥å¯¹è¯å®¢æˆ·ç«¯</title>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.0.js"></script>
    <script src="web_uid_validator.js"></script>
    <script src="web_subscription_manager.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #5a67d8 0%, #805ad5 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #1a202c;
        padding: 24px;
      }

      .container {
        width: 100%;
        max-width: 900px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 20px;
        padding: 32px;
        box-shadow: 0 20px 60px rgba(67, 56, 202, 0.18);
      }

      header {
        text-align: center;
        margin-bottom: 24px;
      }

      header h1 {
        font-size: 2.2rem;
        color: #2d3748;
        margin-bottom: 8px;
      }

      header p {
        color: #4a5568;
      }

      .status-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }

      .status-card {
        background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        border-radius: 14px;
        padding: 18px;
        border: 1px solid #cbd5f5;
      }

      .status-card h2 {
        font-size: 1rem;
        color: #2b6cb0;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .status-value {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .status-value.online {
        color: #2f855a;
      }

      .status-value.offline {
        color: #c53030;
      }

      .status-value.idle {
        color: #b7791f;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-bottom: 24px;
        justify-content: center;
      }

      button {
        padding: 12px 28px;
        border: none;
        border-radius: 999px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: #fff;
      }

      button.primary {
        background: linear-gradient(135deg, #48bb78, #38a169);
      }

      button.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button.danger {
        background: linear-gradient(135deg, #f56565, #e53e3e);
      }

      button.danger:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      /* ä¸€ä¸ªæ²¡ç”¨çš„æ³¨é‡Šï¼Œè§¦å‘é‡å¯ */
      .meter {
        background: #edf2f7;
        border-radius: 14px;
        padding: 12px 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.95rem;
        color: #4a5568;
      }

      .meter span {
        font-weight: 600;
        color: #2d3748;
      }

      .meter-bar {
        margin-top: 8px;
        width: 180px;
        height: 10px;
        background: #e2e8f0;
        border-radius: 999px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #63b3ed, #3182ce);
        transition: width 0.1s ease;
      }

      .conversation-log {
        background: #f7fafc;
        border-radius: 14px;
        border: 1px solid #e2e8f0;
        padding: 18px;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-entry {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px dashed rgba(160, 174, 192, 0.5);
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry time {
        display: block;
        font-size: 0.8rem;
        color: #718096;
        margin-bottom: 4px;
      }

      .log-entry strong {
        display: inline-block;
        min-width: 70px;
        color: #2b6cb0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 12px;
        justify-content: center;
        margin-top: 8px;
      }

      .volume-control label {
        font-weight: 600;
        color: #2d3748;
      }

      .volume-control input {
        width: 220px;
      }

      .conversation-log {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        margin: 24px 0;
        max-height: 300px;
        overflow-y: auto;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 0.9rem;
      }

      .log-entry {
        margin-bottom: 8px;
        padding: 8px;
        border-radius: 6px;
        background: white;
        border-left: 4px solid #cbd5e0;
      }

      .log-entry.stt {
        border-left-color: #4299e1;
        background: #ebf8ff;
      }

      .log-entry.llm {
        border-left-color: #48bb78;
        background: #f0fff4;
      }

      .log-entry.error {
        border-left-color: #f56565;
        background: #fed7d7;
        color: #c53030;
      }

      .log-entry time {
        font-size: 0.8rem;
        color: #718096;
        margin-right: 8px;
      }

      .log-entry .source {
        font-weight: 600;
        margin-right: 8px;
      }

      .log-entry .source.stt {
        color: #2b6cb0;
      }

      .log-entry .source.llm {
        color: #2f855a;
      }

      .log-entry .source.error {
        color: #c53030;
      }

      .error-popup {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #fed7d7;
        border: 1px solid #feb2b2;
        border-radius: 8px;
        padding: 16px;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
      }

      .error-popup .error-title {
        font-weight: 600;
        color: #c53030;
        margin-bottom: 8px;
      }

      .error-popup .error-message {
        color: #742a2a;
        font-size: 0.9rem;
      }

      .error-popup .close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 1.2rem;
        color: #c53030;
        cursor: pointer;
        padding: 4px;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .websocket-status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .websocket-status.connected {
        background: #48bb78;
      }

      .websocket-status.disconnected {
        background: #f56565;
      }

      .websocket-status.connecting {
        background: #ed8936;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      footer {
        margin-top: 24px;
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
      }

      footer code {
        background: #edf2f7;
        padding: 2px 6px;
        border-radius: 6px;
      }

      .control-button.active {
        background-color: #48bb78;
        color: white;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>å£°ç½‘ RTC åŒå·¥å¯¹è¯å®¢æˆ·ç«¯</h1>
        <p>æµè§ˆå™¨ç›´æ¥åŠ å…¥å£°ç½‘é¢‘é“ï¼Œä¸Šè¡Œéº¦å…‹é£ã€ä¸‹è¡Œ Bot éŸ³é¢‘</p>
      </header>

      <section class="status-panel">
        <div class="status-card">
          <h2>è¿æ¥çŠ¶æ€</h2>
          <div id="connectionStatus" class="status-value offline">æœªè¿æ¥</div>
          <p id="statusHint">ç‚¹å‡»å¼€å§‹å¯¹è¯å³å¯è¿æ¥å£°ç½‘</p>
        </div>
        <div class="status-card">
          <h2>é¢‘é“ä¿¡æ¯</h2>
          <div class="status-value">
            <div>é¢‘é“ï¼š<span id="channelName">-</span></div>
            <div>æœ¬åœ° UIDï¼š<span id="localUid">-</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>Bot çŠ¶æ€</h2>
          <div class="status-value">
            <div>è¿œç«¯ UIDï¼š<span id="remoteUid">-</span></div>
            <div>éŸ³é‡ï¼š<span id="remoteVolume">70%</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>è°ƒè¯•è¿æ¥</h2>
          <div class="status-value">
            <div><span class="websocket-status disconnected" id="wsStatus"></span>WebSocketï¼š<span id="wsStatusText">æœªè¿æ¥</span></div>
            <div>æ¶ˆæ¯æ•°ï¼š<span id="wsMessageCount">0</span></div>
          </div>
        </div>
      </section>

      <section class="controls">
        <button id="connectButton" class="primary">å¼€å§‹å¯¹è¯</button>
        <button id="disconnectButton" class="danger" disabled>æ–­å¼€è¿æ¥</button>
        <button id="exportLogsButton" class="primary">å¯¼å‡ºæ—¥å¿—</button>
      </section>

      <!-- Dify App Selection -->
      <div class="controls-panel">
        <div class="control-group">
          <span class="control-label">é€‰æ‹©Difyåº”ç”¨:</span>
          <div class="buttons">
            <button id="difyApp1Button" class="control-button" data-app="dify_app_1" onclick="setDifyApp('dify_app_1')">é€šç”¨åº”ç”¨</button>
            <button id="difyApp2Button" class="control-button active" data-app="dify_app_2" onclick="setDifyApp('dify_app_2')">åè¯ˆåº”ç”¨</button>
          </div>
        </div>
      </div>

      <section class="meter">
        <div>
          <span>éº¦å…‹é£ç”µå¹³</span>
          <div class="meter-bar">
            <div id="micBar" class="meter-fill"></div>
          </div>
        </div>
        <div>
          <span id="micLevel">0%</span>
        </div>
      </section>

      <div class="volume-control">
        <label for="volumeSlider">Bot éŸ³é‡</label>
        <input id="volumeSlider" type="range" min="0" max="100" value="70" />
      </div>



      <section class="conversation-log" id="logContainer"></section>

      <div id="remoteAudio"></div>

      <footer>
        <div>
          è°ƒè¯•å‘½ä»¤ï¼š<code
            >curl https://cityuantifraud.cn/api/agora/config</code
          >
        </div>
      </footer>
    </div>

    <script>
      /**
       * è·¯ç”±åŸåˆ™ï¼š
       * 1) é¢„å½•éŸ³é¢‘ & cache_index.json ç»Ÿä¸€ä»åç«¯è¯»å–ï¼š
       *    `${API_BASE_URL}/prerecorded_audio/cache_index.json`
       *    `${API_BASE_URL}/prerecorded_audio/audio_files/<file>.mp3`
       * 2) RTC/ä¸šåŠ¡ç›¸å…³åªæ‰“åç«¯ï¼ˆcityuantifraud.cnï¼‰ã€‚
       * 3) Bot å®æ—¶éŸ³é¢‘æ¥è‡ª Agora è®¢é˜…çš„è¿œç«¯ trackï¼Œä¸ä¸Šè¿°é™æ€éŸ³é¢‘æ— å…³ã€‚
       */

      /************** â‘  æ•æ‰ F12 æ§åˆ¶å°æ—¥å¿—ï¼ˆlog/info/warn/error/debug + å…¨å±€é”™è¯¯ï¼‰ **************/
      (function setupConsoleCapture() {
        const levels = ["log", "info", "warn", "error", "debug"];
        const original = {};
        const MAX_LOGS = 20000; // ä¸ºäº†å®‰å…¨åšä¸ªä¸Šé™ï¼›éœ€è¦æ”¾å¼€å¯ä»¥æ”¹å¤§
        window.__consoleLogs = [];

        function argToString(a) {
          try {
            if (a instanceof Error) return a.stack || (a.name + ": " + a.message);
            if (typeof a === "object" && a !== null) {
              // å®‰å…¨ stringifyï¼ˆå¤„ç†å¾ªç¯å¼•ç”¨/DOMï¼‰
              const seen = new WeakSet();
              return JSON.stringify(
                a,
                (k, v) => {
                  if (typeof v === "object" && v !== null) {
                    if (seen.has(v)) return "[Circular]";
                    if (v instanceof Node) return `[DOM:${v.nodeName}]`;
                    seen.add(v);
                  }
                  return v;
                },
                2
              );
            }
            return String(a);
          } catch {
            try { return String(a); } catch { return "[Unserializable]"; }
          }
        }

        levels.forEach((level) => {
          original[level] = console[level].bind(console);
          console[level] = function (...args) {
            try {
              window.__consoleLogs.push({
                ts: Date.now(),
                level,
                args: args.map(argToString),
              });
              if (window.__consoleLogs.length > MAX_LOGS) {
                window.__consoleLogs.splice(0, window.__consoleLogs.length - MAX_LOGS);
              }
            } catch {}
            original[level](...args);
          };
        });

        window.addEventListener("error", (e) => {
          try {
            window.__consoleLogs.push({
              ts: Date.now(),
              level: "error",
              args: [
                `UncaughtError: ${e.message}`,
                `${e.filename}:${e.lineno}:${e.colno}`,
              ],
            });
          } catch {}
        });

        window.addEventListener("unhandledrejection", (e) => {
          try {
            const reason = e && e.reason !== undefined ? e.reason : "unknown";
            window.__consoleLogs.push({
              ts: Date.now(),
              level: "error",
              args: [`UnhandledRejection: ${argToString(reason)}`],
            });
          } catch {}
        });

        // å¯¼å‡ºä¸ºçº¯æ–‡æœ¬
        window.__getConsoleLogText = function () {
          return (window.__consoleLogs || [])
            .map(({ ts, level, args }) => {
              const t = new Date(ts).toLocaleString();
              return `[${t}] [${level.toUpperCase()}] ${args.join(" ")}`;
            })
            .join("\n");
        };
      })();

      /************** â‘¡ æŠŠ UI åŒºåŸŸæ—¥å¿— + é¡µé¢çŠ¶æ€ æ±‡æ€»æˆæ–‡æœ¬ **************/
      function getUiLogText() {
        const container = document.getElementById("logContainer");
        if (!container) return "";
        const items = container.querySelectorAll(".log-entry");
        const lines = [];
        items.forEach((n) => {
          const t = (n.querySelector("time")?.textContent || "").trim();
          const s = (n.querySelector(".source")?.textContent || "æ—¥å¿—").trim();
          // å–è¯¥æ¡é‡Œæ‰€æœ‰ <div> çš„æ–‡æœ¬ä½œä¸ºå†…å®¹
          const content = Array.from(n.querySelectorAll("div"))
            .map((d) => (d.textContent || "").trim())
            .filter(Boolean)
            .join(" ");
          lines.push(`${t}  ${s}  ${content}`);
        });
        return lines.join("\n");
      }

      function buildUserInfoText() {
        // ä½ çš„ä¿¡æ¯æ å…³é”®å­—æ®µ
        const get = (el) => (el ? el.textContent.trim() : "-");
        const info = [
          `æ—¶é—´: ${new Date().toLocaleString()}`,
          `URL: ${location.href}`,
          `UA: ${navigator.userAgent}`,
          `å¹³å°: ${navigator.platform || "n/a"}`,
          `è¯­è¨€: ${navigator.language || "n/a"}`,
          `çª—å£: ${window.innerWidth}x${window.innerHeight}`,
          `ç½‘ç»œ: ${
            navigator.connection
              ? `${navigator.connection.effectiveType || "n/a"}, ${navigator.connection.downlink || "?"}Mb/s`
              : "n/a"
          }`,
        ];

        const els = {
          connectionStatus: document.getElementById("connectionStatus"),
          channelName: document.getElementById("channelName"),
          localUid: document.getElementById("localUid"),
          remoteUid: document.getElementById("remoteUid"),
          remoteVolume: document.getElementById("remoteVolume"),
          wsStatusText: document.getElementById("wsStatusText"),
          wsMessageCount: document.getElementById("wsMessageCount"),
          micLevel: document.getElementById("micLevel"),
        };

        const state = [
          `è¿æ¥çŠ¶æ€: ${get(els.connectionStatus)}`,
          `é¢‘é“: ${get(els.channelName)}`,
          `æœ¬åœ°UID: ${get(els.localUid)}`,
          `è¿œç«¯UID: ${get(els.remoteUid)}`,
          `BotéŸ³é‡: ${get(els.remoteVolume)}`,
          `WebSocket: ${get(els.wsStatusText)}ï¼Œæ¶ˆæ¯æ•° ${get(els.wsMessageCount)}`,
          `éº¦å…‹é£ç”µå¹³: ${get(els.micLevel)}`,
        ];

        return `--- ç¯å¢ƒä¿¡æ¯ ---\n${info.join("\n")}\n\n--- é¡µé¢çŠ¶æ€ ---\n${state.join("\n")}`;
      }

      /************** â‘¢ å…¼å®¹æ€§æœ€å¼ºçš„å¼¹çª—ï¼ˆå«ï¼šå…¨é€‰ + å¤åˆ¶ æŒ‰é’®ï¼‰ **************/
      function showLogsInPopup(fullText) {
        // è’™å±‚
        const mask = document.createElement("div");
        Object.assign(mask.style, {
          position: "fixed",
          inset: 0,
          background: "rgba(0,0,0,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          zIndex: 9999,
          padding: "16px",
        });

        // é¢æ¿
        const panel = document.createElement("div");
        Object.assign(panel.style, {
          width: "min(920px, 96vw)",
          background: "#fff",
          borderRadius: "14px",
          boxShadow: "0 10px 30px rgba(0,0,0,0.2)",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
        });

        // å·¥å…·æ¡
        const toolbar = document.createElement("div");
        Object.assign(toolbar.style, {
          display: "flex",
          gap: "8px",
          padding: "12px",
          borderBottom: "1px solid #e2e8f0",
          background: "#f7fafc",
          alignItems: "center",
          justifyContent: "space-between",
        });
        const left = document.createElement("div");
        left.textContent = "å·²æ±‡æ€»ï¼šé¡µé¢ä¿¡æ¯ + UIæ—¥å¿— + æ§åˆ¶å°æ—¥å¿—";
        Object.assign(left.style, { color: "#2d3748", fontWeight: "600" });

        const btnWrap = document.createElement("div");
        Object.assign(btnWrap.style, { display: "flex", gap: "8px" });

        function mkBtn(text, color) {
          const b = document.createElement("button");
          b.textContent = text;
          Object.assign(b.style, {
            border: "none",
            borderRadius: "999px",
            padding: "8px 16px",
            fontWeight: "700",
            cursor: "pointer",
            color: "#fff",
            background: color,
          });
          return b;
        }
        const btnSelectAll = mkBtn("å…¨é€‰", "#3182ce");
        const btnCopy = mkBtn("å¤åˆ¶", "#38a169");
        const btnClose = mkBtn("å…³é—­", "#e53e3e");

        btnWrap.append(btnSelectAll, btnCopy, btnClose);
        toolbar.append(left, btnWrap);

        // æ–‡æœ¬åŒºåŸŸï¼ˆç”¨ textareaï¼Œç§»åŠ¨ç«¯/å¾®ä¿¡å¯é•¿æŒ‰ï¼‰
        const ta = document.createElement("textarea");
        ta.value = fullText;
        ta.readOnly = true;
        Object.assign(ta.style, {
          width: "100%",
          height: "70vh",
          border: "none",
          outline: "none",
          padding: "12px 16px",
          fontFamily: "Consolas, Monaco, monospace",
          fontSize: "13px",
          whiteSpace: "pre-wrap",
          boxSizing: "border-box",
        });

        panel.append(toolbar, ta);
        mask.append(panel);
        document.body.appendChild(mask);

        // äº‹ä»¶
        btnClose.onclick = () => mask.remove();

        btnSelectAll.onclick = () => {
          ta.focus();
          ta.select();
          // iOS å…¼å®¹ï¼šsetSelectionRange
          try { ta.setSelectionRange(0, ta.value.length); } catch {}
        };

        btnCopy.onclick = async () => {
          // å…ˆå°è¯• Clipboard APIï¼ˆå®‰å…¨ä¸Šä¸‹æ–‡ï¼‰
          let ok = false;
          try {
            if (navigator.clipboard && window.isSecureContext) {
              await navigator.clipboard.writeText(ta.value);
              ok = true;
            }
          } catch {}
          // å†é€€å› execCommand
          if (!ok) {
            try {
              ta.focus();
              ta.select();
              try { ta.setSelectionRange(0, ta.value.length); } catch {}
              ok = document.execCommand("copy");
            } catch { ok = false; }
          }
          // æç¤º
          const tip = document.createElement("div");
          tip.textContent = ok ? "âœ… å·²å¤åˆ¶åˆ°å‰ªè´´æ¿" : "âŒ å¤åˆ¶å¤±è´¥ï¼Œè¯·é•¿æŒ‰æ–‡æœ¬æ‰‹åŠ¨å¤åˆ¶";
          Object.assign(tip.style, {
            position: "absolute",
            bottom: "12px",
            left: "50%",
            transform: "translateX(-50%)",
            background: ok ? "#48bb78" : "#e53e3e",
            color: "#fff",
            padding: "6px 12px",
            borderRadius: "999px",
            fontWeight: "700",
            fontSize: "12px",
          });
          panel.appendChild(tip);
          setTimeout(() => tip.remove(), 1800);
        };

        // æ‰“å¼€æ—¶é»˜è®¤æŠŠå…‰æ ‡æ”¾è¿›å»ï¼Œä¾¿äºæ‰‹åŠ¨é•¿æŒ‰
        setTimeout(() => { ta.focus(); }, 50);
      }

      /************** â‘£ "å¯¼å‡ºæ—¥å¿—"æŒ‰é’®ç‚¹å‡»é€»è¾‘ï¼ˆè‡ªåŠ¨æ±‡æ€»ä¸‰ç±»å†…å®¹ï¼‰ **************/
      function collectAllLogsText() {
        const userInfo = buildUserInfoText();
        const uiLogs = getUiLogText();
        const consoleLogs =
          (window.__getConsoleLogText && window.__getConsoleLogText()) || "";

        const lines = [
          "===================== è°ƒè¯•æ—¥å¿—å¯¼å‡º =====================",
          new Date().toLocaleString(),
          "========================================================",
          "",
          userInfo,
          "",
          "--- UI æ—¥å¿—ï¼ˆé¡µé¢å¯è§åŒºåŸŸï¼‰ ---",
          uiLogs || "(æ— )",
          "",
          "--- Console æ—¥å¿—ï¼ˆF12 æ§åˆ¶å°ï¼‰ ---",
          consoleLogs || "(æ— )",
          "",
        ];
        return lines.join("\n");
      }

      // === AudioGateï¼šä¸€æ¬¡è§£é”ï¼Œåç»­ä»»æ„æ’­æ”¾ ===
      function createAudioGate({ poolSize = 4 } = {}) {
        let unlocked = false;
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const pool = [];

        // é¢„åˆ›å»ºä¸€ç»„ <audio>ï¼Œåç»­ç»Ÿä¸€å¤ç”¨
        for (let i = 0; i < poolSize; i++) {
          const a = document.createElement('audio');
          a.preload = 'auto';
          a.setAttribute('playsinline', '');
          a.playsInline = true;
          a.controls = false;
          a.style.display = 'none';
          a.crossOrigin = 'anonymous';
          document.body.appendChild(a);
          pool.push(a);
        }

        async function unlock() {
          if (unlocked) return;
          try {
            console.log('[AudioGate] å¼€å§‹è§£é”éŸ³é¢‘ç¯å¢ƒ...');
            
            // 1) å”¤é†’ WebAudio
            await ctx.resume();

            // 2) ç”¨ä¸€æ¬¡ç”¨æˆ·æ‰‹åŠ¿"ç¥ç¦"æ‰€æœ‰ <audio> å…ƒç´ 
            //    æ’­ä¸€æ®µæçŸ­é™éŸ³éŸ³é¢‘ -> ç«‹å³ pause -> å…ƒç´ è¿›å…¥å·²æˆæƒçŠ¶æ€
            const silent =
              'data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA';
            await Promise.all(
              pool.map(async (el) => {
                try {
                  el.src = silent;
                  el.volume = 0.001;
                  await el.play();
                  el.pause();
                  el.currentTime = 0;
                  el.removeAttribute('src');
                  el.load(); // æ¸…ç©ºï¼Œç­‰å¾…åç»­çœŸæ­£çš„ src
                } catch (e) {
                  // éƒ¨åˆ†æµè§ˆå™¨è¿™é‡Œå¯èƒ½æ‹’ç»ï¼Œä½†åªè¦æœ‰ä¸€æ¬¡æˆåŠŸå°±è¶³å¤Ÿ
                  console.warn('[AudioGate] bless one element failed:', e.message);
                }
              })
            );

            // 3) ä¿é™©ï¼šç”¨ä¸€ä¸ªéšè— iframe è‡ªåŠ¨æ’­ä¸€æ¬¡é™éŸ³ï¼Œè¦†ç›–éƒ¨åˆ†å†…æ ¸è¾¹è§’
            try {
              const iframe = document.createElement('iframe');
              iframe.allow = 'autoplay';
              iframe.style.display = 'none';
              iframe.srcdoc =
                '<audio autoplay ' +
                'src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA"></audio>';
              document.body.appendChild(iframe);
              setTimeout(() => iframe.remove(), 2000);
            } catch {}

            unlocked = true;
            window.__audioGate__ = { ctx, pool, unlocked: true };
            console.log('[AudioGate] âœ… éŸ³é¢‘ç¯å¢ƒå·²æˆåŠŸè§£é”');
          } catch (err) {
            console.warn('[AudioGate] unlock failed:', err);
          }
        }

        function getFreeElement() {
          // æ‰¾ä¸€ä¸ªç©ºé—² <audio>ï¼ˆæš‚åœæˆ–å·²ç»“æŸï¼‰ï¼Œæ²¡æœ‰å°±ç”¨ç¬¬ä¸€ä¸ªï¼ˆä¼šæ‰“æ–­å®ƒï¼‰
          return pool.find((el) => el.paused || el.ended) || pool[0];
        }

        async function play(url, { volume = 1.0, loop = false } = {}) {
          if (!unlocked) throw new Error('Audio not unlocked yet');
          const el = getFreeElement();
          el.volume = volume;
          el.loop = loop;
          el.setAttribute('playsinline', '');
          el.playsInline = true;
          el.src = url;
          try {
            await el.play();
            return el; // è¿”å›æ­£åœ¨æ’­æ”¾çš„ <audio>
          } catch (err) {
            // HTMLMediaElement æ’­æ”¾å¤±è´¥æ—¶ï¼Œé™çº§èµ° WebAudio è§£ç æ’­æ”¾ï¼ˆå‡ ä¹æ€»èƒ½æ’­ï¼‰
            console.warn('[AudioGate] media play() failed, fallback to WebAudio:', err);
            try {
              const resp = await fetch(url);
              const buf = await resp.arrayBuffer();
              const audioBuf = await ctx.decodeAudioData(buf);
              const node = ctx.createBufferSource();
              node.buffer = audioBuf;
              node.connect(ctx.destination);
              node.start(0);
              return node; // è¿”å› WebAudio çš„èŠ‚ç‚¹
            } catch (e) {
              console.error('[AudioGate] fallback failed:', e);
              throw err;
            }
          }
        }

        // é¡µé¢å›å‰å°è‡ªåŠ¨ resumeï¼ˆå¾ˆå¤šæ—¶å€™ä¸éœ€è¦ç”¨æˆ·æ‰‹åŠ¿ï¼‰
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible' && ctx.state === 'suspended') {
            ctx.resume().catch(() => {});
          }
        });
        // ä»»æ„äº¤äº’æ—¶ä¹Ÿå°è¯• resumeï¼ˆå¦‚æœè¢«ç³»ç»ŸæŒ‚èµ·ï¼Œç”¨æˆ·éšæ‰‹ç‚¹ä¸€ä¸‹ä»»ä½•ä½ç½®å³å¯æ¢å¤ï¼‰
        ['pointerdown', 'touchstart', 'keydown'].forEach((evt) => {
          window.addEventListener(
            evt,
            () => {
              if (ctx.state === 'suspended') ctx.resume().catch(() => {});
            },
            { passive: true }
          );
        });

        return { unlock, play, get unlocked() { return unlocked; }, ctx, pool };
      }
      
      const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
      
      // å…¨å±€åªå»ºä¸€æ¬¡ AudioGate å®ä¾‹
      const AudioGate = createAudioGate({ poolSize: 4 });
      
      let localTrack = null;
      let microphoneAudioTrack = null; // æ·»åŠ ç¼ºå¤±çš„å˜é‡å®šä¹‰
      let remoteAudioTrack = null;
      let agoraConfigCache = null;
      const backendBaseUrl = "https://cityuantifraud.cn";
      // ç”Ÿäº§ç¯å¢ƒé…ç½®ï¼šAPIè°ƒç”¨ä½¿ç”¨åç«¯æœåŠ¡å™¨ï¼Œé™æ€èµ„æºä½¿ç”¨ç›¸å¯¹è·¯å¾„
      const API_BASE_URL = backendBaseUrl;
      
      // æ–°å¢ä¸€è¡Œï¼ˆæ”¾åœ¨ä¸Šé¢é™„è¿‘å³å¯ï¼‰
      const PREREC_BASE = `${backendBaseUrl}/prerecorded_audio`;

      // é™æ€èµ„æºä¸€å¾‹ç›¸å¯¹è·¯å¾„ï¼›è¯¥å‡½æ•°åªæ˜¯ç¡®ä¿ä¸ä¼šå‡ºç°ä»¥ / å¼€å¤´çš„æ ¹è·¯å¾„å¯¼è‡´è·³åˆ°ç«™ç‚¹æ ¹
      const staticPath = (p) => (p || "").replace(/^\/+/, "");
      // éŸ³é¢‘è·¯å¾„å½’ä¸€åŒ–ï¼šå¤„ç†Windowsåæ–œæ å¹¶ç¡®ä¿ç›¸å¯¹è·¯å¾„
      const normalizeAudioPath = (p) => staticPath(String(p || '').replace(/\\/g, '/'));
      let isConnecting = false;
      let subscriptionManager = null;
      let audioContext = null;
      let analyser = null;
      let micDataArray = null;
      let meterAnimation = null;
      


      // WebSocketç›¸å…³å˜é‡
      let debugWebSocket = null;
      let wsReconnectTimer = null;
      let wsMessageCount = 0;
      let wsReconnectAttempts = 0;
      const WS_MAX_RECONNECT_ATTEMPTS = 5;
      const WS_RECONNECT_DELAY = 3000;
      
      // === ç»Ÿä¸€å»é‡ï¼š2s TTL ===
      const DEDUP_TTL_MS = 2000;           // â˜… 2 ç§’ TTL
      const lastSeenMap = new Map();       // hash -> ts
      
      // é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾çŠ¶æ€è·Ÿè¸ª
      let lastPrerecordedAudioTime = 0;
      const PRERECORDED_AUDIO_WINDOW = 1000; // 1ç§’å†…çš„assistant_textæ¶ˆæ¯è¢«è®¤ä¸ºæ˜¯é¢„å½•åˆ¶éŸ³é¢‘ç›¸å…³
      
      // ===== é¢„å½•éŸ³é¢‘"æ’­æ”¾é”"/èŠ‚æµ =====
      let prerecPlayingKey = null;
      let prerecAudioEl = null;
      const prerecRecent = new Map(); // key -> ts
      const PREREC_TTL_MS = 4000;     // 4s å†…ç›¸åŒKeyä¸é‡å¤æ’­
      
      // ===== æ’­æ”¾æ’é˜Ÿæœºåˆ¶ï¼šæœªè§£é”æ—¶å…ˆæ’é˜Ÿï¼Œè§£é”åä¸€æ¬¡æ€§å†²åˆ· =====
      const pendingAudioQueue = []; // {url, audioData}[]
      
      function normalizeTextKey(t) {
        return (t || "")
          .replace(/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šã€"'""''ï¼ˆï¼‰ã€ã€‘[\]\s]/g, "")
          .toLowerCase();
      }
      
      function keyFromAudioData(audioData, fallbackText) {
        if (audioData?.audio_file) return `file:${audioData.audio_file}`;
        if (audioData?.hash)       return `hash:${audioData.hash}`;
        const txt = audioData?.text || fallbackText || "";
        return `text:${normalizeTextKey(txt)}`;
      }
      
      // æ’­æ”¾æ’é˜Ÿç›¸å…³å‡½æ•°
      function doPlay(audioUrl, audioData) {
        AudioGate.play(audioUrl, { volume: 1.0 }).then(player => {
          prerecAudioEl = player;

          // ç»“æŸæ¸…ç†ï¼ˆåŒæ—¶å…¼å®¹ <audio> ä¸ WebAudioï¼‰
          if (player && typeof player.addEventListener === 'function') {
            player.addEventListener('ended', () => {
              prerecPlayingKey = null; 
              prerecAudioEl = null;
            });
          } else if (player && 'onended' in player) {
            player.onended = () => { 
              prerecPlayingKey = null; 
              prerecAudioEl = null; 
            };
          }
        }).catch(err => {
          console.error('[é¢„å½•åˆ¶éŸ³é¢‘] âŒ æ’­æ”¾å¤±è´¥:', err);
          log('ç³»ç»Ÿ', `é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾å¤±è´¥: ${err.message}`, 'error');
          prerecPlayingKey = null; 
          prerecAudioEl = null;
          // å¦‚éœ€ï¼šè¿™é‡Œå¯ç»§ç»­è°ƒç”¨ tryAlternativeUrls(audioUrl, audioData, 0)
        });
      }

      function enqueueOrPlay(audioUrl, audioData) {
        if (!AudioGate.unlocked) {
          pendingAudioQueue.push({ url: audioUrl, audioData });
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] â¸ AudioGate æœªè§£é”ï¼Œæ’é˜Ÿï¼š', audioUrl);
          return;
        }
        doPlay(audioUrl, audioData);
      }

      function flushPendingAudio() {
        if (!AudioGate.unlocked) return;
        while (pendingAudioQueue.length) {
          const { url, audioData } = pendingAudioQueue.shift();
          doPlay(url, audioData);
        }
      }
      
      const elements = {
        connectionStatus: document.getElementById("connectionStatus"),
        statusHint: document.getElementById("statusHint"),
        channelName: document.getElementById("channelName"),
        localUid: document.getElementById("localUid"),
        remoteUid: document.getElementById("remoteUid"),
        remoteVolume: document.getElementById("remoteVolume"),
        connectButton: document.getElementById("connectButton"),
        disconnectButton: document.getElementById("disconnectButton"),
        volumeSlider: document.getElementById("volumeSlider"),
        micLevel: document.getElementById("micLevel"),
        micBar: document.getElementById("micBar"),
        logContainer: document.getElementById("logContainer"),
        wsStatus: document.getElementById("wsStatus"),
        wsStatusText: document.getElementById("wsStatusText"),
        wsMessageCount: document.getElementById("wsMessageCount"),
      };

      // ç®€å•çš„å­—ç¬¦ä¸²hashå‡½æ•°
      function simpleHash(str) {
        let hash = 0;
        if (str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
        }
        return hash.toString();
      }

      function normalizeForHash(s) {
        // ç§»é™¤"ï¼ˆè§¦å‘é¢„å½•åˆ¶ï¼‰"åç¼€ï¼Œç¡®ä¿å»é‡æ­£ç¡®è¯†åˆ«ç›¸åŒå†…å®¹
        return (s || '')
          .replace(/ï¼ˆè§¦å‘é¢„å½•åˆ¶ï¼‰$/, '')  // ç§»é™¤ç»“å°¾çš„"ï¼ˆè§¦å‘é¢„å½•åˆ¶ï¼‰"
          .replace(/\s+/g, ' ')           // åˆå¹¶ç©ºç™½ï¼Œé¿å…æ— æ„ä¹‰å·®å¼‚
          .trim();
      }

      // ğŸ”§ ç»Ÿä¸€çš„éŸ³é¢‘URLæ„å»ºå‡½æ•°
      function buildAudioURL(audioFilePath) {
        if (!audioFilePath) return null;
        
        // å¦‚æœå·²ç»æ˜¯å®Œæ•´çš„HTTP(S) URLï¼Œç›´æ¥è¿”å›
        if (/^https?:\/\//i.test(audioFilePath)) {
          return audioFilePath;
        }
        
        // è·å–åŸºç¡€URLï¼Œä¼˜å…ˆä½¿ç”¨API_BASE_URLï¼Œå¦åˆ™ä½¿ç”¨å½“å‰åŸŸå
        const base = (typeof API_BASE_URL === 'string' ? API_BASE_URL : window.location.origin).replace(/\/+$/, '');
        
        // ç¡®ä¿è·¯å¾„ä»¥ / å¼€å¤´
        let path = audioFilePath;
        if (!path.startsWith('/')) {
          path = '/' + path;
        }
        
        return base + path;
      }

      function shouldDedup(source, message, type) {
        const keyType = (type || source || 'info').toString().toLowerCase();
        const hash = simpleHash(`${keyType}|${normalizeForHash(message)}`);
        const now = Date.now();
        const prev = lastSeenMap.get(hash) || 0;

        if (now - prev < DEDUP_TTL_MS) {
          console.log(`[å»é‡] ${keyType} åœ¨ ${now - prev}ms å†…é‡å¤ï¼Œè·³è¿‡: "${(message || '').slice(0,50)}..."`);
          return true;
        }
        lastSeenMap.set(hash, now);
        return false;
      }

      // å®šæœŸæ¸…ç†è¿‡æœŸçš„hashè®°å½•ï¼Œé˜²æ­¢Mapè†¨èƒ€
      setInterval(() => {
        const now = Date.now();
        for (const [k, ts] of lastSeenMap.entries()) {
          if (now - ts > 60000) lastSeenMap.delete(k);
        }
      }, 30000);



      function log(source, message, type = "info") {
        // ç»Ÿä¸€ 2 ç§’ TTL å»é‡
        if (shouldDedup(source, message, type)) return;
        
        const entry = document.createElement("div");
        entry.className = "log-entry";
        const timestamp = new Date().toLocaleTimeString();
        
        // æ ¹æ®æ¶ˆæ¯ç±»å‹è®¾ç½®æ ·å¼
        if (type === "stt" || source === "STT") {
          entry.classList.add("stt");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source stt">è¯­éŸ³è¯†åˆ«</span>
            <div>${message}</div>
          `;
        } else if (type === "llm" || source === "LLM") {
          entry.classList.add("llm");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source llm">AIå›å¤</span>
            <div>${message}</div>
          `;
        } else if (type === "error") {
          entry.classList.add("error");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source error">${source}</span>
            <div>${message}</div>
          `;
        } else {
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source">${source}</span>
            <div>${message}</div>
          `;
          if (type === "success") {
            entry.style.color = "#2f855a";
          }
        }
        
        elements.logContainer.appendChild(entry);
        elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
      }

      function setConnectionState(state, hint) {
        elements.connectionStatus.classList.remove("online", "offline", "idle");
        elements.connectionStatus.classList.add(state);
        elements.connectionStatus.textContent =
          state === "online"
            ? "å·²è¿æ¥"
            : state === "offline"
            ? "æœªè¿æ¥"
            : "å‡†å¤‡ä¸­";
        if (hint) {
          elements.statusHint.textContent = hint;
        }
      }

      // WebSocketçŠ¶æ€æ›´æ–°å‡½æ•°
      function updateWebSocketStatus(status, text) {
        elements.wsStatus.className = `websocket-status ${status}`;
        elements.wsStatusText.textContent = text;
      }

      // æ˜¾ç¤ºé”™è¯¯å¼¹çª—
      function showErrorPopup(title, message) {
        // ç§»é™¤å·²å­˜åœ¨çš„é”™è¯¯å¼¹çª—
        const existingPopup = document.querySelector('.error-popup');
        if (existingPopup) {
          existingPopup.remove();
        }

        const popup = document.createElement('div');
        popup.className = 'error-popup';
        popup.innerHTML = `
          <button class="close-btn" onclick="this.parentElement.remove()">Ã—</button>
          <div class="error-title">${title}</div>
          <div class="error-message">${message}</div>
        `;
        
        document.body.appendChild(popup);
        
        // 5ç§’åè‡ªåŠ¨å…³é—­
        setTimeout(() => {
          if (popup.parentElement) {
            popup.remove();
          }
        }, 5000);
      }

      // ğŸµ é¢„åŠ è½½éŸ³é¢‘æ–‡ä»¶å‡½æ•°
      async function preloadAudioFiles() {
        try {
          console.log('[é¢„åŠ è½½] ğŸµ å¼€å§‹é¢„åŠ è½½éŸ³é¢‘æ–‡ä»¶...');
          log('ç³»ç»Ÿ', 'æ­£åœ¨é¢„åŠ è½½éŸ³é¢‘æ–‡ä»¶...', 'info');
          
          // åŠ è½½ç¼“å­˜ç´¢å¼•
          const cacheIndexUrl = `${PREREC_BASE}/cache_index.json`;
          const response = await fetch(cacheIndexUrl);
          if (!response.ok) {
            console.warn('[é¢„åŠ è½½] âš ï¸ æ— æ³•åŠ è½½ç¼“å­˜ç´¢å¼•ï¼Œè·³è¿‡é¢„åŠ è½½');
            return;
          }
          
          const cacheIndex = await response.json();
          const audioFiles = Object.values(cacheIndex).map(entry => entry.audio_file).filter(Boolean);
          console.log(`[é¢„åŠ è½½] ğŸ“‹ å‘ç° ${audioFiles.length} ä¸ªéŸ³é¢‘æ–‡ä»¶éœ€è¦é¢„åŠ è½½`);
          
          // é™åˆ¶å¹¶å‘é¢„åŠ è½½æ•°é‡ï¼Œé¿å…è¿‡å¤šè¯·æ±‚
          const maxConcurrent = 3;
          let loadedCount = 0;
          let failedCount = 0;
          
          for (let i = 0; i < audioFiles.length; i += maxConcurrent) {
            const batch = audioFiles.slice(i, i + maxConcurrent);
            const promises = batch.map(async (audioFile) => {
              try {
                // 1) ä½¿ç”¨ç»Ÿä¸€çš„URLæ„å»ºå‡½æ•°ï¼Œç¡®ä¿ç”Ÿæˆæ­£ç¡®çš„ç»å¯¹URL
                const audioPath = `prerecorded_audio/audio_files/${audioFile}`;
                const audioUrl = encodeURI(buildAudioURL(audioPath));
                
                // ä½¿ç”¨ AudioGate çš„éŸ³é¢‘æ± é¢„åŠ è½½
                // è¿™é‡Œæˆ‘ä»¬ä¸å®é™…æ’­æ”¾ï¼Œåªæ˜¯è®©æµè§ˆå™¨ç¼“å­˜è¿™äº›æ–‡ä»¶
                const tempAudio = new Audio(audioUrl);
                tempAudio.crossOrigin = 'anonymous';
                tempAudio.preload = 'auto';
                tempAudio.volume = 0;
                
                return new Promise((resolve) => {
                  // 2) æˆåŠŸæ ‡å‡†æ”¾å®½ï¼šloadedmetadata / canplay / canplaythrough ä»»ä¸€è§¦å‘å³ç®—æˆåŠŸ
                  const onSuccess = (evt) => {
                    clearTimeout(t);
                    tempAudio.onloadedmetadata = null;
                    tempAudio.oncanplay = null;
                    tempAudio.oncanplaythrough = null;
                    tempAudio.onerror = null;
                    console.log(`[é¢„åŠ è½½] âœ… ${audioFile} é¢„åŠ è½½æˆåŠŸï¼ˆ${evt?.type}ï¼‰`);
                    loadedCount++;
                    resolve();
                  };
                  const onError = (e) => {
                    clearTimeout(t);
                    tempAudio.onloadedmetadata = null;
                    tempAudio.oncanplay = null;
                    tempAudio.oncanplaythrough = null;
                    tempAudio.onerror = null;
                    console.warn(`[é¢„åŠ è½½] âš ï¸ ${audioFile} é¢„åŠ è½½å¤±è´¥`);
                    failedCount++;
                    resolve();
                  };
                  tempAudio.onloadedmetadata = onSuccess;
                  tempAudio.oncanplay = onSuccess;
                  tempAudio.oncanplaythrough = onSuccess;
                  tempAudio.onerror = onError;

                  // 3) ä¸€å®šè¦ä¿å­˜å¹¶åœ¨æˆåŠŸ/å¤±è´¥æ—¶ clearTimeout
                  const t = setTimeout(() => {
                    onError(new Error('timeout'));
                  }, 12000); // é€‚å½“æ”¾å®½åˆ° 12sï¼Œé¿å…æ…¢ç½‘/å†·ç¼“å­˜è¯¯åˆ¤
                });
              } catch (error) {
                console.warn(`[é¢„åŠ è½½] âŒ ${audioFile} é¢„åŠ è½½å¼‚å¸¸:`, error);
                failedCount++;
              }
            });
            
            await Promise.all(promises);
            
            // æ˜¾ç¤ºè¿›åº¦
            const progress = Math.round(((i + batch.length) / audioFiles.length) * 100);
            console.log(`[é¢„åŠ è½½] ğŸ“Š è¿›åº¦: ${progress}% (${loadedCount}/${audioFiles.length} æˆåŠŸ, ${failedCount} å¤±è´¥)`);
          }
          
          console.log(`[é¢„åŠ è½½] ğŸ‰ é¢„åŠ è½½å®Œæˆ: ${loadedCount}/${audioFiles.length} æˆåŠŸ, ${failedCount} å¤±è´¥`);
          log('ç³»ç»Ÿ', `éŸ³é¢‘é¢„åŠ è½½å®Œæˆ: ${loadedCount}/${audioFiles.length} æˆåŠŸ`, loadedCount > 0 ? 'success' : 'warning');
          
        } catch (error) {
          console.error('[é¢„åŠ è½½] âŒ é¢„åŠ è½½è¿‡ç¨‹å‡ºé”™:', error);
          log('ç³»ç»Ÿ', 'éŸ³é¢‘é¢„åŠ è½½å¤±è´¥', 'error');
        }
      }

      // ğŸ”§ å°è¯•å¤‡ç”¨URLçš„å‡½æ•°
      function tryAlternativeUrls(originalPath, audioData, urlIndex) {
        const base = normalizeAudioPath(originalPath);
        const basename = base.split(/[\/\\]/).pop();
        const alternativeUrls = [
          buildAudioURL(`prerecorded_audio/audio_files/${basename}`),
          buildAudioURL(`prerecorded_audio/audio_files/${base}`)
        ];
        
        if (!AudioGate.unlocked) {
          // ç­‰è§£é”åå†é‡è¯•ï¼Œé¿å…"æœªè§£é”â†’å¤šæ¬¡å¤±è´¥"åˆ·å±
          pendingAudioQueue.push({ url: alternativeUrls[0], audioData });
          return;
        }
        
        if (urlIndex >= alternativeUrls.length) {
          console.error('[é¢„å½•åˆ¶éŸ³é¢‘] âŒ æ‰€æœ‰å¤‡ç”¨URLéƒ½å¤±è´¥äº†');
          log('ç³»ç»Ÿ', 'é¢„å½•åˆ¶éŸ³é¢‘: æ‰€æœ‰URLéƒ½æ— æ³•è®¿é—®', 'error');
          return;
        }
        
        const testUrl = alternativeUrls[urlIndex];
        console.log(`[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ”§ æµ‹è¯•å¤‡ç”¨URL ${urlIndex + 1}/${alternativeUrls.length}:`, testUrl);
        
        // ä½¿ç”¨ AudioGate å°è¯•æ’­æ”¾å¤‡ç”¨URL
        AudioGate.play(testUrl, { volume: 1.0 }).then(audioElement => {
          console.log(`[é¢„å½•åˆ¶éŸ³é¢‘] âœ… å¤‡ç”¨URL ${urlIndex + 1} æˆåŠŸ:`, testUrl);
          log('ç³»ç»Ÿ', `é¢„å½•åˆ¶éŸ³é¢‘: ä½¿ç”¨å¤‡ç”¨URLæ’­æ”¾`, 'success');
          
          // æ›´æ–°å…¨å±€æ’­æ”¾çŠ¶æ€
          prerecAudioEl = audioElement;
          
          // ç»“æŸæ¸…ç†ï¼ˆåŒæ—¶å…¼å®¹ <audio> ä¸ WebAudioï¼‰
          if (audioElement && typeof audioElement.addEventListener === 'function') {
            audioElement.addEventListener('ended', () => {
              console.log('[é¢„å½•åˆ¶éŸ³é¢‘] å¤‡ç”¨URLéŸ³é¢‘æ’­æ”¾å®Œæˆ');
              prerecPlayingKey = null;
              prerecAudioEl = null;
            });
          } else if (audioElement && 'onended' in audioElement) {
            audioElement.onended = () => {
              console.log('[é¢„å½•åˆ¶éŸ³é¢‘] å¤‡ç”¨URLéŸ³é¢‘æ’­æ”¾å®Œæˆ');
              prerecPlayingKey = null;
              prerecAudioEl = null;
            };
          }
        }).catch(error => {
          console.error(`[é¢„å½•åˆ¶éŸ³é¢‘] âŒ å¤‡ç”¨URL ${urlIndex + 1} å¤±è´¥:`, testUrl, error);
          tryAlternativeUrls(originalPath, audioData, urlIndex + 1);
        });
      }

      // ğŸ” ä»ç¼“å­˜ç´¢å¼•ä¸­æŸ¥æ‰¾å¹¶æ’­æ”¾é¢„å½•åˆ¶éŸ³é¢‘
      async function tryFindAndPlayPrerecordedAudio(text, messageData) {
        try {
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ” å¼€å§‹æŸ¥æ‰¾éŸ³é¢‘æ–‡ä»¶:', text);
          
          // ğŸ” å°è¯•åŠ è½½ç¼“å­˜ç´¢å¼•
          const cacheIndexUrl = `${PREREC_BASE}/cache_index.json`;
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ” åŠ è½½ç¼“å­˜ç´¢å¼•:', cacheIndexUrl);
          
          const response = await fetch(cacheIndexUrl);
          if (!response.ok) {
            console.error('[é¢„å½•åˆ¶éŸ³é¢‘] âŒ æ— æ³•åŠ è½½ç¼“å­˜ç´¢å¼•:', response.status, response.statusText);
            return;
          }
          
          const cacheIndex = await response.json();
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ” ç¼“å­˜ç´¢å¼•åŠ è½½æˆåŠŸï¼Œæ¡ç›®æ•°:', Object.keys(cacheIndex).length);
          
          // ğŸ” æŸ¥æ‰¾åŒ¹é…çš„éŸ³é¢‘æ–‡ä»¶
          let foundEntry = null;
          let foundHash = null;
          
          // æ–¹æ³•1: ç›´æ¥æ–‡æœ¬åŒ¹é…
          for (const [hash, entry] of Object.entries(cacheIndex)) {
            if (entry.text === text || entry.normalized_text === text) {
              foundEntry = entry;
              foundHash = hash;
              console.log('[é¢„å½•åˆ¶éŸ³é¢‘] âœ… æ‰¾åˆ°åŒ¹é…æ–‡æœ¬çš„éŸ³é¢‘æ–‡ä»¶ (ç²¾ç¡®åŒ¹é…):', hash, entry.audio_file);
              break;
            }
          }
          
          // æ–¹æ³•2: å¦‚æœç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå°è¯•æ¨¡ç³ŠåŒ¹é…
          if (!foundEntry) {
            const normalizedText = text.replace(/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼š""''ï¼ˆï¼‰ã€ã€‘]/g, '').replace(/\s+/g, '');
            for (const [hash, entry] of Object.entries(cacheIndex)) {
              const entryNormalized = (entry.normalized_text || entry.text || '').replace(/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼š""''ï¼ˆï¼‰ã€ã€‘]/g, '').replace(/\s+/g, '');
              if (entryNormalized === normalizedText) {
                foundEntry = entry;
                foundHash = hash;
                console.log('[é¢„å½•åˆ¶éŸ³é¢‘] âœ… æ‰¾åˆ°åŒ¹é…æ–‡æœ¬çš„éŸ³é¢‘æ–‡ä»¶ (æ¨¡ç³ŠåŒ¹é…):', hash, entry.audio_file);
                break;
              }
            }
          }
          
          if (foundEntry && foundEntry.audio_file) {
            // ğŸµ æ„å»ºéŸ³é¢‘æ–‡ä»¶è·¯å¾„
            const audioFilePath = `prerecorded_audio/audio_files/${foundEntry.audio_file}`;
            console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸµ æ„å»ºéŸ³é¢‘æ–‡ä»¶è·¯å¾„:', audioFilePath);
            
            // æ’­æ”¾éŸ³é¢‘æ–‡ä»¶
            playPrerecordedAudio(audioFilePath, {
              text: text,
              audio_file: foundEntry.audio_file,
              hash: foundHash,
              ...messageData
            });
          } else {
            console.warn('[é¢„å½•åˆ¶éŸ³é¢‘] âš ï¸ æœªæ‰¾åˆ°åŒ¹é…çš„éŸ³é¢‘æ–‡ä»¶:', text);
            console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ” å¯ç”¨çš„éŸ³é¢‘æ–‡ä»¶åˆ—è¡¨:');
            Object.entries(cacheIndex).slice(0, 5).forEach(([hash, entry]) => {
              console.log(`  - ${hash}: "${entry.text || entry.normalized_text}"`);
            });
          }
          
        } catch (error) {
          console.error('[é¢„å½•åˆ¶éŸ³é¢‘] âŒ æŸ¥æ‰¾éŸ³é¢‘æ–‡ä»¶å¤±è´¥:', error);
        }
      }

      // æ’­æ”¾é¢„å½•åˆ¶éŸ³é¢‘æ–‡ä»¶
      function playPrerecordedAudio(audioFilePath, audioData) {
        try {
          const key = keyFromAudioData(audioData, audioData?.text);
          const now = Date.now();
          const last = prerecRecent.get(key) || 0;
          if (now - last < PREREC_TTL_MS) {
            console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ§Š èŠ‚æµï¼šçŸ­æ—¶é—´å†…é‡å¤è§¦å‘ï¼ŒåŒKeyè·³è¿‡ ->', key);
            return;
          }
          // å¦‚æœå½“å‰å°±æ­£åœ¨æ’­æ”¾åŒä¸€æ®µï¼Œç›´æ¥å¿½ç•¥
          if (prerecPlayingKey === key && prerecAudioEl && !prerecAudioEl.ended) {
            console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ” æ­£åœ¨æ’­æ”¾åŒä¸€æ®µï¼ŒåŒKeyè·³è¿‡ ->', key);
            return;
          }
          prerecRecent.set(key, now);
          
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] å¼€å§‹æ’­æ”¾:', audioFilePath, audioData);
          log('ç³»ç»Ÿ', `æ’­æ”¾é¢„å½•åˆ¶éŸ³é¢‘: ${audioData.text || 'æœªçŸ¥æ–‡æœ¬'}`, 'success');
          
          // ğŸ” è¯¦ç»†è°ƒè¯•ä¿¡æ¯
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ” è¯¦ç»†è°ƒè¯•ä¿¡æ¯:');
          console.log('  - API_BASE_URL:', API_BASE_URL);
          console.log('  - audioFilePath:', audioFilePath);
          console.log('  - audioFilePath ç±»å‹:', typeof audioFilePath);
          console.log('  - audioData:', JSON.stringify(audioData, null, 2));
          
          // ä½¿ç”¨ç»Ÿä¸€çš„URLæ„å»ºå‡½æ•°ï¼Œç¡®ä¿ç”Ÿæˆæ­£ç¡®çš„ç»å¯¹URL
          const audioUrl = buildAudioURL(audioFilePath);
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸµ æ„å»ºçš„å®Œæ•´URL:', audioUrl);
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] ğŸ” åŸå§‹è·¯å¾„:', audioFilePath);
          
          // è®¾ç½®æ’­æ”¾çŠ¶æ€
          prerecPlayingKey = key;
          
          // ä½¿ç”¨æ’é˜Ÿæœºåˆ¶æ’­æ”¾éŸ³é¢‘
          enqueueOrPlay(audioUrl, audioData);
          
        } catch (error) {
          console.error('[é¢„å½•åˆ¶éŸ³é¢‘] æ’­æ”¾å‡½æ•°æ‰§è¡Œå¤±è´¥:', error);
          log('ç³»ç»Ÿ', `é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾å‡½æ•°æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
          // å¼‚å¸¸æ—¶ä¹Ÿé‡Šæ”¾é”
          prerecPlayingKey = null;
          prerecAudioEl = null;
        }
      }

      // è§£æWebSocketè°ƒè¯•æ¶ˆæ¯
      function parseDebugMessage(message) {
        try {
          // å°è¯•è§£æJSONæ ¼å¼çš„æ¶ˆæ¯
          const jsonMessage = JSON.parse(message);
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯é¢„å½•åˆ¶éŸ³é¢‘ä¿¡å·
          if (jsonMessage.type === 'prerecorded_audio' && jsonMessage.data) {
            const audioData = jsonMessage.data;
            console.log('[WebSocket] æ”¶åˆ°é¢„å½•åˆ¶éŸ³é¢‘ä¿¡å·:', audioData);
            
            // è®°å½•é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾æ—¶é—´
            lastPrerecordedAudioTime = Date.now();
            
            // æ’­æ”¾é¢„å½•åˆ¶éŸ³é¢‘æ–‡ä»¶
            if (audioData.audio_file_path) {
              playPrerecordedAudio(audioData.audio_file_path, audioData);
            }
            
            // ä¸è¿”å›æ¶ˆæ¯å¯¹è±¡ï¼Œé¿å…é‡å¤æ˜¾ç¤º
            // é¢„å½•åˆ¶éŸ³é¢‘çš„æ–‡æœ¬å†…å®¹ä¼šé€šè¿‡ assistant_text æ¶ˆæ¯å•ç‹¬å‘é€
            return null;
          }
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„assistant_textæ¶ˆæ¯æ ¼å¼ï¼ˆä¼˜å…ˆå¤„ç†ï¼‰
          if (jsonMessage.type === 'assistant_text' && jsonMessage.data && jsonMessage.data.text) {
            const text = jsonMessage.data.text.trim();
            const kind = jsonMessage.data.kind || 'llm';
            const source = jsonMessage.data.source;
            
            // ä»…æ ‡æ³¨ä¸º"è§¦å‘é¢„å½•åˆ¶"ï¼Œä¸è®¾ç½®éŸ³é¢‘æ—¶é—´æˆ³
            if (source === 'prerecorded_cache') {
              return {
                type: (kind === 'stt') ? 'stt' : 'llm',
                content: `${text}ï¼ˆè§¦å‘é¢„å½•åˆ¶ï¼‰`
              };
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯é¢„å½•åˆ¶éŸ³é¢‘ç›¸å…³çš„æ¶ˆæ¯ï¼ˆåœ¨é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾åçš„çŸ­æ—¶é—´å†…ï¼‰
            const now = Date.now();
            const isPrerecordedRelated = (now - lastPrerecordedAudioTime) < PRERECORDED_AUDIO_WINDOW;
            
            return {
              type: (kind === 'stt') ? 'stt' : 'llm',
              content: isPrerecordedRelated ? `${text}ï¼ˆè§¦å‘é¢„å½•åˆ¶ï¼‰` : text
            };
          }
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯æ—§çš„è°ƒè¯•æ¶ˆæ¯æ ¼å¼
          if (jsonMessage.type === 'debug' && jsonMessage.data && jsonMessage.data.message) {
            const debugText = jsonMessage.data.message.trim();
            console.log('[WebSocket] è§£æJSONè°ƒè¯•æ¶ˆæ¯:', debugText);
            
            // è§£æè°ƒè¯•æ¶ˆæ¯å†…å®¹
            if (debugText.startsWith('[LLM_DEBUG]')) {
              return {
                type: 'llm',
                content: debugText.replace('[LLM_DEBUG]', '').trim()
              };
            } else if (debugText.startsWith('[STT_DEBUG]')) {
              return {
                type: 'stt',
                content: debugText.replace('[STT_DEBUG]', '').trim()
              };
            } else if (debugText.startsWith('[WELCOME]')) {
              return {
                type: 'llm',
                content: debugText.replace('[WELCOME]', '').trim()
              };
            } else if (debugText.includes('ERROR')) {
              // åŒ¹é…å„ç§é”™è¯¯ç±»å‹
              const errorTypes = ['VAD_ERROR', 'STT_ERROR', 'LLM_ERROR', 'TTS_ERROR'];
              for (const errorType of errorTypes) {
                if (debugText.includes(`[${errorType}]`)) {
                  return {
                    type: 'error',
                    source: errorType.replace('_ERROR', ''),
                    content: debugText.replace(`[${errorType}]`, '').trim()
                  };
                }
              }
              return {
                type: 'error',
                source: 'ç³»ç»Ÿ',
                content: debugText
              };
            } else {
              return {
                type: 'info',
                content: debugText
              };
            }
          }
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯pingæ¶ˆæ¯
          if (jsonMessage.type === 'ping') {
            return {
              type: 'ping',
              content: 'ping'
            };
          }
          
          // å¤„ç†å…¶ä»–ç±»å‹çš„JSONæ¶ˆæ¯
          return {
            type: 'info',
            content: `æ”¶åˆ°JSONæ¶ˆæ¯: ${jsonMessage.type || 'æœªçŸ¥ç±»å‹'}`
          };
          
        } catch (e) {
          // å¦‚æœä¸æ˜¯JSONï¼ŒæŒ‰åŸæ¥çš„æ–‡æœ¬æ ¼å¼å¤„ç†
          const text = message.trim();
          console.log('[WebSocket] è§£ææ–‡æœ¬è°ƒè¯•æ¶ˆæ¯:', text);
          
          // åŒ¹é…ä¸åŒç±»å‹çš„è°ƒè¯•æ¶ˆæ¯
          if (text.startsWith('[LLM_DEBUG]')) {
            return {
              type: 'llm',
              content: text.replace('[LLM_DEBUG]', '').trim()
            };
          } else if (text.startsWith('[STT_DEBUG]')) {
            return {
              type: 'stt',
              content: text.replace('[STT_DEBUG]', '').trim()
            };
          } else if (text.startsWith('[WELCOME]')) {
            return {
              type: 'llm',
              content: text.replace('[WELCOME]', '').trim()
            };
          } else if (text.includes('ERROR')) {
            // åŒ¹é…å„ç§é”™è¯¯ç±»å‹
            const errorTypes = ['VAD_ERROR', 'STT_ERROR', 'LLM_ERROR', 'TTS_ERROR'];
            for (const errorType of errorTypes) {
              if (text.includes(`[${errorType}]`)) {
                return {
                  type: 'error',
                  source: errorType.replace('_ERROR', ''),
                  content: text.replace(`[${errorType}]`, '').trim()
                };
              }
            }
            return {
              type: 'error',
              source: 'ç³»ç»Ÿ',
              content: text
            };
          } else {
            return {
              type: 'info',
              content: text
            };
          }
        }
      }

      // è¿æ¥WebSocket
      function connectWebSocket() {
        if (debugWebSocket && debugWebSocket.readyState === WebSocket.OPEN) {
          return; // å·²ç»è¿æ¥
        }

        updateWebSocketStatus('connecting', 'è¿æ¥ä¸­...');
        
        try {
          // ç›´æ¥å›ºå®šæˆåŸŸå + /wsï¼ˆç”± Nginx è´Ÿè´£ TLS å’Œåä»£ï¼‰
          const wsUrl = 'wss://cityuantifraud.cn/ws';
          
          console.log(`[WebSocket] å°è¯•è¿æ¥: ${wsUrl}`);
          debugWebSocket = new WebSocket(wsUrl);
          
          debugWebSocket.onopen = function(event) {
            console.log('[WebSocket] è¿æ¥æˆåŠŸ');
            updateWebSocketStatus('connected', 'å·²è¿æ¥');
            wsReconnectAttempts = 0;
            log('WebSocket', 'è°ƒè¯•è¿æ¥å·²å»ºç«‹', 'success');
            
            // å‘é€bindæ¶ˆæ¯ä»¥ç»‘å®šå®¢æˆ·ç«¯ï¼ˆæ‰å¹³JSONæ ¼å¼ï¼‰
            try {
              const bindMessage = JSON.stringify({
                type: 'bind',
                client_id: 'web_console',
                client_type: 'web_client'
              });
              debugWebSocket.send(bindMessage);
              console.log('[WebSocket] å·²å‘é€bindæ¶ˆæ¯:', bindMessage);
            } catch (error) {
              console.error('[WebSocket] å‘é€bindæ¶ˆæ¯å¤±è´¥:', error);
            }
          };
          
          debugWebSocket.onmessage = function(event) {
            wsMessageCount++;
            elements.wsMessageCount.textContent = wsMessageCount;
            
            // æ·»åŠ è¯¦ç»†çš„WebSocketæ¶ˆæ¯æ¥æ”¶æ—¥å¿—
            console.log('[WebSocket] æ”¶åˆ°æ¶ˆæ¯:', event.data);
            console.log('[WebSocket] æ¶ˆæ¯è®¡æ•°:', wsMessageCount);
            
            try {
              const parsed = parseDebugMessage(event.data);
              console.log('[WebSocket] è§£æåçš„æ¶ˆæ¯:', parsed);
              
              // æ£€æŸ¥parsedæ˜¯å¦ä¸ºnullï¼ˆé¢„å½•åˆ¶éŸ³é¢‘æ¶ˆæ¯ä¼šè¿”å›nullï¼‰
              if (parsed === null) {
                console.log('[WebSocket] é¢„å½•åˆ¶éŸ³é¢‘æ¶ˆæ¯å·²å¤„ç†ï¼Œè·³è¿‡åç»­å¤„ç†');
                return;
              }
              
              if (parsed.type === 'ping') {
                // å“åº”pingæ¶ˆæ¯ï¼Œå‘é€pong
                try {
                  const pongMessage = JSON.stringify({
                    type: 'pong',
                    data: {}
                  });
                  debugWebSocket.send(pongMessage);
                  console.log('[WebSocket] ğŸ’“ æ”¶åˆ°pingï¼Œå·²å‘é€pongå“åº”');
                } catch (error) {
                  console.error('[WebSocket] å‘é€pongå“åº”å¤±è´¥:', error);
                }
              } else if (parsed.type === 'stt') {
                log('STT', parsed.content, 'stt');
                console.log('[WebSocket] STTæ¶ˆæ¯å·²å¤„ç†:', parsed.content);
              } else if (parsed.type === 'llm') {
                log('LLM', parsed.content, 'llm');
                console.log('[WebSocket] LLMæ¶ˆæ¯å·²å¤„ç†:', parsed.content);
              } else if (parsed.type === 'error') {
                log(parsed.source, parsed.content, 'error');
                showErrorPopup(`${parsed.source}é”™è¯¯`, parsed.content);
                console.log('[WebSocket] é”™è¯¯æ¶ˆæ¯å·²å¤„ç†:', parsed.source, parsed.content);
              } else {
                log('è°ƒè¯•', parsed.content);
                console.log('[WebSocket] è°ƒè¯•æ¶ˆæ¯å·²å¤„ç†:', parsed.content);
              }
            } catch (error) {
              console.error('[WebSocket] æ¶ˆæ¯è§£æå¤±è´¥:', error, 'åŸå§‹æ¶ˆæ¯:', event.data);
              log('WebSocket', `æ¶ˆæ¯è§£æå¤±è´¥: ${error.message}`, 'error');
            }
          };
          
          debugWebSocket.onclose = function(event) {
            console.log('[WebSocket] è¿æ¥å…³é—­:', event.code, event.reason);
            updateWebSocketStatus('disconnected', 'å·²æ–­å¼€');
            
            // è‡ªåŠ¨é‡è¿é€»è¾‘
            if (wsReconnectAttempts < WS_MAX_RECONNECT_ATTEMPTS) {
              wsReconnectAttempts++;
              log('WebSocket', `è¿æ¥æ–­å¼€ï¼Œ${WS_RECONNECT_DELAY/1000}ç§’åå°è¯•é‡è¿ (${wsReconnectAttempts}/${WS_MAX_RECONNECT_ATTEMPTS})`);
              
              wsReconnectTimer = setTimeout(() => {
                connectWebSocket();
              }, WS_RECONNECT_DELAY);
            } else {
              log('WebSocket', 'é‡è¿æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°é¡µé¢', 'error');
            }
          };
          
          debugWebSocket.onerror = function(error) {
            console.error('[WebSocket] è¿æ¥é”™è¯¯:', error);
            updateWebSocketStatus('disconnected', 'è¿æ¥å¤±è´¥');
            log('WebSocket', 'è¿æ¥å‡ºç°é”™è¯¯', 'error');
          };
          
        } catch (error) {
          console.error('[WebSocket] åˆ›å»ºè¿æ¥å¤±è´¥:', error);
          updateWebSocketStatus('disconnected', 'åˆ›å»ºå¤±è´¥');
          log('WebSocket', `åˆ›å»ºè¿æ¥å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // æ–­å¼€WebSocketè¿æ¥
      function disconnectWebSocket() {
        if (wsReconnectTimer) {
          clearTimeout(wsReconnectTimer);
          wsReconnectTimer = null;
        }
        
        if (debugWebSocket) {
          debugWebSocket.close();
          debugWebSocket = null;
        }
        
        updateWebSocketStatus('disconnected', 'æœªè¿æ¥');
        wsReconnectAttempts = 0;
      }

      async function fetchAgoraConfig(role = "publisher") {
        if (role === "publisher" && agoraConfigCache) {
          return agoraConfigCache;
        }
        const url = new URL("/api/agora/config", backendBaseUrl);
        url.searchParams.set("role", role);
        const response = await fetch(url.toString(), {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          throw new Error(`åç«¯æ¥å£è¿”å› ${response.status}`);
        }
        const config = await response.json();
        if (!config || !config.appId) {
          throw new Error("åç«¯ç¼ºå°‘å£°ç½‘ App ID");
        }

        // UIDé…ç½®éªŒè¯
        const validationResult = WebUIDValidator.validateConfiguration(config);
        if (!validationResult.isValid) {
          console.error("[CONFIG] UIDé…ç½®éªŒè¯å¤±è´¥:", validationResult.errors);
          throw new Error(`UIDé…ç½®æ— æ•ˆ: ${validationResult.errors.join(", ")}`);
        }

        if (validationResult.warnings.length > 0) {
          console.warn("[CONFIG] UIDé…ç½®è­¦å‘Š:", validationResult.warnings);
        }

        // è®°å½•UIDä¿¡æ¯
        WebUIDValidator.logUIDInfo("é…ç½®éªŒè¯", config.botUid, {
          userUID: config.uid,
          channel: config.channel,
        });

        if (role === "publisher") {
          agoraConfigCache = config;
        }
        return config;
      }

      function startMicMeter(track) {
        try {
          const streamTrack = track.getMediaStreamTrack();
          if (!streamTrack) {
            return;
          }
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(
            new MediaStream([streamTrack])
          );
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          micDataArray = new Uint8Array(bufferLength);
          source.connect(analyser);

          const update = () => {
            analyser.getByteTimeDomainData(micDataArray);
            let sum = 0;
            for (let i = 0; i < micDataArray.length; i += 1) {
              const value = micDataArray[i] - 128;
              sum += value * value;
            }
            const rms = Math.sqrt(sum / micDataArray.length);
            const level = Math.min(
              100,
              Math.max(0, Math.round((rms / 128) * 100))
            );
            elements.micLevel.textContent = `${level}%`;
            if (elements.micBar) {
              elements.micBar.style.width = `${level}%`;
            }
            meterAnimation = requestAnimationFrame(update);
          };
          update();
        } catch (error) {
          log("ç³»ç»Ÿ", `éº¦å…‹é£ç”µå¹³ç›‘æ§å¼‚å¸¸: ${error.message}`);
        }
      }

      function stopMicMeter() {
        if (meterAnimation) {
          cancelAnimationFrame(meterAnimation);
          meterAnimation = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        analyser = null;
        micDataArray = null;
        elements.micLevel.textContent = "0%";
        if (elements.micBar) {
          elements.micBar.style.width = "0%";
        }
      }

      // ç«äº‰æ€§å•é€šé“ç›¸å…³å˜é‡
      const CHANNEL = "solidchannel";
      let sessionId, token, uid, appId;
      let beatTimer;
      let remoteCheckTimer = null; // âœ… æ–°å¢ï¼šè¿œç«¯ç”¨æˆ·å®šæ—¶æ£€æŸ¥è®¡æ—¶å™¨ï¼ˆå…¨å±€ï¼‰
      let clientHandlers = {
        userUnpublished: null,
        userLeft: null,
        connectionStateChange: null,
      };
      async function leaveAndCleanup() {
        try {
          if (client && client.connectionState !== "DISCONNECTED") {
            await client.leave();
            log("å£°ç½‘", "å·²ç¦»å¼€é¢‘é“");
          }
        } catch(e) {
          console.error("ç¦»å¼€é¢‘é“å¤±è´¥:", e);
        }
        
        try {
          if (sessionId) {
            // sendBeacon ç¡®ä¿é¡µé¢å…³é—­æ—¶ä¹Ÿèƒ½å‘å‡º
            const leaveUrl = `${API_BASE_URL}/rtc/leave`;
            navigator.sendBeacon(leaveUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
            log("ç³»ç»Ÿ", "å·²é‡Šæ”¾æˆ¿é—´é”");
          }
          
          // å…³é—­RTCç³»ç»Ÿï¼ˆé‡Šæ”¾Agoraèµ„æºï¼‰
          const shutdownUrl = `${API_BASE_URL}/api/rtc/shutdown`;
          navigator.sendBeacon(shutdownUrl, new Blob([JSON.stringify({})], {type:"application/json"}));
          log("ç³»ç»Ÿ", "å·²è¯·æ±‚å…³é—­RTCç³»ç»Ÿ");
          
        } catch(e) {
          console.error("é‡Šæ”¾èµ„æºå¤±è´¥:", e);
        }
        
        clearInterval(beatTimer); 
        beatTimer = null;
        sessionId = token = uid = appId = null;
        
        // æ¸…ç†éŸ³é¢‘è½¨é“
        if (microphoneAudioTrack) {
          microphoneAudioTrack.close();
          microphoneAudioTrack = null;
        }
        // âœ… é€€å‡ºæ—¶å¤ä½å…¨å±€å›è°ƒï¼Œé¿å…äºŒæ¬¡è¿›å…¥é¡µé¢å‡ºç°å¼‚å¸¸è¡Œä¸º
        try {
          AgoraRTC.onAutoplayFailed = null;
        } catch (_) {}

        // âœ… ç»Ÿä¸€æ¸…ç†è¿œç«¯æ£€æŸ¥å®šæ—¶å™¨
        if (remoteCheckTimer) {
          clearInterval(remoteCheckTimer);
          remoteCheckTimer = null;
        }

        setConnectionState("offline", "å·²æ–­å¼€è¿æ¥");
        elements.connectButton.disabled = false;
        isConnecting = false;
      }

      async function enterAndJoin() {
        if (isConnecting) {
          return;
        }
        isConnecting = true;
        
        setConnectionState("idle", "æ­£åœ¨åˆå§‹åŒ–RTCç³»ç»Ÿ...");
        elements.connectButton.disabled = true;
        log("ç³»ç»Ÿ", "å¼€å§‹åˆå§‹åŒ–RTCç³»ç»Ÿ...");

        try {
          // 0) å…ˆåˆå§‹åŒ–RTCç³»ç»Ÿï¼ˆæŒ‰éœ€å¯åŠ¨Agoraè¿æ¥ï¼‰
          const initUrl = `${API_BASE_URL}/api/rtc/init`;
          console.log("åˆå§‹åŒ–RTCç³»ç»ŸURL:", initUrl);
          const initResponse = await fetch(initUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({})
          });
          
          if (!initResponse.ok) {
            throw new Error(`RTCåˆå§‹åŒ–å¤±è´¥ HTTP ${initResponse.status}: ${initResponse.statusText}`);
          }
          
          const initResult = await initResponse.json();
          if (!initResult.ok) {
            throw new Error(`RTCåˆå§‹åŒ–å¤±è´¥: ${initResult.error}`);
          }
          
          log("ç³»ç»Ÿ", "âœ… RTCç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸï¼Œæ­£åœ¨ç”³è¯·è¿›å…¥æˆ¿é—´...");
          setConnectionState("idle", "æ­£åœ¨ç”³è¯·è¿›å…¥æˆ¿é—´...");

          // å¯åŠ¨WebSocketè°ƒè¯•è¿æ¥
          connectWebSocket();

          // 1) ç”³è¯·è¿›å…¥ï¼ˆæ‹¿é”+æ‹¿tokenï¼‰
          const enterUrl = `${API_BASE_URL}/rtc/enter`;
          console.log("è¯·æ±‚URL:", enterUrl);
          const response = await fetch(enterUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({ channel: CHANNEL })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const r = await response.json();

          if (!r.ok) {
            if (r.reason === "BUSY") {
              alert("å½“å‰çº¿è·¯æ­£å¿™ï¼Œè¯·ç¨åå†è¯•ã€‚");
              log("ç³»ç»Ÿ", "æˆ¿é—´è¢«å ç”¨ï¼Œæ— æ³•è¿›å…¥", "error");
            } else {
              alert(`è¿›å…¥æˆ¿é—´å¤±è´¥: ${r.reason}`);
              log("ç³»ç»Ÿ", `è¿›å…¥æˆ¿é—´å¤±è´¥: ${r.reason}`, "error");
            }
            setConnectionState("offline", "è¿›å…¥æˆ¿é—´å¤±è´¥");
            elements.connectButton.disabled = false;
            isConnecting = false;
            return;
          }

          sessionId = r.sessionId; 
          token = r.token; 
          uid = r.uid; 
          appId = r.appId;
          
          log("ç³»ç»Ÿ", `æˆåŠŸè·å–æˆ¿é—´é”ï¼Œä¼šè¯ID: ${sessionId}`);
          elements.localUid.textContent = uid || "-";
          elements.channelName.textContent = CHANNEL;

          // 2) å¿ƒè·³ï¼ˆ10sä¸€æ¬¡ï¼‰â€”â€”æ–­ç½‘/å´©æºƒå 25s è‡ªåŠ¨é‡Šæ”¾
          beatTimer = setInterval(()=> {
            const beatUrl = `${API_BASE_URL}/rtc/beat`;
            navigator.sendBeacon(beatUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
          }, 10000);

          setConnectionState("idle", "æ­£åœ¨åŠ å…¥å£°ç½‘é¢‘é“...");
          
          if (client.connectionState !== "DISCONNECTED") {
            await client.leave().catch(() => {});
          }

          // 3) åŠ å…¥é¢‘é“
          await client.join(appId, CHANNEL, token, uid);
          log("å£°ç½‘", `å·²åŠ å…¥é¢‘é“ ${CHANNEL}`);

          // ğŸš€ å…³é”®ä¿®å¤ï¼šç«‹å³ç»‘å®šäº‹ä»¶ç›‘å¬ï¼Œé¿å…é”™è¿‡ Bot çš„ published äº‹ä»¶
          console.log("[FLOW] ğŸ”§ ç«‹å³ç»‘å®šäº‹ä»¶ç›‘å¬å™¨...");
          bindClientEvents();

          // 4) åˆå§‹åŒ–è®¢é˜…ç®¡ç†å™¨ï¼ˆç›‘å¬Botç”¨æˆ·ï¼‰
          const config = await fetchAgoraConfig("publisher"); // è·å–botUid
          subscriptionManager = new WebSubscriptionManager(client, {
            maxRetryAttempts: 3,
            retryDelay: 2000,
            enableAutoSubscribe: true,
            logLevel: "info",
          });
          // æ³¨æ„ï¼šWebSubscriptionManagerä¸éœ€è¦initializeæ–¹æ³•ï¼Œæ„é€ å‡½æ•°å·²å®Œæˆåˆå§‹åŒ–
          // subscriptionManager.setSubscriptionCallback(handleSubscription); // æ­¤æ–¹æ³•ä¹Ÿä¸å­˜åœ¨ï¼Œä½¿ç”¨å›è°ƒå±æ€§ä»£æ›¿

          subscriptionManager.onSubscriptionSuccess = (uid, mediaType, result) => {
            console.log(`[SUBSCRIPTION] âœ… è®¢é˜…æˆåŠŸ: ${uid} (${mediaType})`);
            log("è®¢é˜…", `æˆåŠŸè®¢é˜…ç”¨æˆ· ${uid} çš„${mediaType === "audio" ? "éŸ³é¢‘" : "è§†é¢‘"}æµ`);

            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              console.log(`[SUBSCRIPTION] ğŸ¤– Botç”¨æˆ·éŸ³é¢‘è®¢é˜…æˆåŠŸï¼Œå¼€å§‹æ’­æ”¾`);

              // ä¿å­˜å…¨å±€å˜é‡ï¼Œæ–¹ä¾¿ autoplayFailed æˆ–æ–­å¼€æ—¶æ¸…ç†
              remoteAudioTrack = result || client.remoteUsers.find(u => String(u.uid) === String(uid))?.audioTrack;

              if (remoteAudioTrack) {
                try {
                  remoteAudioTrack.play("remoteAudio");
                  console.log("[SUBSCRIPTION] BotéŸ³é¢‘å·²æ’­æ”¾");
                } catch (err) {
                  console.warn("[SUBSCRIPTION] æ’­æ”¾å¤±è´¥ï¼Œå¯èƒ½æ˜¯ autoplay é™åˆ¶:", err);
                }
              } else {
                console.error("[SUBSCRIPTION] è®¢é˜…æˆåŠŸä½†æœªè·å–åˆ° audioTrack å¯¹è±¡");
              }
            }
          };



          subscriptionManager.onSubscriptionFailed = (
            uid,
            mediaType,
            error
          ) => {
            console.error(
              `[SUBSCRIPTION] âŒ è®¢é˜…å¤±è´¥: ${uid} (${mediaType})`,
              error
            );
            log(
              "è®¢é˜…",
              `è®¢é˜…ç”¨æˆ· ${uid} çš„${
                mediaType === "audio" ? "éŸ³é¢‘" : "è§†é¢‘"
              }æµå¤±è´¥: ${error.message}`,
              "error"
            );
          };

          subscriptionManager.onSubscriptionStateChanged = (
            uid,
            mediaType,
            state
          ) => {
            console.log(
              `[SUBSCRIPTION] ğŸ”„ è®¢é˜…çŠ¶æ€å˜åŒ–: ${uid} (${mediaType}) -> ${state}`
            );

            // æ›´æ–°UIæ˜¾ç¤º
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              const stateText =
                {
                  not_subscribed: "æœªè®¢é˜…",
                  subscribing: "è®¢é˜…ä¸­",
                  subscribed: "å·²è®¢é˜…",
                  subscription_failed: "è®¢é˜…å¤±è´¥",
                  unsubscribing: "å–æ¶ˆè®¢é˜…ä¸­",
                }[state] || state;

              elements.remoteUid.textContent = `Bot(${uid}) - ${stateText}`;
            }
          };

          console.log("[SUBSCRIPTION] è®¢é˜…ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œå·²è®¾ç½®å›è°ƒå‡½æ•°");

          // ğŸš€ å…³é”®ä¿®å¤ï¼šç«‹å³æ‰«æå¹¶è¡¥è®¢ç°æœ‰çš„ Bot ç”¨æˆ·
          console.log("[FLOW] ğŸ” æ‰«æå¹¶è¡¥è®¢ç°æœ‰ Bot ç”¨æˆ·...");
          await scanAndSubscribeExistingBots();

          // [DEBUG] æ£€æŸ¥å½“å‰è¿œç«¯ç”¨æˆ·
          console.log("[DEBUG] å½“å‰è¿œç«¯ç”¨æˆ·:", client.remoteUsers);
          console.log("[DEBUG] è¿œç«¯ç”¨æˆ·æ•°é‡:", client.remoteUsers.length);
          client.remoteUsers.forEach((user) => {
            console.log("[DEBUG] è¿œç«¯ç”¨æˆ·è¯¦æƒ…:", {
              uid: user.uid,
              hasAudio: user.hasAudio,
              hasVideo: user.hasVideo,
            });
          });

          // [AUDIO_FLOW] æ£€æŸ¥éº¦å…‹é£æƒé™å’Œè®¾å¤‡
          try {
            const devices = await AgoraRTC.getDevices();
            const audioInputs = devices.filter(
              (device) => device.kind === "audioinput"
            );
            console.log(
              "[AUDIO_FLOW] å¯ç”¨éŸ³é¢‘è¾“å…¥è®¾å¤‡:",
              audioInputs.map((d) => ({ id: d.deviceId, label: d.label }))
            );

            if (audioInputs.length === 0) {
              console.warn("[AUDIO_FLOW] è­¦å‘Š: æœªæ£€æµ‹åˆ°éŸ³é¢‘è¾“å…¥è®¾å¤‡");
            }
          } catch (error) {
            console.error("[AUDIO_FLOW] è·å–éŸ³é¢‘è®¾å¤‡å¤±è´¥:", error);
          }

          // åˆ›å»ºå’Œå‘å¸ƒéŸ³é¢‘è½¨é“
          console.log("[AUDIO_FLOW] å¼€å§‹åˆ›å»ºéº¦å…‹é£éŸ³é¢‘è½¨é“...");
          microphoneAudioTrack = await AgoraRTC.createMicrophoneAudioTrack({
            encoderConfig: {
              sampleRate: 48000,
              stereo: false,
            },
          });
          localTrack = microphoneAudioTrack; // ä¿æŒå…¼å®¹æ€§

          // [AUDIO_FLOW] éŸ³é¢‘è½¨é“åˆ›å»ºæˆåŠŸè°ƒè¯•æ—¥å¿—
          console.log("[AUDIO_FLOW] éº¦å…‹é£éŸ³é¢‘è½¨é“å·²åˆ›å»º:", {
            trackId: microphoneAudioTrack.getTrackId(),
            enabled: microphoneAudioTrack.enabled,
            muted: microphoneAudioTrack.muted,
            sampleRate: 48000,
          });

          await client.publish(microphoneAudioTrack);

          // [AUDIO_FLOW] éŸ³é¢‘å‘å¸ƒæˆåŠŸè°ƒè¯•æ—¥å¿—
          console.log("[AUDIO_FLOW] æœ¬åœ°éŸ³é¢‘å·²å‘å¸ƒåˆ°å£°ç½‘:", {
            trackId: microphoneAudioTrack.getTrackId(),
            published: true,
            clientState: client.connectionState,
          });

          log("å£°ç½‘", "æœ¬åœ°éŸ³é¢‘å·²å‘å¸ƒ");

          // [AUDIO_FLOW] æ·»åŠ éŸ³é¢‘æ•°æ®å¤„ç†å™¨ç›‘å¬éŸ³é¢‘æµ
          if (microphoneAudioTrack) {
            let audioFrameCounter = 0;
            try {
              const processor = {
                process: (audioBuffer) => {
                  audioFrameCounter++;
                  if (audioFrameCounter % 100 === 0) {
                    console.log(
                      "[AUDIO_FLOW] éŸ³é¢‘æ•°æ®æµç»å£°ç½‘SDK (ç¬¬" +
                        audioFrameCounter +
                        "å¸§):",
                      {
                        sampleRate: audioBuffer.sampleRate,
                        numberOfChannels: audioBuffer.numberOfChannels,
                        length: audioBuffer.length,
                        timestamp: Date.now(),
                      }
                    );
                  }
                  return audioBuffer;
                },
              };

              if (localTrack.pipe && typeof localTrack.pipe === "function") {
                localTrack.pipe(processor);
                console.log("[AUDIO_FLOW] éŸ³é¢‘å¤„ç†å™¨å·²æ·»åŠ åˆ°æœ¬åœ°è½¨é“");
              } else {
                console.log(
                  "[AUDIO_FLOW] æœ¬åœ°è½¨é“ä¸æ”¯æŒpipeæ–¹æ³•ï¼Œå°è¯•å…¶ä»–ç›‘å¬æ–¹å¼"
                );
              }
            } catch (error) {
              console.log("[AUDIO_FLOW] æ·»åŠ éŸ³é¢‘å¤„ç†å™¨å¤±è´¥:", error.message);
            }

            startMicMeter(microphoneAudioTrack);
          }

          // å¤„ç† Autoplay é™åˆ¶
          AgoraRTC.onAutoplayFailed = () => {
            console.warn("[WARN] Autoplay è¢«é™åˆ¶ï¼Œåˆ›å»ºæ¢å¤æŒ‰é’®");
            const btn = document.createElement("button");
            btn.innerText = "ç‚¹å‡»æ¢å¤ Bot éŸ³é¢‘";
            btn.style.padding = "12px";
            btn.style.margin = "16px";
            btn.style.background = "#48bb78";
            btn.style.color = "#fff";
            btn.style.borderRadius = "8px";
            btn.onclick = () => {
              if (remoteAudioTrack) {
                remoteAudioTrack.play("remoteAudio");
                console.log("[DEBUG] ç”¨æˆ·ç‚¹å‡»åæ¢å¤æ’­æ”¾æˆåŠŸ");
              }
              btn.remove();
            };
            document.body.appendChild(btn);
          };

          // ğŸš€ å…³é”®ä¿®å¤ï¼šåœ¨æ‰€æœ‰å‡†å¤‡å·¥ä½œå®Œæˆåå†è§¦å‘æ¬¢è¿è¯­
          console.log("[FLOW] ğŸ‰ æ‰€æœ‰å‡†å¤‡å·¥ä½œå®Œæˆï¼Œç°åœ¨è§¦å‘æ¬¢è¿è¯­...");
          try {
            const resp = await fetch(`${API_BASE_URL}/api/rtc/welcome`, {
              method: "POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({})
            });
            const data = await resp.json();
            console.log("[WELCOME] è§¦å‘ç»“æœ:", data);
            if (data.ok && data.welcome_sent) {
              log("ç³»ç»Ÿ", "âœ… æ¬¢è¿è¯­å·²è§¦å‘ï¼ˆéŸ³é¢‘è®¢é˜…å·²å°±ç»ªï¼‰");
            } else {
              console.warn("[WELCOME] è§¦å‘å¤±è´¥æˆ–æœªå‘é€:", data);
            }
          } catch (err) {
            console.error("[WELCOME] è¯·æ±‚å‡ºé”™:", err);
          }

          // --- æ–°å¢ï¼šåŠ å…¥åä¸»åŠ¨æ£€æŸ¥Botç”¨æˆ·å¹¶å¯èƒ½å¯åŠ¨é‡è¯• ---
          if (subscriptionManager) {
            // å¯ä»¥é€‰æ‹©æ€§åœ°å»¶è¿Ÿä¸€ä¸‹ï¼Œç¡®ä¿ SDK çŠ¶æ€æ›´ç¨³å®šï¼Œæˆ–è€…ç›´æ¥è°ƒç”¨
            // setTimeout(() => {
              subscriptionManager.checkBotUsersForRetry();
            // }, 100); // å»¶è¿Ÿ 100msï¼Œå¯é€‰
          } else {
            console.warn("SubscriptionManager æœªæ‰¾åˆ°ï¼Œæ— æ³•æ£€æŸ¥Botç”¨æˆ·é‡è¯•ã€‚");
          }
          // --- æ–°å¢ç»“æŸ ---

          setConnectionState("online", "å£°ç½‘é“¾è·¯å·²å»ºç«‹ï¼Œç­‰å¾… Bot éŸ³é¢‘...");
          elements.disconnectButton.disabled = false;
          log("ç³»ç»Ÿ", "è¿æ¥å®Œæˆï¼ŒBot éŸ³é¢‘å°†è‡ªåŠ¨æ’­æ”¾");

          // ?? æ·»åŠ ï¼šå®šæ—¶æ£€æŸ¥é¢‘é“å†…çš„è¿œç«¯ç”¨æˆ·ï¼ˆå¢å¼ºç‰ˆï¼‰
          if (remoteCheckTimer) { clearInterval(remoteCheckTimer); remoteCheckTimer = null; } // é¿å…é‡å¤
          remoteCheckTimer = setInterval(() => {
            const remoteUsers = client.remoteUsers;
            console.log("[CHECK] =========================");
            console.log("[CHECK] é¢‘é“å†…è¿œç«¯ç”¨æˆ·æ€»æ•°:", remoteUsers.length);

            if (remoteUsers.length === 0) {
              console.log("[CHECK] ?? é¢‘é“å†…æ— è¿œç«¯ç”¨æˆ·");
            } else {
              remoteUsers.forEach((user) => {
                console.log(`[CHECK] ç”¨æˆ· ${user.uid}:`, {
                  hasAudioTrack: !!user.audioTrack,
                  hasVideoTrack: !!user.videoTrack,
                  isPlaying: user.audioTrack?.isPlaying,
                  audioTrackType: typeof user.audioTrack,
                  audioTrackObject: user.audioTrack,
                });

                if (user.audioTrack) {
                  console.log(
                    `[CHECK] ? ç”¨æˆ· ${user.uid} æœ‰éŸ³é¢‘è½¨é“ï¼Œæ’­æ”¾çŠ¶æ€: ${user.audioTrack.isPlaying}`
                  );
                } else {
                  console.log(`[CHECK] ? ç”¨æˆ· ${user.uid} æ— éŸ³é¢‘è½¨é“`);
                }

                // ç‰¹åˆ«æ£€æŸ¥Bot UID - ä½¿ç”¨UIDéªŒè¯å™¨
                if (WebUIDValidator.isBotUser(user.uid)) {
                  console.log(
                    `[CHECK] ğŸ¤– æ£€æµ‹åˆ°Botç”¨æˆ· ${
                      user.uid
                    }! (ç±»å‹: ${typeof user.uid})`
                  );
                  WebUIDValidator.logUIDInfo("Botç”¨æˆ·æ£€æµ‹", user.uid, {
                    hasAudioTrack: !!user.audioTrack,
                    isPlaying: user.audioTrack?.isPlaying,
                  });
                  if (!user.audioTrack) {
                    console.log(
                      `[CHECK] âš ï¸ Botç”¨æˆ·æ— éŸ³é¢‘è½¨é“ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨è®¢é˜…`
                    );
                  }
                }
              });
            }
            console.log("[CHECK] =========================");
          }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
        } catch (error) {
          log("é”™è¯¯", `è¿æ¥å¤±è´¥: ${error.message}`, "error");
          await disconnect();
        } finally {
          isConnecting = false;
          if (!elements.disconnectButton.disabled) {
            elements.connectButton.disabled = true;
          } else {
            elements.connectButton.disabled = false;
          }
        }
      }
      function bindClientEvents() {
        // å…ˆé˜²å¾¡æ€§è§£ç»‘ï¼ˆé¿å…æç«¯æƒ…å†µä¸‹é‡å¤ç»‘å®šï¼‰
        unbindClientEvents();

        // ğŸš€ å…³é”®ä¿®å¤ï¼šç«‹å³è®¢é˜… Bot éŸ³é¢‘ï¼Œé¿å…å»¶è¿Ÿ
        clientHandlers.userPublished = async (user, mediaType) => {
          console.log("[EVENT] user-published:", user.uid, mediaType);
          
          // å¦‚æœæ˜¯ Bot ç”¨æˆ·å‘å¸ƒéŸ³é¢‘ï¼Œç«‹å³è®¢é˜…
          if (mediaType === "audio" && WebUIDValidator.isBotUser(user.uid)) {
            try {
              console.log(`[AUTO] ğŸ¤– æ£€æµ‹åˆ° Bot ${user.uid} å‘å¸ƒéŸ³é¢‘ï¼Œç«‹å³è®¢é˜…...`);
              await client.subscribe(user, "audio");
              
              remoteAudioTrack = user.audioTrack;
              if (remoteAudioTrack) {
                // è®¾ç½®éŸ³é‡
                const volume = parseInt(elements.volumeSlider.value) || 70;
                remoteAudioTrack.setVolume(volume);
                
                // å¼€å§‹æ’­æ”¾
                remoteAudioTrack.play("remoteAudio");
                console.log(`[AUTO] âœ… Bot ${user.uid} éŸ³é¢‘å·²è®¢é˜…å¹¶å¼€å§‹æ’­æ”¾`);
                log("è‡ªåŠ¨è®¢é˜…", `Bot ${user.uid} éŸ³é¢‘å·²è¿æ¥å¹¶æ’­æ”¾`);
                
                // æ›´æ–°UIçŠ¶æ€
                elements.remoteUid.textContent = `Bot(${user.uid}) - å·²è¿æ¥`;
              } else {
                console.error(`[AUTO] âŒ è®¢é˜…æˆåŠŸä½†æœªè·å–åˆ° audioTrack`);
              }
            } catch (err) {
              console.error(`[AUTO] âŒ ç«‹å³è®¢é˜… Bot ${user.uid} éŸ³é¢‘å¤±è´¥:`, err);
              log("è®¢é˜…å¤±è´¥", `Bot ${user.uid} éŸ³é¢‘è®¢é˜…å¤±è´¥: ${err.message}`, "error");
            }
          }
        };

        clientHandlers.userUnpublished = (user, mediaType) => {
          console.log("[EVENT] user-unpublished:", user.uid, mediaType);
          if (WebUIDValidator.isBotUser(user.uid) && mediaType === "audio") {
            elements.remoteUid.textContent = "-";
            log("å–æ¶ˆå‘å¸ƒ", `Bot ${user.uid} å–æ¶ˆå‘å¸ƒéŸ³é¢‘`);
          }
        };

        clientHandlers.userLeft = (user) => {
          console.log("[EVENT] user-left:", user.uid);
          if (WebUIDValidator.isBotUser(user.uid)) {
            elements.remoteUid.textContent = "-";
            log("ç¦»å¼€", `Bot ${user.uid} å·²ç¦»å¼€`);
          }
        };

        clientHandlers.connectionStateChange = (cur, prev, reason) => {
          log("å£°ç½‘", `è¿æ¥çŠ¶æ€: ${prev} -> ${cur} (${reason})`);
        };

        // ç»‘å®šæ‰€æœ‰äº‹ä»¶
        client.on("user-published", clientHandlers.userPublished);
        client.on("user-unpublished", clientHandlers.userUnpublished);
        client.on("user-left", clientHandlers.userLeft);
        client.on("connection-state-change", clientHandlers.connectionStateChange);
      }

      // ğŸš€ å…³é”®ä¿®å¤ï¼šæ‰«æå¹¶è¡¥è®¢ç°æœ‰çš„ Bot ç”¨æˆ·
      async function scanAndSubscribeExistingBots() {
        console.log("[SCAN] å¼€å§‹æ‰«æç°æœ‰è¿œç«¯ç”¨æˆ·...");
        const remoteUsers = client.remoteUsers;
        console.log(`[SCAN] å‘ç° ${remoteUsers.length} ä¸ªè¿œç«¯ç”¨æˆ·`);
        
        for (const user of remoteUsers) {
          console.log(`[SCAN] æ£€æŸ¥ç”¨æˆ· ${user.uid}:`, {
            hasAudio: user.hasAudio,
            audioTrack: !!user.audioTrack,
            isBotUser: WebUIDValidator.isBotUser(user.uid)
          });
          
          if (WebUIDValidator.isBotUser(user.uid) && (user.hasAudio || user.audioTrack)) {
            try {
              console.log(`[SCAN] ğŸ¤– å‘ç°ç°æœ‰ Bot ${user.uid}ï¼Œç«‹å³è¡¥è®¢éŸ³é¢‘...`);
              
              // å¦‚æœè¿˜æ²¡æœ‰è®¢é˜…ï¼Œåˆ™è®¢é˜…
              if (!user.audioTrack) {
                await client.subscribe(user, "audio");
                console.log(`[SCAN] âœ… è¡¥è®¢ Bot ${user.uid} éŸ³é¢‘æˆåŠŸ`);
              }
              
              remoteAudioTrack = user.audioTrack;
              if (remoteAudioTrack) {
                // è®¾ç½®éŸ³é‡
                const volume = parseInt(elements.volumeSlider.value) || 70;
                remoteAudioTrack.setVolume(volume);
                
                // å¼€å§‹æ’­æ”¾
                remoteAudioTrack.play("remoteAudio");
                console.log(`[SCAN] âœ… Bot ${user.uid} éŸ³é¢‘å·²å¼€å§‹æ’­æ”¾`);
                log("è¡¥è®¢æˆåŠŸ", `å‘ç°å¹¶è¿æ¥äº† Bot ${user.uid} éŸ³é¢‘`);
                
                // æ›´æ–°UIçŠ¶æ€
                elements.remoteUid.textContent = `Bot(${user.uid}) - å·²è¿æ¥`;
                break; // æ‰¾åˆ°ä¸€ä¸ªBotå°±å¤Ÿäº†
              }
            } catch (err) {
              console.error(`[SCAN] âŒ è¡¥è®¢ Bot ${user.uid} éŸ³é¢‘å¤±è´¥:`, err);
              log("è¡¥è®¢å¤±è´¥", `Bot ${user.uid} éŸ³é¢‘è¡¥è®¢å¤±è´¥: ${err.message}`, "error");
            }
          }
        }
        
        if (remoteUsers.length === 0) {
          console.log("[SCAN] å½“å‰é¢‘é“å†…æ— è¿œç«¯ç”¨æˆ·ï¼Œç­‰å¾… Bot åŠ å…¥...");
        }
      }

      function unbindClientEvents() {
        if (clientHandlers.userPublished) {
          client.off("user-published", clientHandlers.userPublished);
        }
        if (clientHandlers.userUnpublished) {
          client.off("user-unpublished", clientHandlers.userUnpublished);
        }
        if (clientHandlers.userLeft) {
          client.off("user-left", clientHandlers.userLeft);
        }
        if (clientHandlers.connectionStateChange) {
          client.off("connection-state-change", clientHandlers.connectionStateChange);
        }
        // å¯é€‰ï¼šé‡ç½®ä¸º nullï¼Œé¿å…è¯¯ç”¨æ—§æŒ‡é’ˆ
        clientHandlers = {
          userPublished: null,
          userUnpublished: null,
          userLeft: null,
          connectionStateChange: null,
        };
      }
      async function disconnect() {
        elements.disconnectButton.disabled = true;
        
        try {

          // â‘  å…ˆè§£ç»‘æ‰€æœ‰ client äº‹ä»¶ï¼ˆå¯¹ç§°ï¼‰
          unbindClientEvents();
             // ï¼ˆå¯ç•™ç€ä½ çš„è¿™è¡Œï¼Œç­‰ä»·é˜²å¾¡ï¼‰
          // client.off("connection-state-change");
          
         // â‘¡ å…³è¿œç«¯/æœ¬åœ°è½¨é“
          if (remoteAudioTrack) {
            remoteAudioTrack.stop();
            remoteAudioTrack.close();
            remoteAudioTrack = null;
          }

          if (localTrack) {
            localTrack.stop();
            localTrack.close();
            localTrack = null;
          }
          // â‘¢ åœæ­¢ç”µå¹³åŠ¨ç”»
          stopMicMeter();

           // âœ… ç»Ÿä¸€æ¸…ç†è¿œç«¯æ£€æŸ¥å®šæ—¶å™¨
          if (remoteCheckTimer) {
            clearInterval(remoteCheckTimer);
            remoteCheckTimer = null;
          }
          // âœ… é€€å‡ºæ—¶å¤ä½å…¨å±€å›è°ƒï¼Œé¿å…äºŒæ¬¡è¿›å…¥é¡µé¢å‡ºç°å¼‚å¸¸è¡Œä¸º
          try {
            AgoraRTC.onAutoplayFailed = null;
          } catch (_) {}

          // æ¸…ç†è®¢é˜…ç®¡ç†å™¨
          if (subscriptionManager) {
            subscriptionManager.destroy();
            subscriptionManager = null;
            console.log("[SUBSCRIPTION] è®¢é˜…ç®¡ç†å™¨å·²æ¸…ç†");
          }

          // æ–­å¼€WebSocketè¿æ¥
          disconnectWebSocket();
         

          // è°ƒç”¨ç»Ÿä¸€çš„æ¸…ç†å‡½æ•°ï¼ˆåŒ…å«æˆ¿é—´é”é‡Šæ”¾ï¼‰
          await leaveAndCleanup();
        } catch (error) {
          log("é”™è¯¯", `æ–­å¼€è¿æ¥å‡ºç°é—®é¢˜: ${error.message}`);
          // å³ä½¿å‡ºé”™ä¹Ÿè¦å°è¯•æ¸…ç†
          await leaveAndCleanup();
        }
      }

      
    
      // ä¿®æ”¹ä¸ºå…ˆè§£é”éŸ³é¢‘å†å…¥ä¼š
      elements.connectButton.addEventListener("click", async () => {
        await AudioGate.unlock();   // âœ… ä¸€æ¬¡æ€§è§£é”
        flushPendingAudio();         // âœ… ä¸€æ¬¡æ€§å¤„ç†æœªè§£é”æœŸé—´ç§¯å‹çš„æ’­æ”¾
        preloadAudioFiles();         // âœ… è§£é”åé¢„åŠ è½½éŸ³é¢‘æ–‡ä»¶ï¼Œé¿å…ç§»åŠ¨ç«¯è¿‡æ—©æ‹‰èµ„æº
        await enterAndJoin();       // ç„¶åç…§å¸¸å…¥ä¼š
      });
      elements.disconnectButton.addEventListener("click", disconnect);

      // ç»‘å®šå¯¼å‡ºæ—¥å¿—æŒ‰é’®äº‹ä»¶
      const exportLogsButton = document.getElementById("exportLogsButton");
      if (exportLogsButton) {
        exportLogsButton.addEventListener("click", () => {
          const fullText = collectAllLogsText();

          // å¦‚æœæ–‡æœ¬ç‰¹åˆ«å¤§ï¼Œç»™ä¸ªæ¸©æŸ”æç¤ºï¼ˆä¸æˆªæ–­ï¼‰
          if (fullText.length > 2_000_000) {
            console.warn("[å¯¼å‡ºæ—¥å¿—] æ—¥å¿—æ–‡æœ¬è¾ƒå¤§ï¼ˆ>2MBï¼‰ï¼Œå¤åˆ¶å¯èƒ½è¾ƒæ…¢ã€‚");
          }

          // å¾®ä¿¡ / iPhone å‹å¥½ï¼šå¼¹çª— + å…¨é€‰/å¤åˆ¶æŒ‰é’®
          showLogsInPopup(fullText);
        });
      }

      elements.volumeSlider.addEventListener("input", (event) => {
        const volume = Number(event.target.value || "70");
        elements.remoteVolume.textContent = `${volume}%`;
        if (remoteAudioTrack) {
          remoteAudioTrack.setVolume(volume);
        }
      });

      // Dify App Selection Logic
      const difyApp1Button = document.getElementById("difyApp1Button");
      const difyApp2Button = document.getElementById("difyApp2Button");

      async function setDifyApp(appName) {
        try {
          const response = await fetch('/api/set_dify_app', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ app_name: appName }),
          });
          const result = await response.json();
          if (result.ok) {
            log('ç³»ç»Ÿ', `Dify åº”ç”¨å·²åˆ‡æ¢åˆ°: ${appName}`, 'success');
            // Update button styles
            if (appName === 'dify_app_1') {
              difyApp1Button.classList.add('active');
              difyApp2Button.classList.remove('active');
            } else {
              difyApp1Button.classList.remove('active');
              difyApp2Button.classList.add('active');
            }
          } else {
            log('ç³»ç»Ÿ', `Dify åº”ç”¨åˆ‡æ¢å¤±è´¥: ${result.error}`, 'error');
          }
        } catch (error) {
          log('ç³»ç»Ÿ', `Dify åº”ç”¨åˆ‡æ¢è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
        }
      }

      difyApp1Button.addEventListener("click", () => setDifyApp('dify_app_1'));
      difyApp2Button.addEventListener("click", () => setDifyApp('dify_app_2'));





      // â€”â€” æŒ‚åˆ°æ‰€æœ‰é€€å‡ºè·¯å¾„ â€”â€”
      // 1) å…³é—­/åˆ·æ–°
      window.addEventListener("beforeunload", leaveAndCleanup);
      window.addEventListener("pagehide", leaveAndCleanup);     // iOS Safari
      // 2) é¡µé¢å¯è§æ€§å˜åŒ–ï¼ˆå¯é€‰ï¼šåå°åœæ’­ï¼Œå‰å°å†æ’­ï¼‰
      window.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          console.log("[DEBUG] é¡µé¢è¿›å…¥åå°");
          // å¯é€‰ï¼šæš‚åœæŸäº›æ“ä½œ
        } else {
          console.log("[DEBUG] é¡µé¢å›åˆ°å‰å°");
          // å¯é€‰ï¼šæ¢å¤æŸäº›æ“ä½œ
        }
      });

      log("ç³»ç»Ÿ", "é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»æŒ‰é’®å³å¯ä½“éªŒå£°ç½‘ RTC é“¾è·¯ã€‚");
      
      // é¡µé¢åŠ è½½æ—¶å°è¯•è¿æ¥WebSocketè°ƒè¯•æœåŠ¡
      log("ç³»ç»Ÿ", "æ­£åœ¨è¿æ¥WebSocketè°ƒè¯•æœåŠ¡...");
      connectWebSocket();
    </script>
  </body>
</html>
