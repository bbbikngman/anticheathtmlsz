<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>声网 RTC 双工对话客户端</title>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.0.js"></script>
    <script src="web_uid_validator.js"></script>
    <script src="web_subscription_manager.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #5a67d8 0%, #805ad5 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #1a202c;
        padding: 24px;
      }

      .container {
        width: 100%;
        max-width: 900px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 20px;
        padding: 32px;
        box-shadow: 0 20px 60px rgba(67, 56, 202, 0.18);
      }

      header {
        text-align: center;
        margin-bottom: 24px;
      }

      header h1 {
        font-size: 2.2rem;
        color: #2d3748;
        margin-bottom: 8px;
      }

      header p {
        color: #4a5568;
      }

      .status-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }

      .status-card {
        background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        border-radius: 14px;
        padding: 18px;
        border: 1px solid #cbd5f5;
      }

      .status-card h2 {
        font-size: 1rem;
        color: #2b6cb0;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .status-value {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .status-value.online {
        color: #2f855a;
      }

      .status-value.offline {
        color: #c53030;
      }

      .status-value.idle {
        color: #b7791f;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-bottom: 24px;
        justify-content: center;
      }

      button {
        padding: 12px 28px;
        border: none;
        border-radius: 999px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: #fff;
      }

      button.primary {
        background: linear-gradient(135deg, #48bb78, #38a169);
      }

      button.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button.danger {
        background: linear-gradient(135deg, #f56565, #e53e3e);
      }

      button.danger:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      /* 一个没用的注释，触发重启 */
      .meter {
        background: #edf2f7;
        border-radius: 14px;
        padding: 12px 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.95rem;
        color: #4a5568;
      }

      .meter span {
        font-weight: 600;
        color: #2d3748;
      }

      .meter-bar {
        margin-top: 8px;
        width: 180px;
        height: 10px;
        background: #e2e8f0;
        border-radius: 999px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #63b3ed, #3182ce);
        transition: width 0.1s ease;
      }

      .conversation-log {
        background: #f7fafc;
        border-radius: 14px;
        border: 1px solid #e2e8f0;
        padding: 18px;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-entry {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px dashed rgba(160, 174, 192, 0.5);
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry time {
        display: block;
        font-size: 0.8rem;
        color: #718096;
        margin-bottom: 4px;
      }

      .log-entry strong {
        display: inline-block;
        min-width: 70px;
        color: #2b6cb0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 12px;
        justify-content: center;
        margin-top: 8px;
      }

      .volume-control label {
        font-weight: 600;
        color: #2d3748;
      }

      .volume-control input {
        width: 220px;
      }

      footer {
        margin-top: 24px;
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
      }

      footer code {
        background: #edf2f7;
        padding: 2px 6px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>声网 RTC 双工对话客户端</h1>
        <p>浏览器直接加入声网频道，上行麦克风、下行 Bot 音频</p>
      </header>

      <section class="status-panel">
        <div class="status-card">
          <h2>连接状态</h2>
          <div id="connectionStatus" class="status-value offline">未连接</div>
          <p id="statusHint">点击开始对话即可连接声网</p>
        </div>
        <div class="status-card">
          <h2>频道信息</h2>
          <div class="status-value">
            <div>频道：<span id="channelName">-</span></div>
            <div>本地 UID：<span id="localUid">-</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>Bot 状态</h2>
          <div class="status-value">
            <div>远端 UID：<span id="remoteUid">-</span></div>
            <div>音量：<span id="remoteVolume">70%</span></div>
          </div>
        </div>
      </section>

      <section class="controls">
        <button id="connectButton" class="primary">开始对话</button>
        <button id="disconnectButton" class="danger" disabled>断开连接</button>
      </section>

      <section class="meter">
        <div>
          <span>麦克风电平</span>
          <div class="meter-bar">
            <div id="micBar" class="meter-fill"></div>
          </div>
        </div>
        <div>
          <span id="micLevel">0%</span>
        </div>
      </section>

      <div class="volume-control">
        <label for="volumeSlider">Bot 音量</label>
        <input id="volumeSlider" type="range" min="0" max="100" value="70" />
      </div>

      <section class="conversation-log" id="logContainer"></section>

      <div id="remoteAudio"></div>

      <footer>
        <div>
          调试命令：<code
            >curl https://cityuantifraud.cn/api/agora/config</code
          >
        </div>
      </footer>
    </div>

    <script>
      const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
      let localTrack = null;
      let microphoneAudioTrack = null; // 添加缺失的变量定义
      let remoteAudioTrack = null;
      let agoraConfigCache = null;
      const backendBaseUrl = "https://cityuantifraud.cn";
      let isConnecting = false;
      let subscriptionManager = null;
      let audioContext = null;
      let analyser = null;
      let micDataArray = null;
      let meterAnimation = null;

      const elements = {
        connectionStatus: document.getElementById("connectionStatus"),
        statusHint: document.getElementById("statusHint"),
        channelName: document.getElementById("channelName"),
        localUid: document.getElementById("localUid"),
        remoteUid: document.getElementById("remoteUid"),
        remoteVolume: document.getElementById("remoteVolume"),
        connectButton: document.getElementById("connectButton"),
        disconnectButton: document.getElementById("disconnectButton"),
        volumeSlider: document.getElementById("volumeSlider"),
        micLevel: document.getElementById("micLevel"),
        micBar: document.getElementById("micBar"),
        logContainer: document.getElementById("logContainer"),
      };

      function log(source, message, type = "info") {
        const entry = document.createElement("div");
        entry.className = "log-entry";
        const timestamp = new Date().toLocaleTimeString();
        entry.innerHTML = `
          <time>${timestamp}</time>
          <div><strong>${source}</strong>${message}</div>
        `;
        if (type === "error") {
          entry.style.color = "#c53030";
        } else if (type === "success") {
          entry.style.color = "#2f855a";
        }
        elements.logContainer.appendChild(entry);
        elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
      }

      function setConnectionState(state, hint) {
        elements.connectionStatus.classList.remove("online", "offline", "idle");
        elements.connectionStatus.classList.add(state);
        elements.connectionStatus.textContent =
          state === "online"
            ? "已连接"
            : state === "offline"
            ? "未连接"
            : "准备中";
        if (hint) {
          elements.statusHint.textContent = hint;
        }
      }

      async function fetchAgoraConfig(role = "publisher") {
        if (role === "publisher" && agoraConfigCache) {
          return agoraConfigCache;
        }
        const url = new URL("/api/agora/config", backendBaseUrl);
        url.searchParams.set("role", role);
        const response = await fetch(url.toString(), {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          throw new Error(`后端接口返回 ${response.status}`);
        }
        const config = await response.json();
        if (!config || !config.appId) {
          throw new Error("后端缺少声网 App ID");
        }

        // UID配置验证
        const validationResult = WebUIDValidator.validateConfiguration(config);
        if (!validationResult.isValid) {
          console.error("[CONFIG] UID配置验证失败:", validationResult.errors);
          throw new Error(`UID配置无效: ${validationResult.errors.join(", ")}`);
        }

        if (validationResult.warnings.length > 0) {
          console.warn("[CONFIG] UID配置警告:", validationResult.warnings);
        }

        // 记录UID信息
        WebUIDValidator.logUIDInfo("配置验证", config.botUid, {
          userUID: config.uid,
          channel: config.channel,
        });

        if (role === "publisher") {
          agoraConfigCache = config;
        }
        return config;
      }

      function startMicMeter(track) {
        try {
          const streamTrack = track.getMediaStreamTrack();
          if (!streamTrack) {
            return;
          }
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(
            new MediaStream([streamTrack])
          );
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          micDataArray = new Uint8Array(bufferLength);
          source.connect(analyser);

          const update = () => {
            analyser.getByteTimeDomainData(micDataArray);
            let sum = 0;
            for (let i = 0; i < micDataArray.length; i += 1) {
              const value = micDataArray[i] - 128;
              sum += value * value;
            }
            const rms = Math.sqrt(sum / micDataArray.length);
            const level = Math.min(
              100,
              Math.max(0, Math.round((rms / 128) * 100))
            );
            elements.micLevel.textContent = `${level}%`;
            if (elements.micBar) {
              elements.micBar.style.width = `${level}%`;
            }
            meterAnimation = requestAnimationFrame(update);
          };
          update();
        } catch (error) {
          log("系统", `麦克风电平监控异常: ${error.message}`);
        }
      }

      function stopMicMeter() {
        if (meterAnimation) {
          cancelAnimationFrame(meterAnimation);
          meterAnimation = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        analyser = null;
        micDataArray = null;
        elements.micLevel.textContent = "0%";
        if (elements.micBar) {
          elements.micBar.style.width = "0%";
        }
      }

      // 竞争性单通道相关变量
      const CHANNEL = "solidchannel";
      const API_BASE_URL = "https://cityuantifraud.cn"; // 后端API基础URL
      let sessionId, token, uid, appId;
      let beatTimer;
      let remoteCheckTimer = null; // ✅ 新增：远端用户定时检查计时器（全局）
      let clientHandlers = {
        userUnpublished: null,
        userLeft: null,
        connectionStateChange: null,
      };
      async function leaveAndCleanup() {
        try {
          if (client && client.connectionState !== "DISCONNECTED") {
            await client.leave();
            log("声网", "已离开频道");
          }
        } catch(e) {
          console.error("离开频道失败:", e);
        }
        
        try {
          if (sessionId) {
            // sendBeacon 确保页面关闭时也能发出
            const leaveUrl = `${API_BASE_URL}/rtc/leave`;
            navigator.sendBeacon(leaveUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
            log("系统", "已释放房间锁");
          }
          
          // 关闭RTC系统（释放Agora资源）
          const shutdownUrl = `${API_BASE_URL}/api/rtc/shutdown`;
          navigator.sendBeacon(shutdownUrl, new Blob([JSON.stringify({})], {type:"application/json"}));
          log("系统", "已请求关闭RTC系统");
          
        } catch(e) {
          console.error("释放资源失败:", e);
        }
        
        clearInterval(beatTimer); 
        beatTimer = null;
        sessionId = token = uid = appId = null;
        
        // 清理音频轨道
        if (microphoneAudioTrack) {
          microphoneAudioTrack.close();
          microphoneAudioTrack = null;
        }
        // ✅ 退出时复位全局回调，避免二次进入页面出现异常行为
        try {
          AgoraRTC.onAutoplayFailed = null;
        } catch (_) {}

        // ✅ 统一清理远端检查定时器
        if (remoteCheckTimer) {
          clearInterval(remoteCheckTimer);
          remoteCheckTimer = null;
        }

        setConnectionState("offline", "已断开连接");
        elements.connectButton.disabled = false;
        isConnecting = false;
      }

      async function enterAndJoin() {
        if (isConnecting) {
          return;
        }
        isConnecting = true;
        setConnectionState("idle", "正在初始化RTC系统...");
        elements.connectButton.disabled = true;
        log("系统", "开始初始化RTC系统...");

        try {
          // 0) 先初始化RTC系统（按需启动Agora连接）
          const initUrl = `${API_BASE_URL}/api/rtc/init`;
          console.log("初始化RTC系统URL:", initUrl);
          const initResponse = await fetch(initUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({})
          });
          
          if (!initResponse.ok) {
            throw new Error(`RTC初始化失败 HTTP ${initResponse.status}: ${initResponse.statusText}`);
          }
          
          const initResult = await initResponse.json();
          if (!initResult.ok) {
            throw new Error(`RTC初始化失败: ${initResult.error}`);
          }
          
          log("系统", "✅ RTC系统初始化成功，正在申请进入房间...");
          setConnectionState("idle", "正在申请进入房间...");

          // 1) 申请进入（拿锁+拿token）
          const enterUrl = `${API_BASE_URL}/rtc/enter`;
          console.log("请求URL:", enterUrl);
          const response = await fetch(enterUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({ channel: CHANNEL })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const r = await response.json();

          if (!r.ok) {
            if (r.reason === "BUSY") {
              alert("当前线路正忙，请稍后再试。");
              log("系统", "房间被占用，无法进入", "error");
            } else {
              alert(`进入房间失败: ${r.reason}`);
              log("系统", `进入房间失败: ${r.reason}`, "error");
            }
            setConnectionState("offline", "进入房间失败");
            elements.connectButton.disabled = false;
            isConnecting = false;
            return;
          }

          sessionId = r.sessionId; 
          token = r.token; 
          uid = r.uid; 
          appId = r.appId;
          
          log("系统", `成功获取房间锁，会话ID: ${sessionId}`);
          elements.localUid.textContent = uid || "-";
          elements.channelName.textContent = CHANNEL;

          // 2) 心跳（10s一次）——断网/崩溃后 25s 自动释放
          beatTimer = setInterval(()=> {
            const beatUrl = `${API_BASE_URL}/rtc/beat`;
            navigator.sendBeacon(beatUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
          }, 10000);

          setConnectionState("idle", "正在加入声网频道...");
          
          if (client.connectionState !== "DISCONNECTED") {
            await client.leave().catch(() => {});
          }

          // 3) 加入频道
          await client.join(appId, CHANNEL, token, uid);
          log("声网", `已加入频道 ${CHANNEL}`);

          // 4) 初始化订阅管理器（监听Bot用户）
          const config = await fetchAgoraConfig("publisher"); // 获取botUid
          subscriptionManager = new WebSubscriptionManager(client, {
            maxRetryAttempts: 3,
            retryDelay: 2000,
            enableAutoSubscribe: true,
            logLevel: "info",
          });
          // 注意：WebSubscriptionManager不需要initialize方法，构造函数已完成初始化
          // subscriptionManager.setSubscriptionCallback(handleSubscription); // 此方法也不存在，使用回调属性代替

          subscriptionManager.onSubscriptionSuccess = (uid, mediaType, result) => {
            console.log(`[SUBSCRIPTION] ✅ 订阅成功: ${uid} (${mediaType})`);
            log("订阅", `成功订阅用户 ${uid} 的${mediaType === "audio" ? "音频" : "视频"}流`);

            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              console.log(`[SUBSCRIPTION] 🤖 Bot用户音频订阅成功，开始播放`);

              // 保存全局变量，方便 autoplayFailed 或断开时清理
              remoteAudioTrack = result || client.remoteUsers.find(u => String(u.uid) === String(uid))?.audioTrack;

              if (remoteAudioTrack) {
                try {
                  remoteAudioTrack.play("remoteAudio");
                  console.log("[SUBSCRIPTION] Bot音频已播放");
                } catch (err) {
                  console.warn("[SUBSCRIPTION] 播放失败，可能是 autoplay 限制:", err);
                }
              } else {
                console.error("[SUBSCRIPTION] 订阅成功但未获取到 audioTrack 对象");
              }
            }
          };







          subscriptionManager.onSubscriptionFailed = (
            uid,
            mediaType,
            error
          ) => {
            console.error(
              `[SUBSCRIPTION] ❌ 订阅失败: ${uid} (${mediaType})`,
              error
            );
            log(
              "订阅",
              `订阅用户 ${uid} 的${
                mediaType === "audio" ? "音频" : "视频"
              }流失败: ${error.message}`,
              "error"
            );
          };

          subscriptionManager.onSubscriptionStateChanged = (
            uid,
            mediaType,
            state
          ) => {
            console.log(
              `[SUBSCRIPTION] 🔄 订阅状态变化: ${uid} (${mediaType}) -> ${state}`
            );

            // 更新UI显示
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              const stateText =
                {
                  not_subscribed: "未订阅",
                  subscribing: "订阅中",
                  subscribed: "已订阅",
                  subscription_failed: "订阅失败",
                  unsubscribing: "取消订阅中",
                }[state] || state;

              elements.remoteUid.textContent = `Bot(${uid}) - ${stateText}`;
            }
          };

          console.log("[SUBSCRIPTION] 订阅管理器初始化完成，已设置回调函数");

          // [DEBUG] 检查当前远端用户
          console.log("[DEBUG] 当前远端用户:", client.remoteUsers);
          console.log("[DEBUG] 远端用户数量:", client.remoteUsers.length);
          client.remoteUsers.forEach((user) => {
            console.log("[DEBUG] 远端用户详情:", {
              uid: user.uid,
              hasAudio: user.hasAudio,
              hasVideo: user.hasVideo,
            });
          });

          // [AUDIO_FLOW] 检查麦克风权限和设备
          try {
            const devices = await AgoraRTC.getDevices();
            const audioInputs = devices.filter(
              (device) => device.kind === "audioinput"
            );
            console.log(
              "[AUDIO_FLOW] 可用音频输入设备:",
              audioInputs.map((d) => ({ id: d.deviceId, label: d.label }))
            );

            if (audioInputs.length === 0) {
              console.warn("[AUDIO_FLOW] 警告: 未检测到音频输入设备");
            }
          } catch (error) {
            console.error("[AUDIO_FLOW] 获取音频设备失败:", error);
          }

          console.log("[AUDIO_FLOW] 开始创建麦克风音频轨道...");
          microphoneAudioTrack = await AgoraRTC.createMicrophoneAudioTrack({
            encoderConfig: {
              sampleRate: 48000,
              stereo: false,
            },
          });
          localTrack = microphoneAudioTrack; // 保持兼容性

          // [AUDIO_FLOW] 音频轨道创建成功调试日志
          console.log("[AUDIO_FLOW] 麦克风音频轨道已创建:", {
            trackId: microphoneAudioTrack.getTrackId(),
            enabled: microphoneAudioTrack.enabled,
            muted: microphoneAudioTrack.muted,
            sampleRate: 48000,
          });

          await client.publish(microphoneAudioTrack);

          // [AUDIO_FLOW] 音频发布成功调试日志
          console.log("[AUDIO_FLOW] 本地音频已发布到声网:", {
            trackId: microphoneAudioTrack.getTrackId(),
            published: true,
            clientState: client.connectionState,
          });

          log("声网", "本地音频已发布");

          // [AUDIO_FLOW] 添加音频数据处理器监听音频流
          let audioFrameCounter = 0;
          try {
            const processor = {
              process: (audioBuffer) => {
                audioFrameCounter++;
                if (audioFrameCounter % 100 === 0) {
                  console.log(
                    "[AUDIO_FLOW] 音频数据流经声网SDK (第" +
                      audioFrameCounter +
                      "帧):",
                    {
                      sampleRate: audioBuffer.sampleRate,
                      numberOfChannels: audioBuffer.numberOfChannels,
                      length: audioBuffer.length,
                      timestamp: Date.now(),
                    }
                  );
                }
                return audioBuffer;
              },
            };

            if (localTrack.pipe && typeof localTrack.pipe === "function") {
              localTrack.pipe(processor);
              console.log("[AUDIO_FLOW] 音频处理器已添加到本地轨道");
            } else {
              console.log(
                "[AUDIO_FLOW] 本地轨道不支持pipe方法，尝试其他监听方式"
              );
            }
          } catch (error) {
            console.log("[AUDIO_FLOW] 添加音频处理器失败:", error.message);
          }

          startMicMeter(microphoneAudioTrack);

          // 处理 Autoplay 限制
          AgoraRTC.onAutoplayFailed = () => {
            console.warn("[WARN] Autoplay 被限制，创建恢复按钮");
            const btn = document.createElement("button");
            btn.innerText = "点击恢复 Bot 音频";
            btn.style.padding = "12px";
            btn.style.margin = "16px";
            btn.style.background = "#48bb78";
            btn.style.color = "#fff";
            btn.style.borderRadius = "8px";
            btn.onclick = () => {
              if (remoteAudioTrack) {
                remoteAudioTrack.play("remoteAudio");
                console.log("[DEBUG] 用户点击后恢复播放成功");
              }
              btn.remove();
            };
            document.body.appendChild(btn);
          };
          // [WELCOME] 前端触发欢迎语
          try {
            const resp = await fetch(`${API_BASE_URL}/api/rtc/welcome`, {
              method: "POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({})
            });
            const data = await resp.json();
            console.log("[WELCOME] 触发结果:", data);
            if (data.ok && data.welcome_sent) {
              log("系统", "欢迎语已触发");
            } else {
              console.warn("[WELCOME] 触发失败或未发送:", data);
            }
          } catch (err) {
            console.error("[WELCOME] 请求出错:", err);
          }


          // ?? 修复：在join之前注册事件监听，避免错过Bot的published事件
          console.log("[DEBUG] 在join前注册所有事件监听");

          // 成功 join 并完成其他准备后
          bindClientEvents();

          // --- 新增：加入后主动检查Bot用户并可能启动重试 ---
          if (subscriptionManager) {
            // 可以选择性地延迟一下，确保 SDK 状态更稳定，或者直接调用
            // setTimeout(() => {
              subscriptionManager.checkBotUsersForRetry();
            // }, 100); // 延迟 100ms，可选
          } else {
            console.warn("SubscriptionManager 未找到，无法检查Bot用户重试。");
          }
          // --- 新增结束 ---

          setConnectionState("online", "声网链路已建立，等待 Bot 音频...");
          elements.disconnectButton.disabled = false;
          log("系统", "连接完成，Bot 音频将自动播放");

          // ?? 添加：定时检查频道内的远端用户（增强版）
          if (remoteCheckTimer) { clearInterval(remoteCheckTimer); remoteCheckTimer = null; } // 避免重复
          remoteCheckTimer = setInterval(() => {
            const remoteUsers = client.remoteUsers;
            console.log("[CHECK] =========================");
            console.log("[CHECK] 频道内远端用户总数:", remoteUsers.length);

            if (remoteUsers.length === 0) {
              console.log("[CHECK] ?? 频道内无远端用户");
            } else {
              remoteUsers.forEach((user) => {
                console.log(`[CHECK] 用户 ${user.uid}:`, {
                  hasAudioTrack: !!user.audioTrack,
                  hasVideoTrack: !!user.videoTrack,
                  isPlaying: user.audioTrack?.isPlaying,
                  audioTrackType: typeof user.audioTrack,
                  audioTrackObject: user.audioTrack,
                });

                if (user.audioTrack) {
                  console.log(
                    `[CHECK] ? 用户 ${user.uid} 有音频轨道，播放状态: ${user.audioTrack.isPlaying}`
                  );
                } else {
                  console.log(`[CHECK] ? 用户 ${user.uid} 无音频轨道`);
                }

                // 特别检查Bot UID - 使用UID验证器
                if (WebUIDValidator.isBotUser(user.uid)) {
                  console.log(
                    `[CHECK] 🤖 检测到Bot用户 ${
                      user.uid
                    }! (类型: ${typeof user.uid})`
                  );
                  WebUIDValidator.logUIDInfo("Bot用户检测", user.uid, {
                    hasAudioTrack: !!user.audioTrack,
                    isPlaying: user.audioTrack?.isPlaying,
                  });
                  if (!user.audioTrack) {
                    console.log(
                      `[CHECK] ⚠️ Bot用户无音频轨道，可能需要手动订阅`
                    );
                  }
                }
              });
            }
            console.log("[CHECK] =========================");
          }, 5000); // 每5秒检查一次
        } catch (error) {
          log("错误", `连接失败: ${error.message}`, "error");
          await disconnect();
        } finally {
          isConnecting = false;
          if (!elements.disconnectButton.disabled) {
            elements.connectButton.disabled = true;
          } else {
            elements.connectButton.disabled = false;
          }
        }
      }
      function bindClientEvents() {
        // 先防御性解绑（避免极端情况下重复绑定）
        unbindClientEvents();

        clientHandlers.userUnpublished = (user, mediaType) => {
          console.log("[EVENT] user-unpublished:", user.uid, mediaType);
          elements.remoteUid.textContent = "-";
          log("取消发布", `UID ${user.uid} 取消发布音频`);
        };

        clientHandlers.userLeft = (user) => {
          console.log("[EVENT] user-left:", user.uid);
          elements.remoteUid.textContent = "-";
          log("离开", `UID ${user.uid} 已离开`);
        };

        clientHandlers.connectionStateChange = (cur, prev, reason) => {
          log("声网", `连接状态: ${prev} -> ${cur} (${reason})`);
        };

        client.on("user-unpublished", clientHandlers.userUnpublished);
        client.on("user-left", clientHandlers.userLeft);
        client.on("connection-state-change", clientHandlers.connectionStateChange);
      }

      function unbindClientEvents() {
        if (clientHandlers.connectionStateChange) {
          client.off("connection-state-change", clientHandlers.connectionStateChange);
        }
        if (clientHandlers.userUnpublished) {
          client.off("user-unpublished", clientHandlers.userUnpublished);
        }
        if (clientHandlers.userLeft) {
          client.off("user-left", clientHandlers.userLeft);
        }
        // 可选：重置为 null，避免误用旧指针
        clientHandlers = {
          userUnpublished: null,
          userLeft: null,
          connectionStateChange: null,
        };
      }
      async function disconnect() {
        elements.disconnectButton.disabled = true;
        
        try {

          // ① 先解绑所有 client 事件（对称）
          unbindClientEvents();
             // （可留着你的这行，等价防御）
          // client.off("connection-state-change");
          
         // ② 关远端/本地轨道
          if (remoteAudioTrack) {
            remoteAudioTrack.stop();
            remoteAudioTrack.close();
            remoteAudioTrack = null;
          }

          if (localTrack) {
            localTrack.stop();
            localTrack.close();
            localTrack = null;
          }
          // ③ 停止电平动画
          stopMicMeter();

           // ✅ 统一清理远端检查定时器
          if (remoteCheckTimer) {
            clearInterval(remoteCheckTimer);
            remoteCheckTimer = null;
          }
          // ✅ 退出时复位全局回调，避免二次进入页面出现异常行为
          try {
            AgoraRTC.onAutoplayFailed = null;
          } catch (_) {}

          // 清理订阅管理器
          if (subscriptionManager) {
            subscriptionManager.destroy();
            subscriptionManager = null;
            console.log("[SUBSCRIPTION] 订阅管理器已清理");
          }
         

          // 调用统一的清理函数（包含房间锁释放）
          await leaveAndCleanup();
        } catch (error) {
          log("错误", `断开连接出现问题: ${error.message}`);
          // 即使出错也要尝试清理
          await leaveAndCleanup();
        }
      }

      
    
      elements.connectButton.addEventListener("click", enterAndJoin);
      elements.disconnectButton.addEventListener("click", disconnect);

      elements.volumeSlider.addEventListener("input", (event) => {
        const volume = Number(event.target.value || "70");
        elements.remoteVolume.textContent = `${volume}%`;
        if (remoteAudioTrack) {
          remoteAudioTrack.setVolume(volume);
        }
      });

      // —— 挂到所有退出路径 ——
      // 1) 关闭/刷新
      window.addEventListener("beforeunload", leaveAndCleanup);
      window.addEventListener("pagehide", leaveAndCleanup);     // iOS Safari
      // 2) 页面可见性变化（可选：后台停播，前台再播）
      window.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          console.log("[DEBUG] 页面进入后台");
          // 可选：暂停某些操作
        } else {
          console.log("[DEBUG] 页面回到前台");
          // 可选：恢复某些操作
        }
      });

      log("系统", "页面加载完成，点击按钮即可体验声网 RTC 链路。");
    </script>
  </body>
</html>
