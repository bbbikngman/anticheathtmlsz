<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å£°ç½‘ RTC åŒå·¥å¯¹è¯å®¢æˆ·ç«¯</title>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.0.js"></script>
    <script src="web_uid_validator.js"></script>
    <script src="web_subscription_manager.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #5a67d8 0%, #805ad5 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #1a202c;
        padding: 24px;
      }

      .container {
        width: 100%;
        max-width: 900px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 20px;
        padding: 32px;
        box-shadow: 0 20px 60px rgba(67, 56, 202, 0.18);
      }

      header {
        text-align: center;
        margin-bottom: 24px;
      }

      header h1 {
        font-size: 2.2rem;
        color: #2d3748;
        margin-bottom: 8px;
      }

      header p {
        color: #4a5568;
      }

      .status-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }

      .status-card {
        background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        border-radius: 14px;
        padding: 18px;
        border: 1px solid #cbd5f5;
      }

      .status-card h2 {
        font-size: 1rem;
        color: #2b6cb0;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .status-value {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .status-value.online {
        color: #2f855a;
      }

      .status-value.offline {
        color: #c53030;
      }

      .status-value.idle {
        color: #b7791f;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-bottom: 24px;
        justify-content: center;
      }

      button {
        padding: 12px 28px;
        border: none;
        border-radius: 999px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: #fff;
      }

      button.primary {
        background: linear-gradient(135deg, #48bb78, #38a169);
      }

      button.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button.danger {
        background: linear-gradient(135deg, #f56565, #e53e3e);
      }

      button.danger:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      /* ä¸€ä¸ªæ²¡ç”¨çš„æ³¨é‡Šï¼Œè§¦å‘é‡å¯ */
      .meter {
        background: #edf2f7;
        border-radius: 14px;
        padding: 12px 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.95rem;
        color: #4a5568;
      }

      .meter span {
        font-weight: 600;
        color: #2d3748;
      }

      .meter-bar {
        margin-top: 8px;
        width: 180px;
        height: 10px;
        background: #e2e8f0;
        border-radius: 999px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #63b3ed, #3182ce);
        transition: width 0.1s ease;
      }

      .conversation-log {
        background: #f7fafc;
        border-radius: 14px;
        border: 1px solid #e2e8f0;
        padding: 18px;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-entry {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px dashed rgba(160, 174, 192, 0.5);
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry time {
        display: block;
        font-size: 0.8rem;
        color: #718096;
        margin-bottom: 4px;
      }

      .log-entry strong {
        display: inline-block;
        min-width: 70px;
        color: #2b6cb0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 12px;
        justify-content: center;
        margin-top: 8px;
      }

      .volume-control label {
        font-weight: 600;
        color: #2d3748;
      }

      .volume-control input {
        width: 220px;
      }

      .conversation-log {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        margin: 24px 0;
        max-height: 300px;
        overflow-y: auto;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 0.9rem;
      }

      .log-entry {
        margin-bottom: 8px;
        padding: 8px;
        border-radius: 6px;
        background: white;
        border-left: 4px solid #cbd5e0;
      }

      .log-entry.stt {
        border-left-color: #4299e1;
        background: #ebf8ff;
      }

      .log-entry.llm {
        border-left-color: #48bb78;
        background: #f0fff4;
      }

      .log-entry.error {
        border-left-color: #f56565;
        background: #fed7d7;
        color: #c53030;
      }

      .log-entry time {
        font-size: 0.8rem;
        color: #718096;
        margin-right: 8px;
      }

      .log-entry .source {
        font-weight: 600;
        margin-right: 8px;
      }

      .log-entry .source.stt {
        color: #2b6cb0;
      }

      .log-entry .source.llm {
        color: #2f855a;
      }

      .log-entry .source.error {
        color: #c53030;
      }

      .error-popup {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #fed7d7;
        border: 1px solid #feb2b2;
        border-radius: 8px;
        padding: 16px;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
      }

      .error-popup .error-title {
        font-weight: 600;
        color: #c53030;
        margin-bottom: 8px;
      }

      .error-popup .error-message {
        color: #742a2a;
        font-size: 0.9rem;
      }

      .error-popup .close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 1.2rem;
        color: #c53030;
        cursor: pointer;
        padding: 4px;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .websocket-status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .websocket-status.connected {
        background: #48bb78;
      }

      .websocket-status.disconnected {
        background: #f56565;
      }

      .websocket-status.connecting {
        background: #ed8936;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      footer {
        margin-top: 24px;
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
      }

      footer code {
        background: #edf2f7;
        padding: 2px 6px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>å£°ç½‘ RTC åŒå·¥å¯¹è¯å®¢æˆ·ç«¯</h1>
        <p>æµè§ˆå™¨ç›´æ¥åŠ å…¥å£°ç½‘é¢‘é“ï¼Œä¸Šè¡Œéº¦å…‹é£ã€ä¸‹è¡Œ Bot éŸ³é¢‘</p>
      </header>

      <section class="status-panel">
        <div class="status-card">
          <h2>è¿æ¥çŠ¶æ€</h2>
          <div id="connectionStatus" class="status-value offline">æœªè¿æ¥</div>
          <p id="statusHint">ç‚¹å‡»å¼€å§‹å¯¹è¯å³å¯è¿æ¥å£°ç½‘</p>
        </div>
        <div class="status-card">
          <h2>é¢‘é“ä¿¡æ¯</h2>
          <div class="status-value">
            <div>é¢‘é“ï¼š<span id="channelName">-</span></div>
            <div>æœ¬åœ° UIDï¼š<span id="localUid">-</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>Bot çŠ¶æ€</h2>
          <div class="status-value">
            <div>è¿œç«¯ UIDï¼š<span id="remoteUid">-</span></div>
            <div>éŸ³é‡ï¼š<span id="remoteVolume">70%</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>è°ƒè¯•è¿æ¥</h2>
          <div class="status-value">
            <div><span class="websocket-status disconnected" id="wsStatus"></span>WebSocketï¼š<span id="wsStatusText">æœªè¿æ¥</span></div>
            <div>æ¶ˆæ¯æ•°ï¼š<span id="wsMessageCount">0</span></div>
          </div>
        </div>
      </section>

      <section class="controls">
        <button id="connectButton" class="primary">å¼€å§‹å¯¹è¯</button>
        <button id="disconnectButton" class="danger" disabled>æ–­å¼€è¿æ¥</button>
      </section>

      <section class="meter">
        <div>
          <span>éº¦å…‹é£ç”µå¹³</span>
          <div class="meter-bar">
            <div id="micBar" class="meter-fill"></div>
          </div>
        </div>
        <div>
          <span id="micLevel">0%</span>
        </div>
      </section>

      <div class="volume-control">
        <label for="volumeSlider">Bot éŸ³é‡</label>
        <input id="volumeSlider" type="range" min="0" max="100" value="70" />
      </div>



      <section class="conversation-log" id="logContainer"></section>

      <div id="remoteAudio"></div>

      <footer>
        <div>
          è°ƒè¯•å‘½ä»¤ï¼š<code
            >curl https://cityuantifraud.cn/api/agora/config</code
          >
        </div>
      </footer>
    </div>

    <script>
      const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
      let localTrack = null;
      let microphoneAudioTrack = null; // æ·»åŠ ç¼ºå¤±çš„å˜é‡å®šä¹‰
      let remoteAudioTrack = null;
      let agoraConfigCache = null;
      const backendBaseUrl = "https://cityuantifraud.cn";
      let isConnecting = false;
      let subscriptionManager = null;
      let audioContext = null;
      let analyser = null;
      let micDataArray = null;
      let meterAnimation = null;

      // WebSocketç›¸å…³å˜é‡
      let debugWebSocket = null;
      let wsReconnectTimer = null;
      let wsMessageCount = 0;
      let wsReconnectAttempts = 0;
      const WS_MAX_RECONNECT_ATTEMPTS = 5;
      const WS_RECONNECT_DELAY = 3000;
      
      // === ç»Ÿä¸€å»é‡ï¼š2s TTL ===
      const DEDUP_TTL_MS = 2000;           // â˜… 2 ç§’ TTL
      const lastSeenMap = new Map();       // hash -> ts
      
      const elements = {
        connectionStatus: document.getElementById("connectionStatus"),
        statusHint: document.getElementById("statusHint"),
        channelName: document.getElementById("channelName"),
        localUid: document.getElementById("localUid"),
        remoteUid: document.getElementById("remoteUid"),
        remoteVolume: document.getElementById("remoteVolume"),
        connectButton: document.getElementById("connectButton"),
        disconnectButton: document.getElementById("disconnectButton"),
        volumeSlider: document.getElementById("volumeSlider"),
        micLevel: document.getElementById("micLevel"),
        micBar: document.getElementById("micBar"),
        logContainer: document.getElementById("logContainer"),
        wsStatus: document.getElementById("wsStatus"),
        wsStatusText: document.getElementById("wsStatusText"),
        wsMessageCount: document.getElementById("wsMessageCount"),
      };

      // ç®€å•çš„å­—ç¬¦ä¸²hashå‡½æ•°
      function simpleHash(str) {
        let hash = 0;
        if (str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
        }
        return hash.toString();
      }

      function normalizeForHash(s) {
        return (s || '').replace(/\s+/g, ' ').trim(); // åˆå¹¶ç©ºç™½ï¼Œé¿å…æ— æ„ä¹‰å·®å¼‚
      }

      function shouldDedup(source, message, type) {
        const keyType = (type || source || 'info').toString().toLowerCase();
        const hash = simpleHash(`${keyType}|${normalizeForHash(message)}`);
        const now = Date.now();
        const prev = lastSeenMap.get(hash) || 0;

        if (now - prev < DEDUP_TTL_MS) {
          console.log(`[å»é‡] ${keyType} åœ¨ ${now - prev}ms å†…é‡å¤ï¼Œè·³è¿‡: "${(message || '').slice(0,50)}..."`);
          return true;
        }
        lastSeenMap.set(hash, now);
        return false;
      }

      // å®šæœŸæ¸…ç†è¿‡æœŸçš„hashè®°å½•ï¼Œé˜²æ­¢Mapè†¨èƒ€
      setInterval(() => {
        const now = Date.now();
        for (const [k, ts] of lastSeenMap.entries()) {
          if (now - ts > 60000) lastSeenMap.delete(k);
        }
      }, 30000);

      function log(source, message, type = "info") {
        // ç»Ÿä¸€ 2 ç§’ TTL å»é‡
        if (shouldDedup(source, message, type)) return;
        
        const entry = document.createElement("div");
        entry.className = "log-entry";
        const timestamp = new Date().toLocaleTimeString();
        
        // æ ¹æ®æ¶ˆæ¯ç±»å‹è®¾ç½®æ ·å¼
        if (type === "stt" || source === "STT") {
          entry.classList.add("stt");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source stt">è¯­éŸ³è¯†åˆ«</span>
            <div>${message}</div>
          `;
        } else if (type === "llm" || source === "LLM") {
          entry.classList.add("llm");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source llm">AIå›å¤</span>
            <div>${message}</div>
          `;
        } else if (type === "error") {
          entry.classList.add("error");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source error">${source}</span>
            <div>${message}</div>
          `;
        } else {
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source">${source}</span>
            <div>${message}</div>
          `;
          if (type === "success") {
            entry.style.color = "#2f855a";
          }
        }
        
        elements.logContainer.appendChild(entry);
        elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
      }

      function setConnectionState(state, hint) {
        elements.connectionStatus.classList.remove("online", "offline", "idle");
        elements.connectionStatus.classList.add(state);
        elements.connectionStatus.textContent =
          state === "online"
            ? "å·²è¿æ¥"
            : state === "offline"
            ? "æœªè¿æ¥"
            : "å‡†å¤‡ä¸­";
        if (hint) {
          elements.statusHint.textContent = hint;
        }
      }

      // WebSocketçŠ¶æ€æ›´æ–°å‡½æ•°
      function updateWebSocketStatus(status, text) {
        elements.wsStatus.className = `websocket-status ${status}`;
        elements.wsStatusText.textContent = text;
      }

      // æ˜¾ç¤ºé”™è¯¯å¼¹çª—
      function showErrorPopup(title, message) {
        // ç§»é™¤å·²å­˜åœ¨çš„é”™è¯¯å¼¹çª—
        const existingPopup = document.querySelector('.error-popup');
        if (existingPopup) {
          existingPopup.remove();
        }

        const popup = document.createElement('div');
        popup.className = 'error-popup';
        popup.innerHTML = `
          <button class="close-btn" onclick="this.parentElement.remove()">Ã—</button>
          <div class="error-title">${title}</div>
          <div class="error-message">${message}</div>
        `;
        
        document.body.appendChild(popup);
        
        // 5ç§’åè‡ªåŠ¨å…³é—­
        setTimeout(() => {
          if (popup.parentElement) {
            popup.remove();
          }
        }, 5000);
      }

      // æ’­æ”¾é¢„å½•åˆ¶éŸ³é¢‘æ–‡ä»¶
      function playPrerecordedAudio(audioFilePath, audioData) {
        try {
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] å¼€å§‹æ’­æ”¾:', audioFilePath, audioData);
          log('ç³»ç»Ÿ', `æ’­æ”¾é¢„å½•åˆ¶éŸ³é¢‘: ${audioData.text || 'æœªçŸ¥æ–‡æœ¬'}`, 'success');
          
          // æ„å»ºéŸ³é¢‘æ–‡ä»¶çš„å®Œæ•´URL
          // audioFilePath ç°åœ¨å·²ç»åŒ…å«å®Œæ•´çš„ç›¸å¯¹è·¯å¾„ (prerecorded_audio/audio_files/hash.mp3)
          const audioUrl = `${API_BASE_URL}/${audioFilePath}`;
          console.log('[é¢„å½•åˆ¶éŸ³é¢‘] éŸ³é¢‘URL:', audioUrl);
          
          // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
          const audioElement = new Audio(audioUrl);
          
          // è®¾ç½®éŸ³é¢‘äº‹ä»¶ç›‘å¬å™¨
          audioElement.onloadstart = () => {
            console.log('[é¢„å½•åˆ¶éŸ³é¢‘] å¼€å§‹åŠ è½½éŸ³é¢‘æ–‡ä»¶');
          };
          
          audioElement.oncanplay = () => {
            console.log('[é¢„å½•åˆ¶éŸ³é¢‘] éŸ³é¢‘æ–‡ä»¶å¯ä»¥æ’­æ”¾');
          };
          
          audioElement.onplay = () => {
            console.log('[é¢„å½•åˆ¶éŸ³é¢‘] éŸ³é¢‘å¼€å§‹æ’­æ”¾');
            log('ç³»ç»Ÿ', 'é¢„å½•åˆ¶éŸ³é¢‘å¼€å§‹æ’­æ”¾', 'success');
          };
          
          audioElement.onended = () => {
            console.log('[é¢„å½•åˆ¶éŸ³é¢‘] éŸ³é¢‘æ’­æ”¾å®Œæˆ');
            log('ç³»ç»Ÿ', 'é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾å®Œæˆ', 'success');
          };
          
          audioElement.onerror = (error) => {
            console.error('[é¢„å½•åˆ¶éŸ³é¢‘] æ’­æ”¾å¤±è´¥:', error);
            log('ç³»ç»Ÿ', `é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
          };
          
          // å¼€å§‹æ’­æ”¾
          audioElement.play().catch(error => {
            console.error('[é¢„å½•åˆ¶éŸ³é¢‘] æ’­æ”¾å¯åŠ¨å¤±è´¥:', error);
            log('ç³»ç»Ÿ', `é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾å¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
          });
          
        } catch (error) {
          console.error('[é¢„å½•åˆ¶éŸ³é¢‘] æ’­æ”¾å‡½æ•°æ‰§è¡Œå¤±è´¥:', error);
          log('ç³»ç»Ÿ', `é¢„å½•åˆ¶éŸ³é¢‘æ’­æ”¾å‡½æ•°æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
        }
      }

      // è§£æWebSocketè°ƒè¯•æ¶ˆæ¯
      function parseDebugMessage(message) {
        try {
          // å°è¯•è§£æJSONæ ¼å¼çš„æ¶ˆæ¯
          const jsonMessage = JSON.parse(message);
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯é¢„å½•åˆ¶éŸ³é¢‘ä¿¡å·
          if (jsonMessage.type === 'prerecorded_audio' && jsonMessage.data) {
            const audioData = jsonMessage.data;
            console.log('[WebSocket] æ”¶åˆ°é¢„å½•åˆ¶éŸ³é¢‘ä¿¡å·:', audioData);
            
            // æ’­æ”¾é¢„å½•åˆ¶éŸ³é¢‘æ–‡ä»¶
            if (audioData.audio_file_path) {
              playPrerecordedAudio(audioData.audio_file_path, audioData);
            }
            
            return {
              type: 'llm',
              content: audioData.text || 'æ’­æ”¾é¢„å½•åˆ¶éŸ³é¢‘'
            };
          }
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„assistant_textæ¶ˆæ¯æ ¼å¼ï¼ˆä¼˜å…ˆå¤„ç†ï¼‰
          if (jsonMessage.type === 'assistant_text' && jsonMessage.data && jsonMessage.data.text) {
            const text = jsonMessage.data.text.trim();
            const kind = jsonMessage.data.kind || 'llm';
            return {
              type: (kind === 'stt') ? 'stt' : 'llm',
              content: text
            };
          }
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯æ—§çš„è°ƒè¯•æ¶ˆæ¯æ ¼å¼
          if (jsonMessage.type === 'debug' && jsonMessage.data && jsonMessage.data.message) {
            const debugText = jsonMessage.data.message.trim();
            console.log('[WebSocket] è§£æJSONè°ƒè¯•æ¶ˆæ¯:', debugText);
            
            // è§£æè°ƒè¯•æ¶ˆæ¯å†…å®¹
            if (debugText.startsWith('[LLM_DEBUG]')) {
              return {
                type: 'llm',
                content: debugText.replace('[LLM_DEBUG]', '').trim()
              };
            } else if (debugText.startsWith('[STT_DEBUG]')) {
              return {
                type: 'stt',
                content: debugText.replace('[STT_DEBUG]', '').trim()
              };
            } else if (debugText.startsWith('[WELCOME]')) {
              return {
                type: 'llm',
                content: debugText.replace('[WELCOME]', '').trim()
              };
            } else if (debugText.includes('ERROR')) {
              // åŒ¹é…å„ç§é”™è¯¯ç±»å‹
              const errorTypes = ['VAD_ERROR', 'STT_ERROR', 'LLM_ERROR', 'TTS_ERROR'];
              for (const errorType of errorTypes) {
                if (debugText.includes(`[${errorType}]`)) {
                  return {
                    type: 'error',
                    source: errorType.replace('_ERROR', ''),
                    content: debugText.replace(`[${errorType}]`, '').trim()
                  };
                }
              }
              return {
                type: 'error',
                source: 'ç³»ç»Ÿ',
                content: debugText
              };
            } else {
              return {
                type: 'info',
                content: debugText
              };
            }
          }
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯pingæ¶ˆæ¯
          if (jsonMessage.type === 'ping') {
            return {
              type: 'ping',
              content: 'ping'
            };
          }
          
          // å¤„ç†å…¶ä»–ç±»å‹çš„JSONæ¶ˆæ¯
          return {
            type: 'info',
            content: `æ”¶åˆ°JSONæ¶ˆæ¯: ${jsonMessage.type || 'æœªçŸ¥ç±»å‹'}`
          };
          
        } catch (e) {
          // å¦‚æœä¸æ˜¯JSONï¼ŒæŒ‰åŸæ¥çš„æ–‡æœ¬æ ¼å¼å¤„ç†
          const text = message.trim();
          console.log('[WebSocket] è§£ææ–‡æœ¬è°ƒè¯•æ¶ˆæ¯:', text);
          
          // åŒ¹é…ä¸åŒç±»å‹çš„è°ƒè¯•æ¶ˆæ¯
          if (text.startsWith('[LLM_DEBUG]')) {
            return {
              type: 'llm',
              content: text.replace('[LLM_DEBUG]', '').trim()
            };
          } else if (text.startsWith('[STT_DEBUG]')) {
            return {
              type: 'stt',
              content: text.replace('[STT_DEBUG]', '').trim()
            };
          } else if (text.startsWith('[WELCOME]')) {
            return {
              type: 'llm',
              content: text.replace('[WELCOME]', '').trim()
            };
          } else if (text.includes('ERROR')) {
            // åŒ¹é…å„ç§é”™è¯¯ç±»å‹
            const errorTypes = ['VAD_ERROR', 'STT_ERROR', 'LLM_ERROR', 'TTS_ERROR'];
            for (const errorType of errorTypes) {
              if (text.includes(`[${errorType}]`)) {
                return {
                  type: 'error',
                  source: errorType.replace('_ERROR', ''),
                  content: text.replace(`[${errorType}]`, '').trim()
                };
              }
            }
            return {
              type: 'error',
              source: 'ç³»ç»Ÿ',
              content: text
            };
          } else {
            return {
              type: 'info',
              content: text
            };
          }
        }
      }

      // è¿æ¥WebSocket
      function connectWebSocket() {
        if (debugWebSocket && debugWebSocket.readyState === WebSocket.OPEN) {
          return; // å·²ç»è¿æ¥
        }

        updateWebSocketStatus('connecting', 'è¿æ¥ä¸­...');
        
        try {
          // ç›´æ¥å›ºå®šæˆåŸŸå + /wsï¼ˆç”± Nginx è´Ÿè´£ TLS å’Œåä»£ï¼‰
          const wsUrl = 'wss://cityuantifraud.cn/ws';
          
          console.log(`[WebSocket] å°è¯•è¿æ¥: ${wsUrl}`);
          debugWebSocket = new WebSocket(wsUrl);
          
          debugWebSocket.onopen = function(event) {
            console.log('[WebSocket] è¿æ¥æˆåŠŸ');
            updateWebSocketStatus('connected', 'å·²è¿æ¥');
            wsReconnectAttempts = 0;
            log('WebSocket', 'è°ƒè¯•è¿æ¥å·²å»ºç«‹', 'success');
            
            // å‘é€bindæ¶ˆæ¯ä»¥ç»‘å®šå®¢æˆ·ç«¯ï¼ˆæ‰å¹³JSONæ ¼å¼ï¼‰
            try {
              const bindMessage = JSON.stringify({
                type: 'bind',
                client_id: 'web_console',
                client_type: 'web_client'
              });
              debugWebSocket.send(bindMessage);
              console.log('[WebSocket] å·²å‘é€bindæ¶ˆæ¯:', bindMessage);
            } catch (error) {
              console.error('[WebSocket] å‘é€bindæ¶ˆæ¯å¤±è´¥:', error);
            }
          };
          
          debugWebSocket.onmessage = function(event) {
            wsMessageCount++;
            elements.wsMessageCount.textContent = wsMessageCount;
            
            // æ·»åŠ è¯¦ç»†çš„WebSocketæ¶ˆæ¯æ¥æ”¶æ—¥å¿—
            console.log('[WebSocket] æ”¶åˆ°æ¶ˆæ¯:', event.data);
            console.log('[WebSocket] æ¶ˆæ¯è®¡æ•°:', wsMessageCount);
            
            try {
              const parsed = parseDebugMessage(event.data);
              console.log('[WebSocket] è§£æåçš„æ¶ˆæ¯:', parsed);
              
              if (parsed.type === 'ping') {
                // å“åº”pingæ¶ˆæ¯ï¼Œå‘é€pong
                try {
                  const pongMessage = JSON.stringify({
                    type: 'pong',
                    data: {}
                  });
                  debugWebSocket.send(pongMessage);
                  console.log('[WebSocket] ğŸ’“ æ”¶åˆ°pingï¼Œå·²å‘é€pongå“åº”');
                } catch (error) {
                  console.error('[WebSocket] å‘é€pongå“åº”å¤±è´¥:', error);
                }
              } else if (parsed.type === 'stt') {
                log('STT', parsed.content, 'stt');
                console.log('[WebSocket] STTæ¶ˆæ¯å·²å¤„ç†:', parsed.content);
              } else if (parsed.type === 'llm') {
                log('LLM', parsed.content, 'llm');
                console.log('[WebSocket] LLMæ¶ˆæ¯å·²å¤„ç†:', parsed.content);
              } else if (parsed.type === 'error') {
                log(parsed.source, parsed.content, 'error');
                showErrorPopup(`${parsed.source}é”™è¯¯`, parsed.content);
                console.log('[WebSocket] é”™è¯¯æ¶ˆæ¯å·²å¤„ç†:', parsed.source, parsed.content);
              } else {
                log('è°ƒè¯•', parsed.content);
                console.log('[WebSocket] è°ƒè¯•æ¶ˆæ¯å·²å¤„ç†:', parsed.content);
              }
            } catch (error) {
              console.error('[WebSocket] æ¶ˆæ¯è§£æå¤±è´¥:', error, 'åŸå§‹æ¶ˆæ¯:', event.data);
              log('WebSocket', `æ¶ˆæ¯è§£æå¤±è´¥: ${error.message}`, 'error');
            }
          };
          
          debugWebSocket.onclose = function(event) {
            console.log('[WebSocket] è¿æ¥å…³é—­:', event.code, event.reason);
            updateWebSocketStatus('disconnected', 'å·²æ–­å¼€');
            
            // è‡ªåŠ¨é‡è¿é€»è¾‘
            if (wsReconnectAttempts < WS_MAX_RECONNECT_ATTEMPTS) {
              wsReconnectAttempts++;
              log('WebSocket', `è¿æ¥æ–­å¼€ï¼Œ${WS_RECONNECT_DELAY/1000}ç§’åå°è¯•é‡è¿ (${wsReconnectAttempts}/${WS_MAX_RECONNECT_ATTEMPTS})`);
              
              wsReconnectTimer = setTimeout(() => {
                connectWebSocket();
              }, WS_RECONNECT_DELAY);
            } else {
              log('WebSocket', 'é‡è¿æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°é¡µé¢', 'error');
            }
          };
          
          debugWebSocket.onerror = function(error) {
            console.error('[WebSocket] è¿æ¥é”™è¯¯:', error);
            updateWebSocketStatus('disconnected', 'è¿æ¥å¤±è´¥');
            log('WebSocket', 'è¿æ¥å‡ºç°é”™è¯¯', 'error');
          };
          
        } catch (error) {
          console.error('[WebSocket] åˆ›å»ºè¿æ¥å¤±è´¥:', error);
          updateWebSocketStatus('disconnected', 'åˆ›å»ºå¤±è´¥');
          log('WebSocket', `åˆ›å»ºè¿æ¥å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // æ–­å¼€WebSocketè¿æ¥
      function disconnectWebSocket() {
        if (wsReconnectTimer) {
          clearTimeout(wsReconnectTimer);
          wsReconnectTimer = null;
        }
        
        if (debugWebSocket) {
          debugWebSocket.close();
          debugWebSocket = null;
        }
        
        updateWebSocketStatus('disconnected', 'æœªè¿æ¥');
        wsReconnectAttempts = 0;
      }

      async function fetchAgoraConfig(role = "publisher") {
        if (role === "publisher" && agoraConfigCache) {
          return agoraConfigCache;
        }
        const url = new URL("/api/agora/config", backendBaseUrl);
        url.searchParams.set("role", role);
        const response = await fetch(url.toString(), {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          throw new Error(`åç«¯æ¥å£è¿”å› ${response.status}`);
        }
        const config = await response.json();
        if (!config || !config.appId) {
          throw new Error("åç«¯ç¼ºå°‘å£°ç½‘ App ID");
        }

        // UIDé…ç½®éªŒè¯
        const validationResult = WebUIDValidator.validateConfiguration(config);
        if (!validationResult.isValid) {
          console.error("[CONFIG] UIDé…ç½®éªŒè¯å¤±è´¥:", validationResult.errors);
          throw new Error(`UIDé…ç½®æ— æ•ˆ: ${validationResult.errors.join(", ")}`);
        }

        if (validationResult.warnings.length > 0) {
          console.warn("[CONFIG] UIDé…ç½®è­¦å‘Š:", validationResult.warnings);
        }

        // è®°å½•UIDä¿¡æ¯
        WebUIDValidator.logUIDInfo("é…ç½®éªŒè¯", config.botUid, {
          userUID: config.uid,
          channel: config.channel,
        });

        if (role === "publisher") {
          agoraConfigCache = config;
        }
        return config;
      }

      function startMicMeter(track) {
        try {
          const streamTrack = track.getMediaStreamTrack();
          if (!streamTrack) {
            return;
          }
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(
            new MediaStream([streamTrack])
          );
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          micDataArray = new Uint8Array(bufferLength);
          source.connect(analyser);

          const update = () => {
            analyser.getByteTimeDomainData(micDataArray);
            let sum = 0;
            for (let i = 0; i < micDataArray.length; i += 1) {
              const value = micDataArray[i] - 128;
              sum += value * value;
            }
            const rms = Math.sqrt(sum / micDataArray.length);
            const level = Math.min(
              100,
              Math.max(0, Math.round((rms / 128) * 100))
            );
            elements.micLevel.textContent = `${level}%`;
            if (elements.micBar) {
              elements.micBar.style.width = `${level}%`;
            }
            meterAnimation = requestAnimationFrame(update);
          };
          update();
        } catch (error) {
          log("ç³»ç»Ÿ", `éº¦å…‹é£ç”µå¹³ç›‘æ§å¼‚å¸¸: ${error.message}`);
        }
      }

      function stopMicMeter() {
        if (meterAnimation) {
          cancelAnimationFrame(meterAnimation);
          meterAnimation = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        analyser = null;
        micDataArray = null;
        elements.micLevel.textContent = "0%";
        if (elements.micBar) {
          elements.micBar.style.width = "0%";
        }
      }

      // ç«äº‰æ€§å•é€šé“ç›¸å…³å˜é‡
      const CHANNEL = "solidchannel";
      const API_BASE_URL = "https://cityuantifraud.cn"; // åç«¯APIåŸºç¡€URL
      let sessionId, token, uid, appId;
      let beatTimer;
      let remoteCheckTimer = null; // âœ… æ–°å¢ï¼šè¿œç«¯ç”¨æˆ·å®šæ—¶æ£€æŸ¥è®¡æ—¶å™¨ï¼ˆå…¨å±€ï¼‰
      let clientHandlers = {
        userUnpublished: null,
        userLeft: null,
        connectionStateChange: null,
      };
      async function leaveAndCleanup() {
        try {
          if (client && client.connectionState !== "DISCONNECTED") {
            await client.leave();
            log("å£°ç½‘", "å·²ç¦»å¼€é¢‘é“");
          }
        } catch(e) {
          console.error("ç¦»å¼€é¢‘é“å¤±è´¥:", e);
        }
        
        try {
          if (sessionId) {
            // sendBeacon ç¡®ä¿é¡µé¢å…³é—­æ—¶ä¹Ÿèƒ½å‘å‡º
            const leaveUrl = `${API_BASE_URL}/rtc/leave`;
            navigator.sendBeacon(leaveUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
            log("ç³»ç»Ÿ", "å·²é‡Šæ”¾æˆ¿é—´é”");
          }
          
          // å…³é—­RTCç³»ç»Ÿï¼ˆé‡Šæ”¾Agoraèµ„æºï¼‰
          const shutdownUrl = `${API_BASE_URL}/api/rtc/shutdown`;
          navigator.sendBeacon(shutdownUrl, new Blob([JSON.stringify({})], {type:"application/json"}));
          log("ç³»ç»Ÿ", "å·²è¯·æ±‚å…³é—­RTCç³»ç»Ÿ");
          
        } catch(e) {
          console.error("é‡Šæ”¾èµ„æºå¤±è´¥:", e);
        }
        
        clearInterval(beatTimer); 
        beatTimer = null;
        sessionId = token = uid = appId = null;
        
        // æ¸…ç†éŸ³é¢‘è½¨é“
        if (microphoneAudioTrack) {
          microphoneAudioTrack.close();
          microphoneAudioTrack = null;
        }
        // âœ… é€€å‡ºæ—¶å¤ä½å…¨å±€å›è°ƒï¼Œé¿å…äºŒæ¬¡è¿›å…¥é¡µé¢å‡ºç°å¼‚å¸¸è¡Œä¸º
        try {
          AgoraRTC.onAutoplayFailed = null;
        } catch (_) {}

        // âœ… ç»Ÿä¸€æ¸…ç†è¿œç«¯æ£€æŸ¥å®šæ—¶å™¨
        if (remoteCheckTimer) {
          clearInterval(remoteCheckTimer);
          remoteCheckTimer = null;
        }

        setConnectionState("offline", "å·²æ–­å¼€è¿æ¥");
        elements.connectButton.disabled = false;
        isConnecting = false;
      }

      async function enterAndJoin() {
        if (isConnecting) {
          return;
        }
        isConnecting = true;
        
        setConnectionState("idle", "æ­£åœ¨åˆå§‹åŒ–RTCç³»ç»Ÿ...");
        elements.connectButton.disabled = true;
        log("ç³»ç»Ÿ", "å¼€å§‹åˆå§‹åŒ–RTCç³»ç»Ÿ...");

        try {
          // 0) å…ˆåˆå§‹åŒ–RTCç³»ç»Ÿï¼ˆæŒ‰éœ€å¯åŠ¨Agoraè¿æ¥ï¼‰
          const initUrl = `${API_BASE_URL}/api/rtc/init`;
          console.log("åˆå§‹åŒ–RTCç³»ç»ŸURL:", initUrl);
          const initResponse = await fetch(initUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({})
          });
          
          if (!initResponse.ok) {
            throw new Error(`RTCåˆå§‹åŒ–å¤±è´¥ HTTP ${initResponse.status}: ${initResponse.statusText}`);
          }
          
          const initResult = await initResponse.json();
          if (!initResult.ok) {
            throw new Error(`RTCåˆå§‹åŒ–å¤±è´¥: ${initResult.error}`);
          }
          
          log("ç³»ç»Ÿ", "âœ… RTCç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸï¼Œæ­£åœ¨ç”³è¯·è¿›å…¥æˆ¿é—´...");
          setConnectionState("idle", "æ­£åœ¨ç”³è¯·è¿›å…¥æˆ¿é—´...");

          // å¯åŠ¨WebSocketè°ƒè¯•è¿æ¥
          connectWebSocket();

          // 1) ç”³è¯·è¿›å…¥ï¼ˆæ‹¿é”+æ‹¿tokenï¼‰
          const enterUrl = `${API_BASE_URL}/rtc/enter`;
          console.log("è¯·æ±‚URL:", enterUrl);
          const response = await fetch(enterUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({ channel: CHANNEL })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const r = await response.json();

          if (!r.ok) {
            if (r.reason === "BUSY") {
              alert("å½“å‰çº¿è·¯æ­£å¿™ï¼Œè¯·ç¨åå†è¯•ã€‚");
              log("ç³»ç»Ÿ", "æˆ¿é—´è¢«å ç”¨ï¼Œæ— æ³•è¿›å…¥", "error");
            } else {
              alert(`è¿›å…¥æˆ¿é—´å¤±è´¥: ${r.reason}`);
              log("ç³»ç»Ÿ", `è¿›å…¥æˆ¿é—´å¤±è´¥: ${r.reason}`, "error");
            }
            setConnectionState("offline", "è¿›å…¥æˆ¿é—´å¤±è´¥");
            elements.connectButton.disabled = false;
            isConnecting = false;
            return;
          }

          sessionId = r.sessionId; 
          token = r.token; 
          uid = r.uid; 
          appId = r.appId;
          
          log("ç³»ç»Ÿ", `æˆåŠŸè·å–æˆ¿é—´é”ï¼Œä¼šè¯ID: ${sessionId}`);
          elements.localUid.textContent = uid || "-";
          elements.channelName.textContent = CHANNEL;

          // 2) å¿ƒè·³ï¼ˆ10sä¸€æ¬¡ï¼‰â€”â€”æ–­ç½‘/å´©æºƒå 25s è‡ªåŠ¨é‡Šæ”¾
          beatTimer = setInterval(()=> {
            const beatUrl = `${API_BASE_URL}/rtc/beat`;
            navigator.sendBeacon(beatUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
          }, 10000);

          setConnectionState("idle", "æ­£åœ¨åŠ å…¥å£°ç½‘é¢‘é“...");
          
          if (client.connectionState !== "DISCONNECTED") {
            await client.leave().catch(() => {});
          }

          // 3) åŠ å…¥é¢‘é“
          await client.join(appId, CHANNEL, token, uid);
          log("å£°ç½‘", `å·²åŠ å…¥é¢‘é“ ${CHANNEL}`);

          // ğŸš€ å…³é”®ä¿®å¤ï¼šç«‹å³ç»‘å®šäº‹ä»¶ç›‘å¬ï¼Œé¿å…é”™è¿‡ Bot çš„ published äº‹ä»¶
          console.log("[FLOW] ğŸ”§ ç«‹å³ç»‘å®šäº‹ä»¶ç›‘å¬å™¨...");
          bindClientEvents();

          // 4) åˆå§‹åŒ–è®¢é˜…ç®¡ç†å™¨ï¼ˆç›‘å¬Botç”¨æˆ·ï¼‰
          const config = await fetchAgoraConfig("publisher"); // è·å–botUid
          subscriptionManager = new WebSubscriptionManager(client, {
            maxRetryAttempts: 3,
            retryDelay: 2000,
            enableAutoSubscribe: true,
            logLevel: "info",
          });
          // æ³¨æ„ï¼šWebSubscriptionManagerä¸éœ€è¦initializeæ–¹æ³•ï¼Œæ„é€ å‡½æ•°å·²å®Œæˆåˆå§‹åŒ–
          // subscriptionManager.setSubscriptionCallback(handleSubscription); // æ­¤æ–¹æ³•ä¹Ÿä¸å­˜åœ¨ï¼Œä½¿ç”¨å›è°ƒå±æ€§ä»£æ›¿

          subscriptionManager.onSubscriptionSuccess = (uid, mediaType, result) => {
            console.log(`[SUBSCRIPTION] âœ… è®¢é˜…æˆåŠŸ: ${uid} (${mediaType})`);
            log("è®¢é˜…", `æˆåŠŸè®¢é˜…ç”¨æˆ· ${uid} çš„${mediaType === "audio" ? "éŸ³é¢‘" : "è§†é¢‘"}æµ`);

            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              console.log(`[SUBSCRIPTION] ğŸ¤– Botç”¨æˆ·éŸ³é¢‘è®¢é˜…æˆåŠŸï¼Œå¼€å§‹æ’­æ”¾`);

              // ä¿å­˜å…¨å±€å˜é‡ï¼Œæ–¹ä¾¿ autoplayFailed æˆ–æ–­å¼€æ—¶æ¸…ç†
              remoteAudioTrack = result || client.remoteUsers.find(u => String(u.uid) === String(uid))?.audioTrack;

              if (remoteAudioTrack) {
                try {
                  remoteAudioTrack.play("remoteAudio");
                  console.log("[SUBSCRIPTION] BotéŸ³é¢‘å·²æ’­æ”¾");
                } catch (err) {
                  console.warn("[SUBSCRIPTION] æ’­æ”¾å¤±è´¥ï¼Œå¯èƒ½æ˜¯ autoplay é™åˆ¶:", err);
                }
              } else {
                console.error("[SUBSCRIPTION] è®¢é˜…æˆåŠŸä½†æœªè·å–åˆ° audioTrack å¯¹è±¡");
              }
            }
          };



          subscriptionManager.onSubscriptionFailed = (
            uid,
            mediaType,
            error
          ) => {
            console.error(
              `[SUBSCRIPTION] âŒ è®¢é˜…å¤±è´¥: ${uid} (${mediaType})`,
              error
            );
            log(
              "è®¢é˜…",
              `è®¢é˜…ç”¨æˆ· ${uid} çš„${
                mediaType === "audio" ? "éŸ³é¢‘" : "è§†é¢‘"
              }æµå¤±è´¥: ${error.message}`,
              "error"
            );
          };

          subscriptionManager.onSubscriptionStateChanged = (
            uid,
            mediaType,
            state
          ) => {
            console.log(
              `[SUBSCRIPTION] ğŸ”„ è®¢é˜…çŠ¶æ€å˜åŒ–: ${uid} (${mediaType}) -> ${state}`
            );

            // æ›´æ–°UIæ˜¾ç¤º
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              const stateText =
                {
                  not_subscribed: "æœªè®¢é˜…",
                  subscribing: "è®¢é˜…ä¸­",
                  subscribed: "å·²è®¢é˜…",
                  subscription_failed: "è®¢é˜…å¤±è´¥",
                  unsubscribing: "å–æ¶ˆè®¢é˜…ä¸­",
                }[state] || state;

              elements.remoteUid.textContent = `Bot(${uid}) - ${stateText}`;
            }
          };

          console.log("[SUBSCRIPTION] è®¢é˜…ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œå·²è®¾ç½®å›è°ƒå‡½æ•°");

          // ğŸš€ å…³é”®ä¿®å¤ï¼šç«‹å³æ‰«æå¹¶è¡¥è®¢ç°æœ‰çš„ Bot ç”¨æˆ·
          console.log("[FLOW] ğŸ” æ‰«æå¹¶è¡¥è®¢ç°æœ‰ Bot ç”¨æˆ·...");
          await scanAndSubscribeExistingBots();

          // [DEBUG] æ£€æŸ¥å½“å‰è¿œç«¯ç”¨æˆ·
          console.log("[DEBUG] å½“å‰è¿œç«¯ç”¨æˆ·:", client.remoteUsers);
          console.log("[DEBUG] è¿œç«¯ç”¨æˆ·æ•°é‡:", client.remoteUsers.length);
          client.remoteUsers.forEach((user) => {
            console.log("[DEBUG] è¿œç«¯ç”¨æˆ·è¯¦æƒ…:", {
              uid: user.uid,
              hasAudio: user.hasAudio,
              hasVideo: user.hasVideo,
            });
          });

          // [AUDIO_FLOW] æ£€æŸ¥éº¦å…‹é£æƒé™å’Œè®¾å¤‡
          try {
            const devices = await AgoraRTC.getDevices();
            const audioInputs = devices.filter(
              (device) => device.kind === "audioinput"
            );
            console.log(
              "[AUDIO_FLOW] å¯ç”¨éŸ³é¢‘è¾“å…¥è®¾å¤‡:",
              audioInputs.map((d) => ({ id: d.deviceId, label: d.label }))
            );

            if (audioInputs.length === 0) {
              console.warn("[AUDIO_FLOW] è­¦å‘Š: æœªæ£€æµ‹åˆ°éŸ³é¢‘è¾“å…¥è®¾å¤‡");
            }
          } catch (error) {
            console.error("[AUDIO_FLOW] è·å–éŸ³é¢‘è®¾å¤‡å¤±è´¥:", error);
          }

          // åˆ›å»ºå’Œå‘å¸ƒéŸ³é¢‘è½¨é“
          console.log("[AUDIO_FLOW] å¼€å§‹åˆ›å»ºéº¦å…‹é£éŸ³é¢‘è½¨é“...");
          microphoneAudioTrack = await AgoraRTC.createMicrophoneAudioTrack({
            encoderConfig: {
              sampleRate: 48000,
              stereo: false,
            },
          });
          localTrack = microphoneAudioTrack; // ä¿æŒå…¼å®¹æ€§

          // [AUDIO_FLOW] éŸ³é¢‘è½¨é“åˆ›å»ºæˆåŠŸè°ƒè¯•æ—¥å¿—
          console.log("[AUDIO_FLOW] éº¦å…‹é£éŸ³é¢‘è½¨é“å·²åˆ›å»º:", {
            trackId: microphoneAudioTrack.getTrackId(),
            enabled: microphoneAudioTrack.enabled,
            muted: microphoneAudioTrack.muted,
            sampleRate: 48000,
          });

          await client.publish(microphoneAudioTrack);

          // [AUDIO_FLOW] éŸ³é¢‘å‘å¸ƒæˆåŠŸè°ƒè¯•æ—¥å¿—
          console.log("[AUDIO_FLOW] æœ¬åœ°éŸ³é¢‘å·²å‘å¸ƒåˆ°å£°ç½‘:", {
            trackId: microphoneAudioTrack.getTrackId(),
            published: true,
            clientState: client.connectionState,
          });

          log("å£°ç½‘", "æœ¬åœ°éŸ³é¢‘å·²å‘å¸ƒ");

          // [AUDIO_FLOW] æ·»åŠ éŸ³é¢‘æ•°æ®å¤„ç†å™¨ç›‘å¬éŸ³é¢‘æµ
          if (microphoneAudioTrack) {
            let audioFrameCounter = 0;
            try {
              const processor = {
                process: (audioBuffer) => {
                  audioFrameCounter++;
                  if (audioFrameCounter % 100 === 0) {
                    console.log(
                      "[AUDIO_FLOW] éŸ³é¢‘æ•°æ®æµç»å£°ç½‘SDK (ç¬¬" +
                        audioFrameCounter +
                        "å¸§):",
                      {
                        sampleRate: audioBuffer.sampleRate,
                        numberOfChannels: audioBuffer.numberOfChannels,
                        length: audioBuffer.length,
                        timestamp: Date.now(),
                      }
                    );
                  }
                  return audioBuffer;
                },
              };

              if (localTrack.pipe && typeof localTrack.pipe === "function") {
                localTrack.pipe(processor);
                console.log("[AUDIO_FLOW] éŸ³é¢‘å¤„ç†å™¨å·²æ·»åŠ åˆ°æœ¬åœ°è½¨é“");
              } else {
                console.log(
                  "[AUDIO_FLOW] æœ¬åœ°è½¨é“ä¸æ”¯æŒpipeæ–¹æ³•ï¼Œå°è¯•å…¶ä»–ç›‘å¬æ–¹å¼"
                );
              }
            } catch (error) {
              console.log("[AUDIO_FLOW] æ·»åŠ éŸ³é¢‘å¤„ç†å™¨å¤±è´¥:", error.message);
            }

            startMicMeter(microphoneAudioTrack);
          }

          // å¤„ç† Autoplay é™åˆ¶
          AgoraRTC.onAutoplayFailed = () => {
            console.warn("[WARN] Autoplay è¢«é™åˆ¶ï¼Œåˆ›å»ºæ¢å¤æŒ‰é’®");
            const btn = document.createElement("button");
            btn.innerText = "ç‚¹å‡»æ¢å¤ Bot éŸ³é¢‘";
            btn.style.padding = "12px";
            btn.style.margin = "16px";
            btn.style.background = "#48bb78";
            btn.style.color = "#fff";
            btn.style.borderRadius = "8px";
            btn.onclick = () => {
              if (remoteAudioTrack) {
                remoteAudioTrack.play("remoteAudio");
                console.log("[DEBUG] ç”¨æˆ·ç‚¹å‡»åæ¢å¤æ’­æ”¾æˆåŠŸ");
              }
              btn.remove();
            };
            document.body.appendChild(btn);
          };

          // ğŸš€ å…³é”®ä¿®å¤ï¼šåœ¨æ‰€æœ‰å‡†å¤‡å·¥ä½œå®Œæˆåå†è§¦å‘æ¬¢è¿è¯­
          console.log("[FLOW] ğŸ‰ æ‰€æœ‰å‡†å¤‡å·¥ä½œå®Œæˆï¼Œç°åœ¨è§¦å‘æ¬¢è¿è¯­...");
          try {
            const resp = await fetch(`${API_BASE_URL}/api/rtc/welcome`, {
              method: "POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({})
            });
            const data = await resp.json();
            console.log("[WELCOME] è§¦å‘ç»“æœ:", data);
            if (data.ok && data.welcome_sent) {
              log("ç³»ç»Ÿ", "âœ… æ¬¢è¿è¯­å·²è§¦å‘ï¼ˆéŸ³é¢‘è®¢é˜…å·²å°±ç»ªï¼‰");
            } else {
              console.warn("[WELCOME] è§¦å‘å¤±è´¥æˆ–æœªå‘é€:", data);
            }
          } catch (err) {
            console.error("[WELCOME] è¯·æ±‚å‡ºé”™:", err);
          }

          // --- æ–°å¢ï¼šåŠ å…¥åä¸»åŠ¨æ£€æŸ¥Botç”¨æˆ·å¹¶å¯èƒ½å¯åŠ¨é‡è¯• ---
          if (subscriptionManager) {
            // å¯ä»¥é€‰æ‹©æ€§åœ°å»¶è¿Ÿä¸€ä¸‹ï¼Œç¡®ä¿ SDK çŠ¶æ€æ›´ç¨³å®šï¼Œæˆ–è€…ç›´æ¥è°ƒç”¨
            // setTimeout(() => {
              subscriptionManager.checkBotUsersForRetry();
            // }, 100); // å»¶è¿Ÿ 100msï¼Œå¯é€‰
          } else {
            console.warn("SubscriptionManager æœªæ‰¾åˆ°ï¼Œæ— æ³•æ£€æŸ¥Botç”¨æˆ·é‡è¯•ã€‚");
          }
          // --- æ–°å¢ç»“æŸ ---

          setConnectionState("online", "å£°ç½‘é“¾è·¯å·²å»ºç«‹ï¼Œç­‰å¾… Bot éŸ³é¢‘...");
          elements.disconnectButton.disabled = false;
          log("ç³»ç»Ÿ", "è¿æ¥å®Œæˆï¼ŒBot éŸ³é¢‘å°†è‡ªåŠ¨æ’­æ”¾");

          // ?? æ·»åŠ ï¼šå®šæ—¶æ£€æŸ¥é¢‘é“å†…çš„è¿œç«¯ç”¨æˆ·ï¼ˆå¢å¼ºç‰ˆï¼‰
          if (remoteCheckTimer) { clearInterval(remoteCheckTimer); remoteCheckTimer = null; } // é¿å…é‡å¤
          remoteCheckTimer = setInterval(() => {
            const remoteUsers = client.remoteUsers;
            console.log("[CHECK] =========================");
            console.log("[CHECK] é¢‘é“å†…è¿œç«¯ç”¨æˆ·æ€»æ•°:", remoteUsers.length);

            if (remoteUsers.length === 0) {
              console.log("[CHECK] ?? é¢‘é“å†…æ— è¿œç«¯ç”¨æˆ·");
            } else {
              remoteUsers.forEach((user) => {
                console.log(`[CHECK] ç”¨æˆ· ${user.uid}:`, {
                  hasAudioTrack: !!user.audioTrack,
                  hasVideoTrack: !!user.videoTrack,
                  isPlaying: user.audioTrack?.isPlaying,
                  audioTrackType: typeof user.audioTrack,
                  audioTrackObject: user.audioTrack,
                });

                if (user.audioTrack) {
                  console.log(
                    `[CHECK] ? ç”¨æˆ· ${user.uid} æœ‰éŸ³é¢‘è½¨é“ï¼Œæ’­æ”¾çŠ¶æ€: ${user.audioTrack.isPlaying}`
                  );
                } else {
                  console.log(`[CHECK] ? ç”¨æˆ· ${user.uid} æ— éŸ³é¢‘è½¨é“`);
                }

                // ç‰¹åˆ«æ£€æŸ¥Bot UID - ä½¿ç”¨UIDéªŒè¯å™¨
                if (WebUIDValidator.isBotUser(user.uid)) {
                  console.log(
                    `[CHECK] ğŸ¤– æ£€æµ‹åˆ°Botç”¨æˆ· ${
                      user.uid
                    }! (ç±»å‹: ${typeof user.uid})`
                  );
                  WebUIDValidator.logUIDInfo("Botç”¨æˆ·æ£€æµ‹", user.uid, {
                    hasAudioTrack: !!user.audioTrack,
                    isPlaying: user.audioTrack?.isPlaying,
                  });
                  if (!user.audioTrack) {
                    console.log(
                      `[CHECK] âš ï¸ Botç”¨æˆ·æ— éŸ³é¢‘è½¨é“ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨è®¢é˜…`
                    );
                  }
                }
              });
            }
            console.log("[CHECK] =========================");
          }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
        } catch (error) {
          log("é”™è¯¯", `è¿æ¥å¤±è´¥: ${error.message}`, "error");
          await disconnect();
        } finally {
          isConnecting = false;
          if (!elements.disconnectButton.disabled) {
            elements.connectButton.disabled = true;
          } else {
            elements.connectButton.disabled = false;
          }
        }
      }
      function bindClientEvents() {
        // å…ˆé˜²å¾¡æ€§è§£ç»‘ï¼ˆé¿å…æç«¯æƒ…å†µä¸‹é‡å¤ç»‘å®šï¼‰
        unbindClientEvents();

        // ğŸš€ å…³é”®ä¿®å¤ï¼šç«‹å³è®¢é˜… Bot éŸ³é¢‘ï¼Œé¿å…å»¶è¿Ÿ
        clientHandlers.userPublished = async (user, mediaType) => {
          console.log("[EVENT] user-published:", user.uid, mediaType);
          
          // å¦‚æœæ˜¯ Bot ç”¨æˆ·å‘å¸ƒéŸ³é¢‘ï¼Œç«‹å³è®¢é˜…
          if (mediaType === "audio" && WebUIDValidator.isBotUser(user.uid)) {
            try {
              console.log(`[AUTO] ğŸ¤– æ£€æµ‹åˆ° Bot ${user.uid} å‘å¸ƒéŸ³é¢‘ï¼Œç«‹å³è®¢é˜…...`);
              await client.subscribe(user, "audio");
              
              remoteAudioTrack = user.audioTrack;
              if (remoteAudioTrack) {
                // è®¾ç½®éŸ³é‡
                const volume = parseInt(elements.volumeSlider.value) || 70;
                remoteAudioTrack.setVolume(volume);
                
                // å¼€å§‹æ’­æ”¾
                remoteAudioTrack.play("remoteAudio");
                console.log(`[AUTO] âœ… Bot ${user.uid} éŸ³é¢‘å·²è®¢é˜…å¹¶å¼€å§‹æ’­æ”¾`);
                log("è‡ªåŠ¨è®¢é˜…", `Bot ${user.uid} éŸ³é¢‘å·²è¿æ¥å¹¶æ’­æ”¾`);
                
                // æ›´æ–°UIçŠ¶æ€
                elements.remoteUid.textContent = `Bot(${user.uid}) - å·²è¿æ¥`;
              } else {
                console.error(`[AUTO] âŒ è®¢é˜…æˆåŠŸä½†æœªè·å–åˆ° audioTrack`);
              }
            } catch (err) {
              console.error(`[AUTO] âŒ ç«‹å³è®¢é˜… Bot ${user.uid} éŸ³é¢‘å¤±è´¥:`, err);
              log("è®¢é˜…å¤±è´¥", `Bot ${user.uid} éŸ³é¢‘è®¢é˜…å¤±è´¥: ${err.message}`, "error");
            }
          }
        };

        clientHandlers.userUnpublished = (user, mediaType) => {
          console.log("[EVENT] user-unpublished:", user.uid, mediaType);
          if (WebUIDValidator.isBotUser(user.uid) && mediaType === "audio") {
            elements.remoteUid.textContent = "-";
            log("å–æ¶ˆå‘å¸ƒ", `Bot ${user.uid} å–æ¶ˆå‘å¸ƒéŸ³é¢‘`);
          }
        };

        clientHandlers.userLeft = (user) => {
          console.log("[EVENT] user-left:", user.uid);
          if (WebUIDValidator.isBotUser(user.uid)) {
            elements.remoteUid.textContent = "-";
            log("ç¦»å¼€", `Bot ${user.uid} å·²ç¦»å¼€`);
          }
        };

        clientHandlers.connectionStateChange = (cur, prev, reason) => {
          log("å£°ç½‘", `è¿æ¥çŠ¶æ€: ${prev} -> ${cur} (${reason})`);
        };

        // ç»‘å®šæ‰€æœ‰äº‹ä»¶
        client.on("user-published", clientHandlers.userPublished);
        client.on("user-unpublished", clientHandlers.userUnpublished);
        client.on("user-left", clientHandlers.userLeft);
        client.on("connection-state-change", clientHandlers.connectionStateChange);
      }

      // ğŸš€ å…³é”®ä¿®å¤ï¼šæ‰«æå¹¶è¡¥è®¢ç°æœ‰çš„ Bot ç”¨æˆ·
      async function scanAndSubscribeExistingBots() {
        console.log("[SCAN] å¼€å§‹æ‰«æç°æœ‰è¿œç«¯ç”¨æˆ·...");
        const remoteUsers = client.remoteUsers;
        console.log(`[SCAN] å‘ç° ${remoteUsers.length} ä¸ªè¿œç«¯ç”¨æˆ·`);
        
        for (const user of remoteUsers) {
          console.log(`[SCAN] æ£€æŸ¥ç”¨æˆ· ${user.uid}:`, {
            hasAudio: user.hasAudio,
            audioTrack: !!user.audioTrack,
            isBotUser: WebUIDValidator.isBotUser(user.uid)
          });
          
          if (WebUIDValidator.isBotUser(user.uid) && (user.hasAudio || user.audioTrack)) {
            try {
              console.log(`[SCAN] ğŸ¤– å‘ç°ç°æœ‰ Bot ${user.uid}ï¼Œç«‹å³è¡¥è®¢éŸ³é¢‘...`);
              
              // å¦‚æœè¿˜æ²¡æœ‰è®¢é˜…ï¼Œåˆ™è®¢é˜…
              if (!user.audioTrack) {
                await client.subscribe(user, "audio");
                console.log(`[SCAN] âœ… è¡¥è®¢ Bot ${user.uid} éŸ³é¢‘æˆåŠŸ`);
              }
              
              remoteAudioTrack = user.audioTrack;
              if (remoteAudioTrack) {
                // è®¾ç½®éŸ³é‡
                const volume = parseInt(elements.volumeSlider.value) || 70;
                remoteAudioTrack.setVolume(volume);
                
                // å¼€å§‹æ’­æ”¾
                remoteAudioTrack.play("remoteAudio");
                console.log(`[SCAN] âœ… Bot ${user.uid} éŸ³é¢‘å·²å¼€å§‹æ’­æ”¾`);
                log("è¡¥è®¢æˆåŠŸ", `å‘ç°å¹¶è¿æ¥äº† Bot ${user.uid} éŸ³é¢‘`);
                
                // æ›´æ–°UIçŠ¶æ€
                elements.remoteUid.textContent = `Bot(${user.uid}) - å·²è¿æ¥`;
                break; // æ‰¾åˆ°ä¸€ä¸ªBotå°±å¤Ÿäº†
              }
            } catch (err) {
              console.error(`[SCAN] âŒ è¡¥è®¢ Bot ${user.uid} éŸ³é¢‘å¤±è´¥:`, err);
              log("è¡¥è®¢å¤±è´¥", `Bot ${user.uid} éŸ³é¢‘è¡¥è®¢å¤±è´¥: ${err.message}`, "error");
            }
          }
        }
        
        if (remoteUsers.length === 0) {
          console.log("[SCAN] å½“å‰é¢‘é“å†…æ— è¿œç«¯ç”¨æˆ·ï¼Œç­‰å¾… Bot åŠ å…¥...");
        }
      }

      function unbindClientEvents() {
        if (clientHandlers.userPublished) {
          client.off("user-published", clientHandlers.userPublished);
        }
        if (clientHandlers.userUnpublished) {
          client.off("user-unpublished", clientHandlers.userUnpublished);
        }
        if (clientHandlers.userLeft) {
          client.off("user-left", clientHandlers.userLeft);
        }
        if (clientHandlers.connectionStateChange) {
          client.off("connection-state-change", clientHandlers.connectionStateChange);
        }
        // å¯é€‰ï¼šé‡ç½®ä¸º nullï¼Œé¿å…è¯¯ç”¨æ—§æŒ‡é’ˆ
        clientHandlers = {
          userPublished: null,
          userUnpublished: null,
          userLeft: null,
          connectionStateChange: null,
        };
      }
      async function disconnect() {
        elements.disconnectButton.disabled = true;
        
        try {

          // â‘  å…ˆè§£ç»‘æ‰€æœ‰ client äº‹ä»¶ï¼ˆå¯¹ç§°ï¼‰
          unbindClientEvents();
             // ï¼ˆå¯ç•™ç€ä½ çš„è¿™è¡Œï¼Œç­‰ä»·é˜²å¾¡ï¼‰
          // client.off("connection-state-change");
          
         // â‘¡ å…³è¿œç«¯/æœ¬åœ°è½¨é“
          if (remoteAudioTrack) {
            remoteAudioTrack.stop();
            remoteAudioTrack.close();
            remoteAudioTrack = null;
          }

          if (localTrack) {
            localTrack.stop();
            localTrack.close();
            localTrack = null;
          }
          // â‘¢ åœæ­¢ç”µå¹³åŠ¨ç”»
          stopMicMeter();

           // âœ… ç»Ÿä¸€æ¸…ç†è¿œç«¯æ£€æŸ¥å®šæ—¶å™¨
          if (remoteCheckTimer) {
            clearInterval(remoteCheckTimer);
            remoteCheckTimer = null;
          }
          // âœ… é€€å‡ºæ—¶å¤ä½å…¨å±€å›è°ƒï¼Œé¿å…äºŒæ¬¡è¿›å…¥é¡µé¢å‡ºç°å¼‚å¸¸è¡Œä¸º
          try {
            AgoraRTC.onAutoplayFailed = null;
          } catch (_) {}

          // æ¸…ç†è®¢é˜…ç®¡ç†å™¨
          if (subscriptionManager) {
            subscriptionManager.destroy();
            subscriptionManager = null;
            console.log("[SUBSCRIPTION] è®¢é˜…ç®¡ç†å™¨å·²æ¸…ç†");
          }

          // æ–­å¼€WebSocketè¿æ¥
          disconnectWebSocket();
         

          // è°ƒç”¨ç»Ÿä¸€çš„æ¸…ç†å‡½æ•°ï¼ˆåŒ…å«æˆ¿é—´é”é‡Šæ”¾ï¼‰
          await leaveAndCleanup();
        } catch (error) {
          log("é”™è¯¯", `æ–­å¼€è¿æ¥å‡ºç°é—®é¢˜: ${error.message}`);
          // å³ä½¿å‡ºé”™ä¹Ÿè¦å°è¯•æ¸…ç†
          await leaveAndCleanup();
        }
      }

      
    
      elements.connectButton.addEventListener("click", enterAndJoin);
      elements.disconnectButton.addEventListener("click", disconnect);

      elements.volumeSlider.addEventListener("input", (event) => {
        const volume = Number(event.target.value || "70");
        elements.remoteVolume.textContent = `${volume}%`;
        if (remoteAudioTrack) {
          remoteAudioTrack.setVolume(volume);
        }
      });





      // â€”â€” æŒ‚åˆ°æ‰€æœ‰é€€å‡ºè·¯å¾„ â€”â€”
      // 1) å…³é—­/åˆ·æ–°
      window.addEventListener("beforeunload", leaveAndCleanup);
      window.addEventListener("pagehide", leaveAndCleanup);     // iOS Safari
      // 2) é¡µé¢å¯è§æ€§å˜åŒ–ï¼ˆå¯é€‰ï¼šåå°åœæ’­ï¼Œå‰å°å†æ’­ï¼‰
      window.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          console.log("[DEBUG] é¡µé¢è¿›å…¥åå°");
          // å¯é€‰ï¼šæš‚åœæŸäº›æ“ä½œ
        } else {
          console.log("[DEBUG] é¡µé¢å›åˆ°å‰å°");
          // å¯é€‰ï¼šæ¢å¤æŸäº›æ“ä½œ
        }
      });

      log("ç³»ç»Ÿ", "é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»æŒ‰é’®å³å¯ä½“éªŒå£°ç½‘ RTC é“¾è·¯ã€‚");
      
      // é¡µé¢åŠ è½½æ—¶å°è¯•è¿æ¥WebSocketè°ƒè¯•æœåŠ¡
      log("ç³»ç»Ÿ", "æ­£åœ¨è¿æ¥WebSocketè°ƒè¯•æœåŠ¡...");
      connectWebSocket();
    </script>
  </body>
</html>
