<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>声网 RTC 双工对话客户端</title>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.20.0.js"></script>
    <script src="web_uid_validator.js"></script>
    <script src="web_subscription_manager.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #5a67d8 0%, #805ad5 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #1a202c;
        padding: 24px;
      }

      .container {
        width: 100%;
        max-width: 900px;
        background: rgba(255, 255, 255, 0.96);
        border-radius: 20px;
        padding: 32px;
        box-shadow: 0 20px 60px rgba(67, 56, 202, 0.18);
      }

      header {
        text-align: center;
        margin-bottom: 24px;
      }

      header h1 {
        font-size: 2.2rem;
        color: #2d3748;
        margin-bottom: 8px;
      }

      header p {
        color: #4a5568;
      }

      .status-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }

      .status-card {
        background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
        border-radius: 14px;
        padding: 18px;
        border: 1px solid #cbd5f5;
      }

      .status-card h2 {
        font-size: 1rem;
        color: #2b6cb0;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .status-value {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .status-value.online {
        color: #2f855a;
      }

      .status-value.offline {
        color: #c53030;
      }

      .status-value.idle {
        color: #b7791f;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        margin-bottom: 24px;
        justify-content: center;
      }

      button {
        padding: 12px 28px;
        border: none;
        border-radius: 999px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.25s ease;
        color: #fff;
      }

      button.primary {
        background: linear-gradient(135deg, #48bb78, #38a169);
      }

      button.primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      button.danger {
        background: linear-gradient(135deg, #f56565, #e53e3e);
      }

      button.danger:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      /* 一个没用的注释，触发重启 */
      .meter {
        background: #edf2f7;
        border-radius: 14px;
        padding: 12px 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.95rem;
        color: #4a5568;
      }

      .meter span {
        font-weight: 600;
        color: #2d3748;
      }

      .meter-bar {
        margin-top: 8px;
        width: 180px;
        height: 10px;
        background: #e2e8f0;
        border-radius: 999px;
        overflow: hidden;
      }

      .meter-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(135deg, #63b3ed, #3182ce);
        transition: width 0.1s ease;
      }

      .conversation-log {
        background: #f7fafc;
        border-radius: 14px;
        border: 1px solid #e2e8f0;
        padding: 18px;
        max-height: 260px;
        overflow-y: auto;
      }

      .log-entry {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px dashed rgba(160, 174, 192, 0.5);
      }

      .log-entry:last-child {
        border-bottom: none;
      }

      .log-entry time {
        display: block;
        font-size: 0.8rem;
        color: #718096;
        margin-bottom: 4px;
      }

      .log-entry strong {
        display: inline-block;
        min-width: 70px;
        color: #2b6cb0;
      }

      .volume-control {
        display: flex;
        align-items: center;
        gap: 12px;
        justify-content: center;
        margin-top: 8px;
      }

      .volume-control label {
        font-weight: 600;
        color: #2d3748;
      }

      .volume-control input {
        width: 220px;
      }

      .conversation-log {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        margin: 24px 0;
        max-height: 300px;
        overflow-y: auto;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 0.9rem;
      }

      .log-entry {
        margin-bottom: 8px;
        padding: 8px;
        border-radius: 6px;
        background: white;
        border-left: 4px solid #cbd5e0;
      }

      .log-entry.stt {
        border-left-color: #4299e1;
        background: #ebf8ff;
      }

      .log-entry.llm {
        border-left-color: #48bb78;
        background: #f0fff4;
      }

      .log-entry.error {
        border-left-color: #f56565;
        background: #fed7d7;
        color: #c53030;
      }

      .log-entry time {
        font-size: 0.8rem;
        color: #718096;
        margin-right: 8px;
      }

      .log-entry .source {
        font-weight: 600;
        margin-right: 8px;
      }

      .log-entry .source.stt {
        color: #2b6cb0;
      }

      .log-entry .source.llm {
        color: #2f855a;
      }

      .log-entry .source.error {
        color: #c53030;
      }

      .error-popup {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #fed7d7;
        border: 1px solid #feb2b2;
        border-radius: 8px;
        padding: 16px;
        max-width: 400px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
      }

      .error-popup .error-title {
        font-weight: 600;
        color: #c53030;
        margin-bottom: 8px;
      }

      .error-popup .error-message {
        color: #742a2a;
        font-size: 0.9rem;
      }

      .error-popup .close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 1.2rem;
        color: #c53030;
        cursor: pointer;
        padding: 4px;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .websocket-status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .websocket-status.connected {
        background: #48bb78;
      }

      .websocket-status.disconnected {
        background: #f56565;
      }

      .websocket-status.connecting {
        background: #ed8936;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      footer {
        margin-top: 24px;
        text-align: center;
        font-size: 0.85rem;
        color: #4a5568;
      }

      footer code {
        background: #edf2f7;
        padding: 2px 6px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>声网 RTC 双工对话客户端</h1>
        <p>浏览器直接加入声网频道，上行麦克风、下行 Bot 音频</p>
      </header>

      <section class="status-panel">
        <div class="status-card">
          <h2>连接状态</h2>
          <div id="connectionStatus" class="status-value offline">未连接</div>
          <p id="statusHint">点击开始对话即可连接声网</p>
        </div>
        <div class="status-card">
          <h2>频道信息</h2>
          <div class="status-value">
            <div>频道：<span id="channelName">-</span></div>
            <div>本地 UID：<span id="localUid">-</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>Bot 状态</h2>
          <div class="status-value">
            <div>远端 UID：<span id="remoteUid">-</span></div>
            <div>音量：<span id="remoteVolume">70%</span></div>
          </div>
        </div>
        <div class="status-card">
          <h2>调试连接</h2>
          <div class="status-value">
            <div><span class="websocket-status disconnected" id="wsStatus"></span>WebSocket：<span id="wsStatusText">未连接</span></div>
            <div>消息数：<span id="wsMessageCount">0</span></div>
          </div>
        </div>
      </section>

      <section class="controls">
        <button id="connectButton" class="primary">开始对话</button>
        <button id="disconnectButton" class="danger" disabled>断开连接</button>
      </section>

      <section class="meter">
        <div>
          <span>麦克风电平</span>
          <div class="meter-bar">
            <div id="micBar" class="meter-fill"></div>
          </div>
        </div>
        <div>
          <span id="micLevel">0%</span>
        </div>
      </section>

      <div class="volume-control">
        <label for="volumeSlider">Bot 音量</label>
        <input id="volumeSlider" type="range" min="0" max="100" value="70" />
      </div>



      <section class="conversation-log" id="logContainer"></section>

      <div id="remoteAudio"></div>

      <footer>
        <div>
          调试命令：<code
            >curl https://cityuantifraud.cn/api/agora/config</code
          >
        </div>
      </footer>
    </div>

    <script>
      /**
       * 路由原则（别乱改）：
       * 1) 预录音频 & cache_index.json 仅从前端仓库读取（相对路径），绝不去后端取。
       *    例：./prerecorded_audio/cache_index.json
       *        ./prerecorded_audio/audio_files/xxx.mp3
       * 
       * 2) RTC/业务相关只打后端（cityuantifraud.cn）：
       *    - POST /api/rtc/init
       *    - POST /rtc/enter  / sendBeacon /rtc/beat  / sendBeacon /rtc/leave
       *    - POST /api/rtc/welcome  / POST /api/rtc/shutdown
       *    - GET  /api/agora/config?role=...
       *    - WSS  wss://cityuantifraud.cn/ws
       * 
       * 3) 播放 Bot 的音频（来自 Agora）= 订阅 remoteAudioTrack.play('remoteAudio')，这既不是前端静态音频，也不是后端直链。
       */

      // === AudioGate：一次解锁，后续任意播放 ===
      function createAudioGate({ poolSize = 4 } = {}) {
        let unlocked = false;
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const pool = [];

        // 预创建一组 <audio>，后续统一复用
        for (let i = 0; i < poolSize; i++) {
          const a = document.createElement('audio');
          a.preload = 'auto';
          a.setAttribute('playsinline', '');
          a.playsInline = true;
          a.controls = false;
          a.style.display = 'none';
          document.body.appendChild(a);
          pool.push(a);
        }

        async function unlock() {
          if (unlocked) return;
          try {
            console.log('[AudioGate] 开始解锁音频环境...');
            
            // 1) 唤醒 WebAudio
            await ctx.resume();

            // 2) 用一次用户手势"祝福"所有 <audio> 元素
            //    播一段极短静音音频 -> 立即 pause -> 元素进入已授权状态
            const silent =
              'data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA';
            await Promise.all(
              pool.map(async (el) => {
                try {
                  el.src = silent;
                  el.volume = 0.001;
                  await el.play();
                  el.pause();
                  el.currentTime = 0;
                  el.removeAttribute('src');
                  el.load(); // 清空，等待后续真正的 src
                } catch (e) {
                  // 部分浏览器这里可能拒绝，但只要有一次成功就足够
                  console.warn('[AudioGate] bless one element failed:', e.message);
                }
              })
            );

            // 3) 保险：用一个隐藏 iframe 自动播一次静音，覆盖部分内核边角
            try {
              const iframe = document.createElement('iframe');
              iframe.allow = 'autoplay';
              iframe.style.display = 'none';
              iframe.srcdoc =
                '<audio autoplay ' +
                'src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA"></audio>';
              document.body.appendChild(iframe);
              setTimeout(() => iframe.remove(), 2000);
            } catch {}

            unlocked = true;
            window.__audioGate__ = { ctx, pool, unlocked: true };
            console.log('[AudioGate] ✅ 音频环境已成功解锁');
          } catch (err) {
            console.warn('[AudioGate] unlock failed:', err);
          }
        }

        function getFreeElement() {
          // 找一个空闲 <audio>（暂停或已结束），没有就用第一个（会打断它）
          return pool.find((el) => el.paused || el.ended) || pool[0];
        }

        async function play(url, { volume = 1.0, loop = false } = {}) {
          if (!unlocked) throw new Error('Audio not unlocked yet');
          const el = getFreeElement();
          el.volume = volume;
          el.loop = loop;
          el.setAttribute('playsinline', '');
          el.playsInline = true;
          el.src = url;
          try {
            await el.play();
            return el; // 返回正在播放的 <audio>
          } catch (err) {
            // HTMLMediaElement 播放失败时，降级走 WebAudio 解码播放（几乎总能播）
            console.warn('[AudioGate] media play() failed, fallback to WebAudio:', err);
            try {
              const resp = await fetch(url);
              const buf = await resp.arrayBuffer();
              const audioBuf = await ctx.decodeAudioData(buf);
              const node = ctx.createBufferSource();
              node.buffer = audioBuf;
              node.connect(ctx.destination);
              node.start(0);
              return node; // 返回 WebAudio 的节点
            } catch (e) {
              console.error('[AudioGate] fallback failed:', e);
              throw err;
            }
          }
        }

        // 页面回前台自动 resume（很多时候不需要用户手势）
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible' && ctx.state === 'suspended') {
            ctx.resume().catch(() => {});
          }
        });
        // 任意交互时也尝试 resume（如果被系统挂起，用户随手点一下任何位置即可恢复）
        ['pointerdown', 'touchstart', 'keydown'].forEach((evt) => {
          window.addEventListener(
            evt,
            () => {
              if (ctx.state === 'suspended') ctx.resume().catch(() => {});
            },
            { passive: true }
          );
        });

        return { unlock, play, get unlocked() { return unlocked; }, ctx, pool };
      }
      
      const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
      
      // 全局只建一次 AudioGate 实例
      const AudioGate = createAudioGate({ poolSize: 4 });
      
      let localTrack = null;
      let microphoneAudioTrack = null; // 添加缺失的变量定义
      let remoteAudioTrack = null;
      let agoraConfigCache = null;
      const backendBaseUrl = "https://cityuantifraud.cn";
      // 生产环境配置：API调用使用后端服务器，静态资源使用相对路径
      const API_BASE_URL = backendBaseUrl;
      
      // 静态资源一律相对路径；该函数只是确保不会出现以 / 开头的根路径导致跳到站点根
      const staticPath = (p) => (p || "").replace(/^\/+/, "");
      // 音频路径归一化：处理Windows反斜杠并确保相对路径
      const normalizeAudioPath = (p) => staticPath(String(p || '').replace(/\\/g, '/'));
      let isConnecting = false;
      let subscriptionManager = null;
      let audioContext = null;
      let analyser = null;
      let micDataArray = null;
      let meterAnimation = null;
      


      // WebSocket相关变量
      let debugWebSocket = null;
      let wsReconnectTimer = null;
      let wsMessageCount = 0;
      let wsReconnectAttempts = 0;
      const WS_MAX_RECONNECT_ATTEMPTS = 5;
      const WS_RECONNECT_DELAY = 3000;
      
      // === 统一去重：2s TTL ===
      const DEDUP_TTL_MS = 2000;           // ★ 2 秒 TTL
      const lastSeenMap = new Map();       // hash -> ts
      
      // 预录制音频播放状态跟踪
      let lastPrerecordedAudioTime = 0;
      const PRERECORDED_AUDIO_WINDOW = 1000; // 1秒内的assistant_text消息被认为是预录制音频相关
      
      // ===== 预录音频"播放锁"/节流 =====
      let prerecPlayingKey = null;
      let prerecAudioEl = null;
      const prerecRecent = new Map(); // key -> ts
      const PREREC_TTL_MS = 4000;     // 4s 内相同Key不重复播
      
      // ===== 播放排队机制：未解锁时先排队，解锁后一次性冲刷 =====
      const pendingAudioQueue = []; // {url, audioData}[]
      
      function normalizeTextKey(t) {
        return (t || "")
          .replace(/[，。！？；：、"'""''（）【】[\]\s]/g, "")
          .toLowerCase();
      }
      
      function keyFromAudioData(audioData, fallbackText) {
        if (audioData?.audio_file) return `file:${audioData.audio_file}`;
        if (audioData?.hash)       return `hash:${audioData.hash}`;
        const txt = audioData?.text || fallbackText || "";
        return `text:${normalizeTextKey(txt)}`;
      }
      
      // 播放排队相关函数
      function doPlay(audioUrl, audioData) {
        AudioGate.play(audioUrl, { volume: 1.0 }).then(player => {
          prerecAudioEl = player;

          // 结束清理（同时兼容 <audio> 与 WebAudio）
          if (player && typeof player.addEventListener === 'function') {
            player.addEventListener('ended', () => {
              prerecPlayingKey = null; 
              prerecAudioEl = null;
            });
          } else if (player && 'onended' in player) {
            player.onended = () => { 
              prerecPlayingKey = null; 
              prerecAudioEl = null; 
            };
          }
        }).catch(err => {
          console.error('[预录制音频] ❌ 播放失败:', err);
          log('系统', `预录制音频播放失败: ${err.message}`, 'error');
          prerecPlayingKey = null; 
          prerecAudioEl = null;
          // 如需：这里可继续调用 tryAlternativeUrls(audioUrl, audioData, 0)
        });
      }

      function enqueueOrPlay(audioUrl, audioData) {
        if (!AudioGate.unlocked) {
          pendingAudioQueue.push({ url: audioUrl, audioData });
          console.log('[预录制音频] ⏸ AudioGate 未解锁，排队：', audioUrl);
          return;
        }
        doPlay(audioUrl, audioData);
      }

      function flushPendingAudio() {
        if (!AudioGate.unlocked) return;
        while (pendingAudioQueue.length) {
          const { url, audioData } = pendingAudioQueue.shift();
          doPlay(url, audioData);
        }
      }
      
      const elements = {
        connectionStatus: document.getElementById("connectionStatus"),
        statusHint: document.getElementById("statusHint"),
        channelName: document.getElementById("channelName"),
        localUid: document.getElementById("localUid"),
        remoteUid: document.getElementById("remoteUid"),
        remoteVolume: document.getElementById("remoteVolume"),
        connectButton: document.getElementById("connectButton"),
        disconnectButton: document.getElementById("disconnectButton"),
        volumeSlider: document.getElementById("volumeSlider"),
        micLevel: document.getElementById("micLevel"),
        micBar: document.getElementById("micBar"),
        logContainer: document.getElementById("logContainer"),
        wsStatus: document.getElementById("wsStatus"),
        wsStatusText: document.getElementById("wsStatusText"),
        wsMessageCount: document.getElementById("wsMessageCount"),
      };

      // 简单的字符串hash函数
      function simpleHash(str) {
        let hash = 0;
        if (str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // 转换为32位整数
        }
        return hash.toString();
      }

      function normalizeForHash(s) {
        // 移除"（触发预录制）"后缀，确保去重正确识别相同内容
        return (s || '')
          .replace(/（触发预录制）$/, '')  // 移除结尾的"（触发预录制）"
          .replace(/\s+/g, ' ')           // 合并空白，避免无意义差异
          .trim();
      }

      function shouldDedup(source, message, type) {
        const keyType = (type || source || 'info').toString().toLowerCase();
        const hash = simpleHash(`${keyType}|${normalizeForHash(message)}`);
        const now = Date.now();
        const prev = lastSeenMap.get(hash) || 0;

        if (now - prev < DEDUP_TTL_MS) {
          console.log(`[去重] ${keyType} 在 ${now - prev}ms 内重复，跳过: "${(message || '').slice(0,50)}..."`);
          return true;
        }
        lastSeenMap.set(hash, now);
        return false;
      }

      // 定期清理过期的hash记录，防止Map膨胀
      setInterval(() => {
        const now = Date.now();
        for (const [k, ts] of lastSeenMap.entries()) {
          if (now - ts > 60000) lastSeenMap.delete(k);
        }
      }, 30000);



      function log(source, message, type = "info") {
        // 统一 2 秒 TTL 去重
        if (shouldDedup(source, message, type)) return;
        
        const entry = document.createElement("div");
        entry.className = "log-entry";
        const timestamp = new Date().toLocaleTimeString();
        
        // 根据消息类型设置样式
        if (type === "stt" || source === "STT") {
          entry.classList.add("stt");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source stt">语音识别</span>
            <div>${message}</div>
          `;
        } else if (type === "llm" || source === "LLM") {
          entry.classList.add("llm");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source llm">AI回复</span>
            <div>${message}</div>
          `;
        } else if (type === "error") {
          entry.classList.add("error");
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source error">${source}</span>
            <div>${message}</div>
          `;
        } else {
          entry.innerHTML = `
            <time>${timestamp}</time>
            <span class="source">${source}</span>
            <div>${message}</div>
          `;
          if (type === "success") {
            entry.style.color = "#2f855a";
          }
        }
        
        elements.logContainer.appendChild(entry);
        elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
      }

      function setConnectionState(state, hint) {
        elements.connectionStatus.classList.remove("online", "offline", "idle");
        elements.connectionStatus.classList.add(state);
        elements.connectionStatus.textContent =
          state === "online"
            ? "已连接"
            : state === "offline"
            ? "未连接"
            : "准备中";
        if (hint) {
          elements.statusHint.textContent = hint;
        }
      }

      // WebSocket状态更新函数
      function updateWebSocketStatus(status, text) {
        elements.wsStatus.className = `websocket-status ${status}`;
        elements.wsStatusText.textContent = text;
      }

      // 显示错误弹窗
      function showErrorPopup(title, message) {
        // 移除已存在的错误弹窗
        const existingPopup = document.querySelector('.error-popup');
        if (existingPopup) {
          existingPopup.remove();
        }

        const popup = document.createElement('div');
        popup.className = 'error-popup';
        popup.innerHTML = `
          <button class="close-btn" onclick="this.parentElement.remove()">×</button>
          <div class="error-title">${title}</div>
          <div class="error-message">${message}</div>
        `;
        
        document.body.appendChild(popup);
        
        // 5秒后自动关闭
        setTimeout(() => {
          if (popup.parentElement) {
            popup.remove();
          }
        }, 5000);
      }

      // 🎵 预加载音频文件函数
      async function preloadAudioFiles() {
        try {
          console.log('[预加载] 🎵 开始预加载音频文件...');
          log('系统', '正在预加载音频文件...', 'info');
          
          // 加载缓存索引
          const cacheIndexUrl = './prerecorded_audio/cache_index.json';
          const response = await fetch(cacheIndexUrl);
          if (!response.ok) {
            console.warn('[预加载] ⚠️ 无法加载缓存索引，跳过预加载');
            return;
          }
          
          const cacheIndex = await response.json();
          const audioFiles = Object.values(cacheIndex).map(entry => entry.audio_file).filter(Boolean);
          console.log(`[预加载] 📋 发现 ${audioFiles.length} 个音频文件需要预加载`);
          
          // 限制并发预加载数量，避免过多请求
          const maxConcurrent = 3;
          let loadedCount = 0;
          let failedCount = 0;
          
          for (let i = 0; i < audioFiles.length; i += maxConcurrent) {
            const batch = audioFiles.slice(i, i + maxConcurrent);
            const promises = batch.map(async (audioFile) => {
              try {
                const audioUrl = staticPath(`prerecorded_audio/audio_files/${audioFile}`);
                
                // 使用 AudioGate 的音频池预加载
                // 这里我们不实际播放，只是让浏览器缓存这些文件
                const tempAudio = new Audio(audioUrl);
                tempAudio.preload = 'auto';
                tempAudio.volume = 0;
                
                return new Promise((resolve, reject) => {
                  tempAudio.oncanplaythrough = () => {
                    console.log(`[预加载] ✅ ${audioFile} 预加载成功`);
                    loadedCount++;
                    resolve();
                  };
                  tempAudio.onerror = () => {
                    console.warn(`[预加载] ⚠️ ${audioFile} 预加载失败`);
                    failedCount++;
                    resolve(); // 即使失败也继续
                  };
                  
                  // 设置超时
                  setTimeout(() => {
                    console.warn(`[预加载] ⏰ ${audioFile} 预加载超时`);
                    failedCount++;
                    resolve();
                  }, 5000);
                });
              } catch (error) {
                console.warn(`[预加载] ❌ ${audioFile} 预加载异常:`, error);
                failedCount++;
              }
            });
            
            await Promise.all(promises);
            
            // 显示进度
            const progress = Math.round(((i + batch.length) / audioFiles.length) * 100);
            console.log(`[预加载] 📊 进度: ${progress}% (${loadedCount}/${audioFiles.length} 成功, ${failedCount} 失败)`);
          }
          
          console.log(`[预加载] 🎉 预加载完成: ${loadedCount}/${audioFiles.length} 成功, ${failedCount} 失败`);
          log('系统', `音频预加载完成: ${loadedCount}/${audioFiles.length} 成功`, loadedCount > 0 ? 'success' : 'warning');
          
        } catch (error) {
          console.error('[预加载] ❌ 预加载过程出错:', error);
          log('系统', '音频预加载失败', 'error');
        }
      }

      // 🔧 尝试备用URL的函数
      function tryAlternativeUrls(originalPath, audioData, urlIndex) {
        const base = normalizeAudioPath(originalPath);
        const basename = base.split(/[\/\\]/).pop();
        const alternativeUrls = [
          normalizeAudioPath(`prerecorded_audio/audio_files/${basename}`),
          normalizeAudioPath(`prerecorded_audio/audio_files/${base}`),
          base.startsWith('prerecorded_audio/') ? normalizeAudioPath(base)
            : normalizeAudioPath(`prerecorded_audio/audio_files/${base}`)
        ];
        
        if (!AudioGate.unlocked) {
          // 等解锁后再重试，避免"未解锁→多次失败"刷屏
          pendingAudioQueue.push({ url: alternativeUrls[0], audioData });
          return;
        }
        
        if (urlIndex >= alternativeUrls.length) {
          console.error('[预录制音频] ❌ 所有备用URL都失败了');
          log('系统', '预录制音频: 所有URL都无法访问', 'error');
          return;
        }
        
        const testUrl = alternativeUrls[urlIndex];
        console.log(`[预录制音频] 🔧 测试备用URL ${urlIndex + 1}/${alternativeUrls.length}:`, testUrl);
        
        // 使用 AudioGate 尝试播放备用URL
        AudioGate.play(testUrl, { volume: 1.0 }).then(audioElement => {
          console.log(`[预录制音频] ✅ 备用URL ${urlIndex + 1} 成功:`, testUrl);
          log('系统', `预录制音频: 使用备用URL播放`, 'success');
          
          // 更新全局播放状态
          prerecAudioEl = audioElement;
          
          // 结束清理（同时兼容 <audio> 与 WebAudio）
          if (audioElement && typeof audioElement.addEventListener === 'function') {
            audioElement.addEventListener('ended', () => {
              console.log('[预录制音频] 备用URL音频播放完成');
              prerecPlayingKey = null;
              prerecAudioEl = null;
            });
          } else if (audioElement && 'onended' in audioElement) {
            audioElement.onended = () => {
              console.log('[预录制音频] 备用URL音频播放完成');
              prerecPlayingKey = null;
              prerecAudioEl = null;
            };
          }
        }).catch(error => {
          console.error(`[预录制音频] ❌ 备用URL ${urlIndex + 1} 失败:`, testUrl, error);
          tryAlternativeUrls(originalPath, audioData, urlIndex + 1);
        });
      }

      // 🔍 从缓存索引中查找并播放预录制音频
      async function tryFindAndPlayPrerecordedAudio(text, messageData) {
        try {
          console.log('[预录制音频] 🔍 开始查找音频文件:', text);
          
          // 🔍 尝试加载缓存索引
          const cacheIndexUrl = './prerecorded_audio/cache_index.json';
          console.log('[预录制音频] 🔍 加载缓存索引:', cacheIndexUrl);
          
          const response = await fetch(cacheIndexUrl);
          if (!response.ok) {
            console.error('[预录制音频] ❌ 无法加载缓存索引:', response.status, response.statusText);
            return;
          }
          
          const cacheIndex = await response.json();
          console.log('[预录制音频] 🔍 缓存索引加载成功，条目数:', Object.keys(cacheIndex).length);
          
          // 🔍 查找匹配的音频文件
          let foundEntry = null;
          let foundHash = null;
          
          // 方法1: 直接文本匹配
          for (const [hash, entry] of Object.entries(cacheIndex)) {
            if (entry.text === text || entry.normalized_text === text) {
              foundEntry = entry;
              foundHash = hash;
              console.log('[预录制音频] ✅ 找到匹配文本的音频文件 (精确匹配):', hash, entry.audio_file);
              break;
            }
          }
          
          // 方法2: 如果精确匹配失败，尝试模糊匹配
          if (!foundEntry) {
            const normalizedText = text.replace(/[，。！？；：""''（）【】]/g, '').replace(/\s+/g, '');
            for (const [hash, entry] of Object.entries(cacheIndex)) {
              const entryNormalized = (entry.normalized_text || entry.text || '').replace(/[，。！？；：""''（）【】]/g, '').replace(/\s+/g, '');
              if (entryNormalized === normalizedText) {
                foundEntry = entry;
                foundHash = hash;
                console.log('[预录制音频] ✅ 找到匹配文本的音频文件 (模糊匹配):', hash, entry.audio_file);
                break;
              }
            }
          }
          
          if (foundEntry && foundEntry.audio_file) {
            // 🎵 构建音频文件路径
            const audioFilePath = `prerecorded_audio/audio_files/${foundEntry.audio_file}`;
            console.log('[预录制音频] 🎵 构建音频文件路径:', audioFilePath);
            
            // 播放音频文件
            playPrerecordedAudio(audioFilePath, {
              text: text,
              audio_file: foundEntry.audio_file,
              hash: foundHash,
              ...messageData
            });
          } else {
            console.warn('[预录制音频] ⚠️ 未找到匹配的音频文件:', text);
            console.log('[预录制音频] 🔍 可用的音频文件列表:');
            Object.entries(cacheIndex).slice(0, 5).forEach(([hash, entry]) => {
              console.log(`  - ${hash}: "${entry.text || entry.normalized_text}"`);
            });
          }
          
        } catch (error) {
          console.error('[预录制音频] ❌ 查找音频文件失败:', error);
        }
      }

      // 播放预录制音频文件
      function playPrerecordedAudio(audioFilePath, audioData) {
        try {
          const key = keyFromAudioData(audioData, audioData?.text);
          const now = Date.now();
          const last = prerecRecent.get(key) || 0;
          if (now - last < PREREC_TTL_MS) {
            console.log('[预录制音频] 🧊 节流：短时间内重复触发，同Key跳过 ->', key);
            return;
          }
          // 如果当前就正在播放同一段，直接忽略
          if (prerecPlayingKey === key && prerecAudioEl && !prerecAudioEl.ended) {
            console.log('[预录制音频] 🔁 正在播放同一段，同Key跳过 ->', key);
            return;
          }
          prerecRecent.set(key, now);
          
          console.log('[预录制音频] 开始播放:', audioFilePath, audioData);
          log('系统', `播放预录制音频: ${audioData.text || '未知文本'}`, 'success');
          
          // 🔍 详细调试信息
          console.log('[预录制音频] 🔍 详细调试信息:');
          console.log('  - API_BASE_URL:', API_BASE_URL);
          console.log('  - audioFilePath:', audioFilePath);
          console.log('  - audioFilePath 类型:', typeof audioFilePath);
          console.log('  - audioData:', JSON.stringify(audioData, null, 2));
          
          // 构建音频文件的相对路径URL（仅前端静态资源）
          const normalized = normalizeAudioPath(audioFilePath);
          const audioUrl = normalized.startsWith('prerecorded_audio/')
            ? normalized
            : normalizeAudioPath(`prerecorded_audio/audio_files/${normalized}`);
          console.log('[预录制音频] 🎵 构建的音频URL (前端相对路径):', audioUrl);
          
          // 设置播放状态
          prerecPlayingKey = key;
          
          // 使用排队机制播放音频
          enqueueOrPlay(audioUrl, audioData);
          
        } catch (error) {
          console.error('[预录制音频] 播放函数执行失败:', error);
          log('系统', `预录制音频播放函数执行失败: ${error.message}`, 'error');
          // 异常时也释放锁
          prerecPlayingKey = null;
          prerecAudioEl = null;
        }
      }

      // 解析WebSocket调试消息
      function parseDebugMessage(message) {
        try {
          // 尝试解析JSON格式的消息
          const jsonMessage = JSON.parse(message);
          
          // 检查是否是预录制音频信号
          if (jsonMessage.type === 'prerecorded_audio' && jsonMessage.data) {
            const audioData = jsonMessage.data;
            console.log('[WebSocket] 收到预录制音频信号:', audioData);
            
            // 记录预录制音频播放时间
            lastPrerecordedAudioTime = Date.now();
            
            // 播放预录制音频文件
            if (audioData.audio_file_path) {
              playPrerecordedAudio(audioData.audio_file_path, audioData);
            }
            
            // 不返回消息对象，避免重复显示
            // 预录制音频的文本内容会通过 assistant_text 消息单独发送
            return null;
          }
          
          // 检查是否是新的assistant_text消息格式（优先处理）
          if (jsonMessage.type === 'assistant_text' && jsonMessage.data && jsonMessage.data.text) {
            const text = jsonMessage.data.text.trim();
            const kind = jsonMessage.data.kind || 'llm';
            const source = jsonMessage.data.source;
            
            // 仅标注为"触发预录制"，不设置音频时间戳
            if (source === 'prerecorded_cache') {
              return {
                type: (kind === 'stt') ? 'stt' : 'llm',
                content: `${text}（触发预录制）`
              };
            }
            
            // 检查是否是预录制音频相关的消息（在预录制音频播放后的短时间内）
            const now = Date.now();
            const isPrerecordedRelated = (now - lastPrerecordedAudioTime) < PRERECORDED_AUDIO_WINDOW;
            
            return {
              type: (kind === 'stt') ? 'stt' : 'llm',
              content: isPrerecordedRelated ? `${text}（触发预录制）` : text
            };
          }
          
          // 检查是否是旧的调试消息格式
          if (jsonMessage.type === 'debug' && jsonMessage.data && jsonMessage.data.message) {
            const debugText = jsonMessage.data.message.trim();
            console.log('[WebSocket] 解析JSON调试消息:', debugText);
            
            // 解析调试消息内容
            if (debugText.startsWith('[LLM_DEBUG]')) {
              return {
                type: 'llm',
                content: debugText.replace('[LLM_DEBUG]', '').trim()
              };
            } else if (debugText.startsWith('[STT_DEBUG]')) {
              return {
                type: 'stt',
                content: debugText.replace('[STT_DEBUG]', '').trim()
              };
            } else if (debugText.startsWith('[WELCOME]')) {
              return {
                type: 'llm',
                content: debugText.replace('[WELCOME]', '').trim()
              };
            } else if (debugText.includes('ERROR')) {
              // 匹配各种错误类型
              const errorTypes = ['VAD_ERROR', 'STT_ERROR', 'LLM_ERROR', 'TTS_ERROR'];
              for (const errorType of errorTypes) {
                if (debugText.includes(`[${errorType}]`)) {
                  return {
                    type: 'error',
                    source: errorType.replace('_ERROR', ''),
                    content: debugText.replace(`[${errorType}]`, '').trim()
                  };
                }
              }
              return {
                type: 'error',
                source: '系统',
                content: debugText
              };
            } else {
              return {
                type: 'info',
                content: debugText
              };
            }
          }
          
          // 检查是否是ping消息
          if (jsonMessage.type === 'ping') {
            return {
              type: 'ping',
              content: 'ping'
            };
          }
          
          // 处理其他类型的JSON消息
          return {
            type: 'info',
            content: `收到JSON消息: ${jsonMessage.type || '未知类型'}`
          };
          
        } catch (e) {
          // 如果不是JSON，按原来的文本格式处理
          const text = message.trim();
          console.log('[WebSocket] 解析文本调试消息:', text);
          
          // 匹配不同类型的调试消息
          if (text.startsWith('[LLM_DEBUG]')) {
            return {
              type: 'llm',
              content: text.replace('[LLM_DEBUG]', '').trim()
            };
          } else if (text.startsWith('[STT_DEBUG]')) {
            return {
              type: 'stt',
              content: text.replace('[STT_DEBUG]', '').trim()
            };
          } else if (text.startsWith('[WELCOME]')) {
            return {
              type: 'llm',
              content: text.replace('[WELCOME]', '').trim()
            };
          } else if (text.includes('ERROR')) {
            // 匹配各种错误类型
            const errorTypes = ['VAD_ERROR', 'STT_ERROR', 'LLM_ERROR', 'TTS_ERROR'];
            for (const errorType of errorTypes) {
              if (text.includes(`[${errorType}]`)) {
                return {
                  type: 'error',
                  source: errorType.replace('_ERROR', ''),
                  content: text.replace(`[${errorType}]`, '').trim()
                };
              }
            }
            return {
              type: 'error',
              source: '系统',
              content: text
            };
          } else {
            return {
              type: 'info',
              content: text
            };
          }
        }
      }

      // 连接WebSocket
      function connectWebSocket() {
        if (debugWebSocket && debugWebSocket.readyState === WebSocket.OPEN) {
          return; // 已经连接
        }

        updateWebSocketStatus('connecting', '连接中...');
        
        try {
          // 直接固定成域名 + /ws（由 Nginx 负责 TLS 和反代）
          const wsUrl = 'wss://cityuantifraud.cn/ws';
          
          console.log(`[WebSocket] 尝试连接: ${wsUrl}`);
          debugWebSocket = new WebSocket(wsUrl);
          
          debugWebSocket.onopen = function(event) {
            console.log('[WebSocket] 连接成功');
            updateWebSocketStatus('connected', '已连接');
            wsReconnectAttempts = 0;
            log('WebSocket', '调试连接已建立', 'success');
            
            // 发送bind消息以绑定客户端（扁平JSON格式）
            try {
              const bindMessage = JSON.stringify({
                type: 'bind',
                client_id: 'web_console',
                client_type: 'web_client'
              });
              debugWebSocket.send(bindMessage);
              console.log('[WebSocket] 已发送bind消息:', bindMessage);
            } catch (error) {
              console.error('[WebSocket] 发送bind消息失败:', error);
            }
          };
          
          debugWebSocket.onmessage = function(event) {
            wsMessageCount++;
            elements.wsMessageCount.textContent = wsMessageCount;
            
            // 添加详细的WebSocket消息接收日志
            console.log('[WebSocket] 收到消息:', event.data);
            console.log('[WebSocket] 消息计数:', wsMessageCount);
            
            try {
              const parsed = parseDebugMessage(event.data);
              console.log('[WebSocket] 解析后的消息:', parsed);
              
              // 检查parsed是否为null（预录制音频消息会返回null）
              if (parsed === null) {
                console.log('[WebSocket] 预录制音频消息已处理，跳过后续处理');
                return;
              }
              
              if (parsed.type === 'ping') {
                // 响应ping消息，发送pong
                try {
                  const pongMessage = JSON.stringify({
                    type: 'pong',
                    data: {}
                  });
                  debugWebSocket.send(pongMessage);
                  console.log('[WebSocket] 💓 收到ping，已发送pong响应');
                } catch (error) {
                  console.error('[WebSocket] 发送pong响应失败:', error);
                }
              } else if (parsed.type === 'stt') {
                log('STT', parsed.content, 'stt');
                console.log('[WebSocket] STT消息已处理:', parsed.content);
              } else if (parsed.type === 'llm') {
                log('LLM', parsed.content, 'llm');
                console.log('[WebSocket] LLM消息已处理:', parsed.content);
              } else if (parsed.type === 'error') {
                log(parsed.source, parsed.content, 'error');
                showErrorPopup(`${parsed.source}错误`, parsed.content);
                console.log('[WebSocket] 错误消息已处理:', parsed.source, parsed.content);
              } else {
                log('调试', parsed.content);
                console.log('[WebSocket] 调试消息已处理:', parsed.content);
              }
            } catch (error) {
              console.error('[WebSocket] 消息解析失败:', error, '原始消息:', event.data);
              log('WebSocket', `消息解析失败: ${error.message}`, 'error');
            }
          };
          
          debugWebSocket.onclose = function(event) {
            console.log('[WebSocket] 连接关闭:', event.code, event.reason);
            updateWebSocketStatus('disconnected', '已断开');
            
            // 自动重连逻辑
            if (wsReconnectAttempts < WS_MAX_RECONNECT_ATTEMPTS) {
              wsReconnectAttempts++;
              log('WebSocket', `连接断开，${WS_RECONNECT_DELAY/1000}秒后尝试重连 (${wsReconnectAttempts}/${WS_MAX_RECONNECT_ATTEMPTS})`);
              
              wsReconnectTimer = setTimeout(() => {
                connectWebSocket();
              }, WS_RECONNECT_DELAY);
            } else {
              log('WebSocket', '重连次数已达上限，请手动刷新页面', 'error');
            }
          };
          
          debugWebSocket.onerror = function(error) {
            console.error('[WebSocket] 连接错误:', error);
            updateWebSocketStatus('disconnected', '连接失败');
            log('WebSocket', '连接出现错误', 'error');
          };
          
        } catch (error) {
          console.error('[WebSocket] 创建连接失败:', error);
          updateWebSocketStatus('disconnected', '创建失败');
          log('WebSocket', `创建连接失败: ${error.message}`, 'error');
        }
      }

      // 断开WebSocket连接
      function disconnectWebSocket() {
        if (wsReconnectTimer) {
          clearTimeout(wsReconnectTimer);
          wsReconnectTimer = null;
        }
        
        if (debugWebSocket) {
          debugWebSocket.close();
          debugWebSocket = null;
        }
        
        updateWebSocketStatus('disconnected', '未连接');
        wsReconnectAttempts = 0;
      }

      async function fetchAgoraConfig(role = "publisher") {
        if (role === "publisher" && agoraConfigCache) {
          return agoraConfigCache;
        }
        const url = new URL("/api/agora/config", backendBaseUrl);
        url.searchParams.set("role", role);
        const response = await fetch(url.toString(), {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        if (!response.ok) {
          throw new Error(`后端接口返回 ${response.status}`);
        }
        const config = await response.json();
        if (!config || !config.appId) {
          throw new Error("后端缺少声网 App ID");
        }

        // UID配置验证
        const validationResult = WebUIDValidator.validateConfiguration(config);
        if (!validationResult.isValid) {
          console.error("[CONFIG] UID配置验证失败:", validationResult.errors);
          throw new Error(`UID配置无效: ${validationResult.errors.join(", ")}`);
        }

        if (validationResult.warnings.length > 0) {
          console.warn("[CONFIG] UID配置警告:", validationResult.warnings);
        }

        // 记录UID信息
        WebUIDValidator.logUIDInfo("配置验证", config.botUid, {
          userUID: config.uid,
          channel: config.channel,
        });

        if (role === "publisher") {
          agoraConfigCache = config;
        }
        return config;
      }

      function startMicMeter(track) {
        try {
          const streamTrack = track.getMediaStreamTrack();
          if (!streamTrack) {
            return;
          }
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(
            new MediaStream([streamTrack])
          );
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          micDataArray = new Uint8Array(bufferLength);
          source.connect(analyser);

          const update = () => {
            analyser.getByteTimeDomainData(micDataArray);
            let sum = 0;
            for (let i = 0; i < micDataArray.length; i += 1) {
              const value = micDataArray[i] - 128;
              sum += value * value;
            }
            const rms = Math.sqrt(sum / micDataArray.length);
            const level = Math.min(
              100,
              Math.max(0, Math.round((rms / 128) * 100))
            );
            elements.micLevel.textContent = `${level}%`;
            if (elements.micBar) {
              elements.micBar.style.width = `${level}%`;
            }
            meterAnimation = requestAnimationFrame(update);
          };
          update();
        } catch (error) {
          log("系统", `麦克风电平监控异常: ${error.message}`);
        }
      }

      function stopMicMeter() {
        if (meterAnimation) {
          cancelAnimationFrame(meterAnimation);
          meterAnimation = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        analyser = null;
        micDataArray = null;
        elements.micLevel.textContent = "0%";
        if (elements.micBar) {
          elements.micBar.style.width = "0%";
        }
      }

      // 竞争性单通道相关变量
      const CHANNEL = "solidchannel";
      let sessionId, token, uid, appId;
      let beatTimer;
      let remoteCheckTimer = null; // ✅ 新增：远端用户定时检查计时器（全局）
      let clientHandlers = {
        userUnpublished: null,
        userLeft: null,
        connectionStateChange: null,
      };
      async function leaveAndCleanup() {
        try {
          if (client && client.connectionState !== "DISCONNECTED") {
            await client.leave();
            log("声网", "已离开频道");
          }
        } catch(e) {
          console.error("离开频道失败:", e);
        }
        
        try {
          if (sessionId) {
            // sendBeacon 确保页面关闭时也能发出
            const leaveUrl = `${API_BASE_URL}/rtc/leave`;
            navigator.sendBeacon(leaveUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
            log("系统", "已释放房间锁");
          }
          
          // 关闭RTC系统（释放Agora资源）
          const shutdownUrl = `${API_BASE_URL}/api/rtc/shutdown`;
          navigator.sendBeacon(shutdownUrl, new Blob([JSON.stringify({})], {type:"application/json"}));
          log("系统", "已请求关闭RTC系统");
          
        } catch(e) {
          console.error("释放资源失败:", e);
        }
        
        clearInterval(beatTimer); 
        beatTimer = null;
        sessionId = token = uid = appId = null;
        
        // 清理音频轨道
        if (microphoneAudioTrack) {
          microphoneAudioTrack.close();
          microphoneAudioTrack = null;
        }
        // ✅ 退出时复位全局回调，避免二次进入页面出现异常行为
        try {
          AgoraRTC.onAutoplayFailed = null;
        } catch (_) {}

        // ✅ 统一清理远端检查定时器
        if (remoteCheckTimer) {
          clearInterval(remoteCheckTimer);
          remoteCheckTimer = null;
        }

        setConnectionState("offline", "已断开连接");
        elements.connectButton.disabled = false;
        isConnecting = false;
      }

      async function enterAndJoin() {
        if (isConnecting) {
          return;
        }
        isConnecting = true;
        
        setConnectionState("idle", "正在初始化RTC系统...");
        elements.connectButton.disabled = true;
        log("系统", "开始初始化RTC系统...");

        try {
          // 0) 先初始化RTC系统（按需启动Agora连接）
          const initUrl = `${API_BASE_URL}/api/rtc/init`;
          console.log("初始化RTC系统URL:", initUrl);
          const initResponse = await fetch(initUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({})
          });
          
          if (!initResponse.ok) {
            throw new Error(`RTC初始化失败 HTTP ${initResponse.status}: ${initResponse.statusText}`);
          }
          
          const initResult = await initResponse.json();
          if (!initResult.ok) {
            throw new Error(`RTC初始化失败: ${initResult.error}`);
          }
          
          log("系统", "✅ RTC系统初始化成功，正在申请进入房间...");
          setConnectionState("idle", "正在申请进入房间...");

          // 启动WebSocket调试连接
          connectWebSocket();

          // 1) 申请进入（拿锁+拿token）
          const enterUrl = `${API_BASE_URL}/rtc/enter`;
          console.log("请求URL:", enterUrl);
          const response = await fetch(enterUrl, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({ channel: CHANNEL })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const r = await response.json();

          if (!r.ok) {
            if (r.reason === "BUSY") {
              alert("当前线路正忙，请稍后再试。");
              log("系统", "房间被占用，无法进入", "error");
            } else {
              alert(`进入房间失败: ${r.reason}`);
              log("系统", `进入房间失败: ${r.reason}`, "error");
            }
            setConnectionState("offline", "进入房间失败");
            elements.connectButton.disabled = false;
            isConnecting = false;
            return;
          }

          sessionId = r.sessionId; 
          token = r.token; 
          uid = r.uid; 
          appId = r.appId;
          
          log("系统", `成功获取房间锁，会话ID: ${sessionId}`);
          elements.localUid.textContent = uid || "-";
          elements.channelName.textContent = CHANNEL;

          // 2) 心跳（10s一次）——断网/崩溃后 25s 自动释放
          beatTimer = setInterval(()=> {
            const beatUrl = `${API_BASE_URL}/rtc/beat`;
            navigator.sendBeacon(beatUrl, new Blob([JSON.stringify({channel:CHANNEL, sessionId})], {type:"application/json"}));
          }, 10000);

          setConnectionState("idle", "正在加入声网频道...");
          
          if (client.connectionState !== "DISCONNECTED") {
            await client.leave().catch(() => {});
          }

          // 3) 加入频道
          await client.join(appId, CHANNEL, token, uid);
          log("声网", `已加入频道 ${CHANNEL}`);

          // 🚀 关键修复：立即绑定事件监听，避免错过 Bot 的 published 事件
          console.log("[FLOW] 🔧 立即绑定事件监听器...");
          bindClientEvents();

          // 4) 初始化订阅管理器（监听Bot用户）
          const config = await fetchAgoraConfig("publisher"); // 获取botUid
          subscriptionManager = new WebSubscriptionManager(client, {
            maxRetryAttempts: 3,
            retryDelay: 2000,
            enableAutoSubscribe: true,
            logLevel: "info",
          });
          // 注意：WebSubscriptionManager不需要initialize方法，构造函数已完成初始化
          // subscriptionManager.setSubscriptionCallback(handleSubscription); // 此方法也不存在，使用回调属性代替

          subscriptionManager.onSubscriptionSuccess = (uid, mediaType, result) => {
            console.log(`[SUBSCRIPTION] ✅ 订阅成功: ${uid} (${mediaType})`);
            log("订阅", `成功订阅用户 ${uid} 的${mediaType === "audio" ? "音频" : "视频"}流`);

            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              console.log(`[SUBSCRIPTION] 🤖 Bot用户音频订阅成功，开始播放`);

              // 保存全局变量，方便 autoplayFailed 或断开时清理
              remoteAudioTrack = result || client.remoteUsers.find(u => String(u.uid) === String(uid))?.audioTrack;

              if (remoteAudioTrack) {
                try {
                  remoteAudioTrack.play("remoteAudio");
                  console.log("[SUBSCRIPTION] Bot音频已播放");
                } catch (err) {
                  console.warn("[SUBSCRIPTION] 播放失败，可能是 autoplay 限制:", err);
                }
              } else {
                console.error("[SUBSCRIPTION] 订阅成功但未获取到 audioTrack 对象");
              }
            }
          };



          subscriptionManager.onSubscriptionFailed = (
            uid,
            mediaType,
            error
          ) => {
            console.error(
              `[SUBSCRIPTION] ❌ 订阅失败: ${uid} (${mediaType})`,
              error
            );
            log(
              "订阅",
              `订阅用户 ${uid} 的${
                mediaType === "audio" ? "音频" : "视频"
              }流失败: ${error.message}`,
              "error"
            );
          };

          subscriptionManager.onSubscriptionStateChanged = (
            uid,
            mediaType,
            state
          ) => {
            console.log(
              `[SUBSCRIPTION] 🔄 订阅状态变化: ${uid} (${mediaType}) -> ${state}`
            );

            // 更新UI显示
            if (WebUIDValidator.isBotUser(uid) && mediaType === "audio") {
              const stateText =
                {
                  not_subscribed: "未订阅",
                  subscribing: "订阅中",
                  subscribed: "已订阅",
                  subscription_failed: "订阅失败",
                  unsubscribing: "取消订阅中",
                }[state] || state;

              elements.remoteUid.textContent = `Bot(${uid}) - ${stateText}`;
            }
          };

          console.log("[SUBSCRIPTION] 订阅管理器初始化完成，已设置回调函数");

          // 🚀 关键修复：立即扫描并补订现有的 Bot 用户
          console.log("[FLOW] 🔍 扫描并补订现有 Bot 用户...");
          await scanAndSubscribeExistingBots();

          // [DEBUG] 检查当前远端用户
          console.log("[DEBUG] 当前远端用户:", client.remoteUsers);
          console.log("[DEBUG] 远端用户数量:", client.remoteUsers.length);
          client.remoteUsers.forEach((user) => {
            console.log("[DEBUG] 远端用户详情:", {
              uid: user.uid,
              hasAudio: user.hasAudio,
              hasVideo: user.hasVideo,
            });
          });

          // [AUDIO_FLOW] 检查麦克风权限和设备
          try {
            const devices = await AgoraRTC.getDevices();
            const audioInputs = devices.filter(
              (device) => device.kind === "audioinput"
            );
            console.log(
              "[AUDIO_FLOW] 可用音频输入设备:",
              audioInputs.map((d) => ({ id: d.deviceId, label: d.label }))
            );

            if (audioInputs.length === 0) {
              console.warn("[AUDIO_FLOW] 警告: 未检测到音频输入设备");
            }
          } catch (error) {
            console.error("[AUDIO_FLOW] 获取音频设备失败:", error);
          }

          // 创建和发布音频轨道
          console.log("[AUDIO_FLOW] 开始创建麦克风音频轨道...");
          microphoneAudioTrack = await AgoraRTC.createMicrophoneAudioTrack({
            encoderConfig: {
              sampleRate: 48000,
              stereo: false,
            },
          });
          localTrack = microphoneAudioTrack; // 保持兼容性

          // [AUDIO_FLOW] 音频轨道创建成功调试日志
          console.log("[AUDIO_FLOW] 麦克风音频轨道已创建:", {
            trackId: microphoneAudioTrack.getTrackId(),
            enabled: microphoneAudioTrack.enabled,
            muted: microphoneAudioTrack.muted,
            sampleRate: 48000,
          });

          await client.publish(microphoneAudioTrack);

          // [AUDIO_FLOW] 音频发布成功调试日志
          console.log("[AUDIO_FLOW] 本地音频已发布到声网:", {
            trackId: microphoneAudioTrack.getTrackId(),
            published: true,
            clientState: client.connectionState,
          });

          log("声网", "本地音频已发布");

          // [AUDIO_FLOW] 添加音频数据处理器监听音频流
          if (microphoneAudioTrack) {
            let audioFrameCounter = 0;
            try {
              const processor = {
                process: (audioBuffer) => {
                  audioFrameCounter++;
                  if (audioFrameCounter % 100 === 0) {
                    console.log(
                      "[AUDIO_FLOW] 音频数据流经声网SDK (第" +
                        audioFrameCounter +
                        "帧):",
                      {
                        sampleRate: audioBuffer.sampleRate,
                        numberOfChannels: audioBuffer.numberOfChannels,
                        length: audioBuffer.length,
                        timestamp: Date.now(),
                      }
                    );
                  }
                  return audioBuffer;
                },
              };

              if (localTrack.pipe && typeof localTrack.pipe === "function") {
                localTrack.pipe(processor);
                console.log("[AUDIO_FLOW] 音频处理器已添加到本地轨道");
              } else {
                console.log(
                  "[AUDIO_FLOW] 本地轨道不支持pipe方法，尝试其他监听方式"
                );
              }
            } catch (error) {
              console.log("[AUDIO_FLOW] 添加音频处理器失败:", error.message);
            }

            startMicMeter(microphoneAudioTrack);
          }

          // 处理 Autoplay 限制
          AgoraRTC.onAutoplayFailed = () => {
            console.warn("[WARN] Autoplay 被限制，创建恢复按钮");
            const btn = document.createElement("button");
            btn.innerText = "点击恢复 Bot 音频";
            btn.style.padding = "12px";
            btn.style.margin = "16px";
            btn.style.background = "#48bb78";
            btn.style.color = "#fff";
            btn.style.borderRadius = "8px";
            btn.onclick = () => {
              if (remoteAudioTrack) {
                remoteAudioTrack.play("remoteAudio");
                console.log("[DEBUG] 用户点击后恢复播放成功");
              }
              btn.remove();
            };
            document.body.appendChild(btn);
          };

          // 🚀 关键修复：在所有准备工作完成后再触发欢迎语
          console.log("[FLOW] 🎉 所有准备工作完成，现在触发欢迎语...");
          try {
            const resp = await fetch(`${API_BASE_URL}/api/rtc/welcome`, {
              method: "POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({})
            });
            const data = await resp.json();
            console.log("[WELCOME] 触发结果:", data);
            if (data.ok && data.welcome_sent) {
              log("系统", "✅ 欢迎语已触发（音频订阅已就绪）");
            } else {
              console.warn("[WELCOME] 触发失败或未发送:", data);
            }
          } catch (err) {
            console.error("[WELCOME] 请求出错:", err);
          }

          // --- 新增：加入后主动检查Bot用户并可能启动重试 ---
          if (subscriptionManager) {
            // 可以选择性地延迟一下，确保 SDK 状态更稳定，或者直接调用
            // setTimeout(() => {
              subscriptionManager.checkBotUsersForRetry();
            // }, 100); // 延迟 100ms，可选
          } else {
            console.warn("SubscriptionManager 未找到，无法检查Bot用户重试。");
          }
          // --- 新增结束 ---

          setConnectionState("online", "声网链路已建立，等待 Bot 音频...");
          elements.disconnectButton.disabled = false;
          log("系统", "连接完成，Bot 音频将自动播放");

          // ?? 添加：定时检查频道内的远端用户（增强版）
          if (remoteCheckTimer) { clearInterval(remoteCheckTimer); remoteCheckTimer = null; } // 避免重复
          remoteCheckTimer = setInterval(() => {
            const remoteUsers = client.remoteUsers;
            console.log("[CHECK] =========================");
            console.log("[CHECK] 频道内远端用户总数:", remoteUsers.length);

            if (remoteUsers.length === 0) {
              console.log("[CHECK] ?? 频道内无远端用户");
            } else {
              remoteUsers.forEach((user) => {
                console.log(`[CHECK] 用户 ${user.uid}:`, {
                  hasAudioTrack: !!user.audioTrack,
                  hasVideoTrack: !!user.videoTrack,
                  isPlaying: user.audioTrack?.isPlaying,
                  audioTrackType: typeof user.audioTrack,
                  audioTrackObject: user.audioTrack,
                });

                if (user.audioTrack) {
                  console.log(
                    `[CHECK] ? 用户 ${user.uid} 有音频轨道，播放状态: ${user.audioTrack.isPlaying}`
                  );
                } else {
                  console.log(`[CHECK] ? 用户 ${user.uid} 无音频轨道`);
                }

                // 特别检查Bot UID - 使用UID验证器
                if (WebUIDValidator.isBotUser(user.uid)) {
                  console.log(
                    `[CHECK] 🤖 检测到Bot用户 ${
                      user.uid
                    }! (类型: ${typeof user.uid})`
                  );
                  WebUIDValidator.logUIDInfo("Bot用户检测", user.uid, {
                    hasAudioTrack: !!user.audioTrack,
                    isPlaying: user.audioTrack?.isPlaying,
                  });
                  if (!user.audioTrack) {
                    console.log(
                      `[CHECK] ⚠️ Bot用户无音频轨道，可能需要手动订阅`
                    );
                  }
                }
              });
            }
            console.log("[CHECK] =========================");
          }, 5000); // 每5秒检查一次
        } catch (error) {
          log("错误", `连接失败: ${error.message}`, "error");
          await disconnect();
        } finally {
          isConnecting = false;
          if (!elements.disconnectButton.disabled) {
            elements.connectButton.disabled = true;
          } else {
            elements.connectButton.disabled = false;
          }
        }
      }
      function bindClientEvents() {
        // 先防御性解绑（避免极端情况下重复绑定）
        unbindClientEvents();

        // 🚀 关键修复：立即订阅 Bot 音频，避免延迟
        clientHandlers.userPublished = async (user, mediaType) => {
          console.log("[EVENT] user-published:", user.uid, mediaType);
          
          // 如果是 Bot 用户发布音频，立即订阅
          if (mediaType === "audio" && WebUIDValidator.isBotUser(user.uid)) {
            try {
              console.log(`[AUTO] 🤖 检测到 Bot ${user.uid} 发布音频，立即订阅...`);
              await client.subscribe(user, "audio");
              
              remoteAudioTrack = user.audioTrack;
              if (remoteAudioTrack) {
                // 设置音量
                const volume = parseInt(elements.volumeSlider.value) || 70;
                remoteAudioTrack.setVolume(volume);
                
                // 开始播放
                remoteAudioTrack.play("remoteAudio");
                console.log(`[AUTO] ✅ Bot ${user.uid} 音频已订阅并开始播放`);
                log("自动订阅", `Bot ${user.uid} 音频已连接并播放`);
                
                // 更新UI状态
                elements.remoteUid.textContent = `Bot(${user.uid}) - 已连接`;
              } else {
                console.error(`[AUTO] ❌ 订阅成功但未获取到 audioTrack`);
              }
            } catch (err) {
              console.error(`[AUTO] ❌ 立即订阅 Bot ${user.uid} 音频失败:`, err);
              log("订阅失败", `Bot ${user.uid} 音频订阅失败: ${err.message}`, "error");
            }
          }
        };

        clientHandlers.userUnpublished = (user, mediaType) => {
          console.log("[EVENT] user-unpublished:", user.uid, mediaType);
          if (WebUIDValidator.isBotUser(user.uid) && mediaType === "audio") {
            elements.remoteUid.textContent = "-";
            log("取消发布", `Bot ${user.uid} 取消发布音频`);
          }
        };

        clientHandlers.userLeft = (user) => {
          console.log("[EVENT] user-left:", user.uid);
          if (WebUIDValidator.isBotUser(user.uid)) {
            elements.remoteUid.textContent = "-";
            log("离开", `Bot ${user.uid} 已离开`);
          }
        };

        clientHandlers.connectionStateChange = (cur, prev, reason) => {
          log("声网", `连接状态: ${prev} -> ${cur} (${reason})`);
        };

        // 绑定所有事件
        client.on("user-published", clientHandlers.userPublished);
        client.on("user-unpublished", clientHandlers.userUnpublished);
        client.on("user-left", clientHandlers.userLeft);
        client.on("connection-state-change", clientHandlers.connectionStateChange);
      }

      // 🚀 关键修复：扫描并补订现有的 Bot 用户
      async function scanAndSubscribeExistingBots() {
        console.log("[SCAN] 开始扫描现有远端用户...");
        const remoteUsers = client.remoteUsers;
        console.log(`[SCAN] 发现 ${remoteUsers.length} 个远端用户`);
        
        for (const user of remoteUsers) {
          console.log(`[SCAN] 检查用户 ${user.uid}:`, {
            hasAudio: user.hasAudio,
            audioTrack: !!user.audioTrack,
            isBotUser: WebUIDValidator.isBotUser(user.uid)
          });
          
          if (WebUIDValidator.isBotUser(user.uid) && (user.hasAudio || user.audioTrack)) {
            try {
              console.log(`[SCAN] 🤖 发现现有 Bot ${user.uid}，立即补订音频...`);
              
              // 如果还没有订阅，则订阅
              if (!user.audioTrack) {
                await client.subscribe(user, "audio");
                console.log(`[SCAN] ✅ 补订 Bot ${user.uid} 音频成功`);
              }
              
              remoteAudioTrack = user.audioTrack;
              if (remoteAudioTrack) {
                // 设置音量
                const volume = parseInt(elements.volumeSlider.value) || 70;
                remoteAudioTrack.setVolume(volume);
                
                // 开始播放
                remoteAudioTrack.play("remoteAudio");
                console.log(`[SCAN] ✅ Bot ${user.uid} 音频已开始播放`);
                log("补订成功", `发现并连接了 Bot ${user.uid} 音频`);
                
                // 更新UI状态
                elements.remoteUid.textContent = `Bot(${user.uid}) - 已连接`;
                break; // 找到一个Bot就够了
              }
            } catch (err) {
              console.error(`[SCAN] ❌ 补订 Bot ${user.uid} 音频失败:`, err);
              log("补订失败", `Bot ${user.uid} 音频补订失败: ${err.message}`, "error");
            }
          }
        }
        
        if (remoteUsers.length === 0) {
          console.log("[SCAN] 当前频道内无远端用户，等待 Bot 加入...");
        }
      }

      function unbindClientEvents() {
        if (clientHandlers.userPublished) {
          client.off("user-published", clientHandlers.userPublished);
        }
        if (clientHandlers.userUnpublished) {
          client.off("user-unpublished", clientHandlers.userUnpublished);
        }
        if (clientHandlers.userLeft) {
          client.off("user-left", clientHandlers.userLeft);
        }
        if (clientHandlers.connectionStateChange) {
          client.off("connection-state-change", clientHandlers.connectionStateChange);
        }
        // 可选：重置为 null，避免误用旧指针
        clientHandlers = {
          userPublished: null,
          userUnpublished: null,
          userLeft: null,
          connectionStateChange: null,
        };
      }
      async function disconnect() {
        elements.disconnectButton.disabled = true;
        
        try {

          // ① 先解绑所有 client 事件（对称）
          unbindClientEvents();
             // （可留着你的这行，等价防御）
          // client.off("connection-state-change");
          
         // ② 关远端/本地轨道
          if (remoteAudioTrack) {
            remoteAudioTrack.stop();
            remoteAudioTrack.close();
            remoteAudioTrack = null;
          }

          if (localTrack) {
            localTrack.stop();
            localTrack.close();
            localTrack = null;
          }
          // ③ 停止电平动画
          stopMicMeter();

           // ✅ 统一清理远端检查定时器
          if (remoteCheckTimer) {
            clearInterval(remoteCheckTimer);
            remoteCheckTimer = null;
          }
          // ✅ 退出时复位全局回调，避免二次进入页面出现异常行为
          try {
            AgoraRTC.onAutoplayFailed = null;
          } catch (_) {}

          // 清理订阅管理器
          if (subscriptionManager) {
            subscriptionManager.destroy();
            subscriptionManager = null;
            console.log("[SUBSCRIPTION] 订阅管理器已清理");
          }

          // 断开WebSocket连接
          disconnectWebSocket();
         

          // 调用统一的清理函数（包含房间锁释放）
          await leaveAndCleanup();
        } catch (error) {
          log("错误", `断开连接出现问题: ${error.message}`);
          // 即使出错也要尝试清理
          await leaveAndCleanup();
        }
      }

      
    
      // 修改为先解锁音频再入会
      elements.connectButton.addEventListener("click", async () => {
        await AudioGate.unlock();   // ✅ 一次性解锁
        flushPendingAudio();         // ✅ 一次性处理未解锁期间积压的播放
        preloadAudioFiles();         // ✅ 解锁后预加载音频文件，避免移动端过早拉资源
        await enterAndJoin();       // 然后照常入会
      });
      elements.disconnectButton.addEventListener("click", disconnect);

      elements.volumeSlider.addEventListener("input", (event) => {
        const volume = Number(event.target.value || "70");
        elements.remoteVolume.textContent = `${volume}%`;
        if (remoteAudioTrack) {
          remoteAudioTrack.setVolume(volume);
        }
      });





      // —— 挂到所有退出路径 ——
      // 1) 关闭/刷新
      window.addEventListener("beforeunload", leaveAndCleanup);
      window.addEventListener("pagehide", leaveAndCleanup);     // iOS Safari
      // 2) 页面可见性变化（可选：后台停播，前台再播）
      window.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          console.log("[DEBUG] 页面进入后台");
          // 可选：暂停某些操作
        } else {
          console.log("[DEBUG] 页面回到前台");
          // 可选：恢复某些操作
        }
      });

      log("系统", "页面加载完成，点击按钮即可体验声网 RTC 链路。");
      
      // 页面加载时尝试连接WebSocket调试服务
      log("系统", "正在连接WebSocket调试服务...");
      connectWebSocket();
    </script>
  </body>
</html>
